// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session/commands.proto

#ifndef PROTOBUF_session_2fcommands_2eproto__INCLUDED
#define PROTOBUF_session_2fcommands_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "config/config.pb.h"
#include "session/candidates.pb.h"
#include "dictionary/user_dictionary_storage.pb.h"
// @@protoc_insertion_point(includes)

namespace mozc {
namespace commands {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_session_2fcommands_2eproto();
void protobuf_AssignDesc_session_2fcommands_2eproto();
void protobuf_ShutdownFile_session_2fcommands_2eproto();

class KeyEvent;
class KeyEvent_ProbableKeyEvent;
class GenericStorageEntry;
class SessionCommand;
class Context;
class Capability;
class Request;
class ApplicationInfo;
class Input;
class Input_TouchPosition;
class Input_TouchEvent;
class Result;
class Preedit;
class Preedit_Segment;
class Status;
class DeletionRange;
class Output;
class Output_Callback;
class Command;
class CommandList;

enum KeyEvent_SpecialKey {
  KeyEvent_SpecialKey_NO_SPECIALKEY = 0,
  KeyEvent_SpecialKey_DIGIT = 1,
  KeyEvent_SpecialKey_ON = 2,
  KeyEvent_SpecialKey_OFF = 3,
  KeyEvent_SpecialKey_SPACE = 4,
  KeyEvent_SpecialKey_ENTER = 5,
  KeyEvent_SpecialKey_LEFT = 6,
  KeyEvent_SpecialKey_RIGHT = 7,
  KeyEvent_SpecialKey_UP = 8,
  KeyEvent_SpecialKey_DOWN = 9,
  KeyEvent_SpecialKey_ESCAPE = 10,
  KeyEvent_SpecialKey_DEL = 11,
  KeyEvent_SpecialKey_BACKSPACE = 12,
  KeyEvent_SpecialKey_HENKAN = 13,
  KeyEvent_SpecialKey_MUHENKAN = 14,
  KeyEvent_SpecialKey_KANA = 15,
  KeyEvent_SpecialKey_HOME = 16,
  KeyEvent_SpecialKey_END = 17,
  KeyEvent_SpecialKey_TAB = 18,
  KeyEvent_SpecialKey_F1 = 19,
  KeyEvent_SpecialKey_F2 = 20,
  KeyEvent_SpecialKey_F3 = 21,
  KeyEvent_SpecialKey_F4 = 22,
  KeyEvent_SpecialKey_F5 = 23,
  KeyEvent_SpecialKey_F6 = 24,
  KeyEvent_SpecialKey_F7 = 25,
  KeyEvent_SpecialKey_F8 = 26,
  KeyEvent_SpecialKey_F9 = 27,
  KeyEvent_SpecialKey_F10 = 28,
  KeyEvent_SpecialKey_F11 = 29,
  KeyEvent_SpecialKey_F12 = 30,
  KeyEvent_SpecialKey_PAGE_UP = 31,
  KeyEvent_SpecialKey_PAGE_DOWN = 32,
  KeyEvent_SpecialKey_INSERT = 33,
  KeyEvent_SpecialKey_F13 = 34,
  KeyEvent_SpecialKey_F14 = 35,
  KeyEvent_SpecialKey_F15 = 36,
  KeyEvent_SpecialKey_F16 = 37,
  KeyEvent_SpecialKey_F17 = 38,
  KeyEvent_SpecialKey_F18 = 39,
  KeyEvent_SpecialKey_F19 = 40,
  KeyEvent_SpecialKey_F20 = 41,
  KeyEvent_SpecialKey_F21 = 42,
  KeyEvent_SpecialKey_F22 = 43,
  KeyEvent_SpecialKey_F23 = 44,
  KeyEvent_SpecialKey_F24 = 45,
  KeyEvent_SpecialKey_EISU = 46,
  KeyEvent_SpecialKey_NUMPAD0 = 47,
  KeyEvent_SpecialKey_NUMPAD1 = 48,
  KeyEvent_SpecialKey_NUMPAD2 = 49,
  KeyEvent_SpecialKey_NUMPAD3 = 50,
  KeyEvent_SpecialKey_NUMPAD4 = 51,
  KeyEvent_SpecialKey_NUMPAD5 = 52,
  KeyEvent_SpecialKey_NUMPAD6 = 53,
  KeyEvent_SpecialKey_NUMPAD7 = 54,
  KeyEvent_SpecialKey_NUMPAD8 = 55,
  KeyEvent_SpecialKey_NUMPAD9 = 56,
  KeyEvent_SpecialKey_MULTIPLY = 57,
  KeyEvent_SpecialKey_ADD = 58,
  KeyEvent_SpecialKey_SEPARATOR = 59,
  KeyEvent_SpecialKey_SUBTRACT = 60,
  KeyEvent_SpecialKey_DECIMAL = 61,
  KeyEvent_SpecialKey_DIVIDE = 62,
  KeyEvent_SpecialKey_EQUALS = 63,
  KeyEvent_SpecialKey_TEXT_INPUT = 64,
  KeyEvent_SpecialKey_HANKAKU = 65,
  KeyEvent_SpecialKey_KANJI = 66,
  KeyEvent_SpecialKey_KATAKANA = 67,
  KeyEvent_SpecialKey_CAPS_LOCK = 68,
  KeyEvent_SpecialKey_UNDEFINED_KEY = 69,
  KeyEvent_SpecialKey_COMMA = 70,
  KeyEvent_SpecialKey_CLEAR = 71,
  KeyEvent_SpecialKey_VIRTUAL_LEFT = 72,
  KeyEvent_SpecialKey_VIRTUAL_RIGHT = 73,
  KeyEvent_SpecialKey_VIRTUAL_ENTER = 74,
  KeyEvent_SpecialKey_NUM_SPECIALKEYS = 75
};
bool KeyEvent_SpecialKey_IsValid(int value);
const KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MIN = KeyEvent_SpecialKey_NO_SPECIALKEY;
const KeyEvent_SpecialKey KeyEvent_SpecialKey_SpecialKey_MAX = KeyEvent_SpecialKey_NUM_SPECIALKEYS;
const int KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE = KeyEvent_SpecialKey_SpecialKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_SpecialKey_descriptor();
inline const ::std::string& KeyEvent_SpecialKey_Name(KeyEvent_SpecialKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_SpecialKey_descriptor(), value);
}
inline bool KeyEvent_SpecialKey_Parse(
    const ::std::string& name, KeyEvent_SpecialKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_SpecialKey>(
    KeyEvent_SpecialKey_descriptor(), name, value);
}
enum KeyEvent_ModifierKey {
  KeyEvent_ModifierKey_CTRL = 1,
  KeyEvent_ModifierKey_ALT = 2,
  KeyEvent_ModifierKey_SHIFT = 4,
  KeyEvent_ModifierKey_KEY_DOWN = 8,
  KeyEvent_ModifierKey_KEY_UP = 16,
  KeyEvent_ModifierKey_LEFT_CTRL = 32,
  KeyEvent_ModifierKey_LEFT_ALT = 64,
  KeyEvent_ModifierKey_LEFT_SHIFT = 128,
  KeyEvent_ModifierKey_RIGHT_CTRL = 256,
  KeyEvent_ModifierKey_RIGHT_ALT = 512,
  KeyEvent_ModifierKey_RIGHT_SHIFT = 1024,
  KeyEvent_ModifierKey_CAPS = 2048
};
bool KeyEvent_ModifierKey_IsValid(int value);
const KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MIN = KeyEvent_ModifierKey_CTRL;
const KeyEvent_ModifierKey KeyEvent_ModifierKey_ModifierKey_MAX = KeyEvent_ModifierKey_CAPS;
const int KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE = KeyEvent_ModifierKey_ModifierKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_ModifierKey_descriptor();
inline const ::std::string& KeyEvent_ModifierKey_Name(KeyEvent_ModifierKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_ModifierKey_descriptor(), value);
}
inline bool KeyEvent_ModifierKey_Parse(
    const ::std::string& name, KeyEvent_ModifierKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_ModifierKey>(
    KeyEvent_ModifierKey_descriptor(), name, value);
}
enum KeyEvent_InputStyle {
  KeyEvent_InputStyle_FOLLOW_MODE = 0,
  KeyEvent_InputStyle_AS_IS = 1,
  KeyEvent_InputStyle_DIRECT_INPUT = 2
};
bool KeyEvent_InputStyle_IsValid(int value);
const KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MIN = KeyEvent_InputStyle_FOLLOW_MODE;
const KeyEvent_InputStyle KeyEvent_InputStyle_InputStyle_MAX = KeyEvent_InputStyle_DIRECT_INPUT;
const int KeyEvent_InputStyle_InputStyle_ARRAYSIZE = KeyEvent_InputStyle_InputStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyEvent_InputStyle_descriptor();
inline const ::std::string& KeyEvent_InputStyle_Name(KeyEvent_InputStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyEvent_InputStyle_descriptor(), value);
}
inline bool KeyEvent_InputStyle_Parse(
    const ::std::string& name, KeyEvent_InputStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyEvent_InputStyle>(
    KeyEvent_InputStyle_descriptor(), name, value);
}
enum GenericStorageEntry_StorageType {
  GenericStorageEntry_StorageType_SYMBOL_HISTORY = 0,
  GenericStorageEntry_StorageType_EMOTICON_HISTORY = 1,
  GenericStorageEntry_StorageType_EMOJI_HISTORY = 2
};
bool GenericStorageEntry_StorageType_IsValid(int value);
const GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MIN = GenericStorageEntry_StorageType_SYMBOL_HISTORY;
const GenericStorageEntry_StorageType GenericStorageEntry_StorageType_StorageType_MAX = GenericStorageEntry_StorageType_EMOJI_HISTORY;
const int GenericStorageEntry_StorageType_StorageType_ARRAYSIZE = GenericStorageEntry_StorageType_StorageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GenericStorageEntry_StorageType_descriptor();
inline const ::std::string& GenericStorageEntry_StorageType_Name(GenericStorageEntry_StorageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GenericStorageEntry_StorageType_descriptor(), value);
}
inline bool GenericStorageEntry_StorageType_Parse(
    const ::std::string& name, GenericStorageEntry_StorageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GenericStorageEntry_StorageType>(
    GenericStorageEntry_StorageType_descriptor(), name, value);
}
enum SessionCommand_CommandType {
  SessionCommand_CommandType_REVERT = 1,
  SessionCommand_CommandType_SUBMIT = 2,
  SessionCommand_CommandType_SELECT_CANDIDATE = 3,
  SessionCommand_CommandType_HIGHLIGHT_CANDIDATE = 4,
  SessionCommand_CommandType_SWITCH_INPUT_MODE = 5,
  SessionCommand_CommandType_GET_STATUS = 6,
  SessionCommand_CommandType_SUBMIT_CANDIDATE = 7,
  SessionCommand_CommandType_CONVERT_REVERSE = 8,
  SessionCommand_CommandType_UNDO = 9,
  SessionCommand_CommandType_RESET_CONTEXT = 10,
  SessionCommand_CommandType_MOVE_CURSOR = 11,
  SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE = 12,
  SessionCommand_CommandType_USAGE_STATS_EVENT = 13,
  SessionCommand_CommandType_UNDO_OR_REWIND = 14,
  SessionCommand_CommandType_EXPAND_SUGGESTION = 15,
  SessionCommand_CommandType_SEND_CARET_LOCATION = 16,
  SessionCommand_CommandType_OBSOLETE_SEND_LANGUAGE_BAR_COMMAND = 17,
  SessionCommand_CommandType_GET_ASYNC_RESULT = 18,
  SessionCommand_CommandType_COMMIT_RAW_TEXT = 19,
  SessionCommand_CommandType_CONVERT_PREV_PAGE = 20,
  SessionCommand_CommandType_CONVERT_NEXT_PAGE = 21,
  SessionCommand_CommandType_TURN_ON_IME = 22,
  SessionCommand_CommandType_TURN_OFF_IME = 23,
  SessionCommand_CommandType_NUM_OF_COMMANDS = 24
};
bool SessionCommand_CommandType_IsValid(int value);
const SessionCommand_CommandType SessionCommand_CommandType_CommandType_MIN = SessionCommand_CommandType_REVERT;
const SessionCommand_CommandType SessionCommand_CommandType_CommandType_MAX = SessionCommand_CommandType_NUM_OF_COMMANDS;
const int SessionCommand_CommandType_CommandType_ARRAYSIZE = SessionCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionCommand_CommandType_descriptor();
inline const ::std::string& SessionCommand_CommandType_Name(SessionCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionCommand_CommandType_descriptor(), value);
}
inline bool SessionCommand_CommandType_Parse(
    const ::std::string& name, SessionCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionCommand_CommandType>(
    SessionCommand_CommandType_descriptor(), name, value);
}
enum SessionCommand_UsageStatsEvent {
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW = 1,
  SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE = 2,
  SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT = 3,
  SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT = 4,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT = 5,
  SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT = 6,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE = 7,
  SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT = 8
};
bool SessionCommand_UsageStatsEvent_IsValid(int value);
const SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN = SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
const SessionCommand_UsageStatsEvent SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX = SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT;
const int SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE = SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionCommand_UsageStatsEvent_descriptor();
inline const ::std::string& SessionCommand_UsageStatsEvent_Name(SessionCommand_UsageStatsEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionCommand_UsageStatsEvent_descriptor(), value);
}
inline bool SessionCommand_UsageStatsEvent_Parse(
    const ::std::string& name, SessionCommand_UsageStatsEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionCommand_UsageStatsEvent>(
    SessionCommand_UsageStatsEvent_descriptor(), name, value);
}
enum Context_InputFieldType {
  Context_InputFieldType_NORMAL = 1,
  Context_InputFieldType_PASSWORD = 2,
  Context_InputFieldType_TEL = 3,
  Context_InputFieldType_NUMBER = 4
};
bool Context_InputFieldType_IsValid(int value);
const Context_InputFieldType Context_InputFieldType_InputFieldType_MIN = Context_InputFieldType_NORMAL;
const Context_InputFieldType Context_InputFieldType_InputFieldType_MAX = Context_InputFieldType_NUMBER;
const int Context_InputFieldType_InputFieldType_ARRAYSIZE = Context_InputFieldType_InputFieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Context_InputFieldType_descriptor();
inline const ::std::string& Context_InputFieldType_Name(Context_InputFieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Context_InputFieldType_descriptor(), value);
}
inline bool Context_InputFieldType_Parse(
    const ::std::string& name, Context_InputFieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Context_InputFieldType>(
    Context_InputFieldType_descriptor(), name, value);
}
enum Capability_TextDeletionCapabilityType {
  Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY = 0,
  Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT = 1
};
bool Capability_TextDeletionCapabilityType_IsValid(int value);
const Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN = Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
const Capability_TextDeletionCapabilityType Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX = Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
const int Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE = Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Capability_TextDeletionCapabilityType_descriptor();
inline const ::std::string& Capability_TextDeletionCapabilityType_Name(Capability_TextDeletionCapabilityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Capability_TextDeletionCapabilityType_descriptor(), value);
}
inline bool Capability_TextDeletionCapabilityType_Parse(
    const ::std::string& name, Capability_TextDeletionCapabilityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Capability_TextDeletionCapabilityType>(
    Capability_TextDeletionCapabilityType_descriptor(), name, value);
}
enum Request_SpecialRomanjiTable {
  Request_SpecialRomanjiTable_DEFAULT_TABLE = 0,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA = 10,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII = 11,
  Request_SpecialRomanjiTable_TWELVE_KEYS_TO_NUMBER = 12,
  Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA = 13,
  Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII = 14,
  Request_SpecialRomanjiTable_FLICK_TO_NUMBER = 15,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA = 16,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII = 17,
  Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_NUMBER = 18,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA = 20,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA_NUMBER = 21,
  Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII = 22,
  Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA = 30,
  Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII = 31,
  Request_SpecialRomanjiTable_GODAN_TO_NUMBER = 32
};
bool Request_SpecialRomanjiTable_IsValid(int value);
const Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN = Request_SpecialRomanjiTable_DEFAULT_TABLE;
const Request_SpecialRomanjiTable Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX = Request_SpecialRomanjiTable_GODAN_TO_NUMBER;
const int Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE = Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_SpecialRomanjiTable_descriptor();
inline const ::std::string& Request_SpecialRomanjiTable_Name(Request_SpecialRomanjiTable value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_SpecialRomanjiTable_descriptor(), value);
}
inline bool Request_SpecialRomanjiTable_Parse(
    const ::std::string& name, Request_SpecialRomanjiTable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_SpecialRomanjiTable>(
    Request_SpecialRomanjiTable_descriptor(), name, value);
}
enum Request_SpaceOnAlphanumeric {
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION = 0,
  Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION = 1,
  Request_SpaceOnAlphanumeric_COMMIT = 2
};
bool Request_SpaceOnAlphanumeric_IsValid(int value);
const Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN = Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
const Request_SpaceOnAlphanumeric Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX = Request_SpaceOnAlphanumeric_COMMIT;
const int Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE = Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_SpaceOnAlphanumeric_descriptor();
inline const ::std::string& Request_SpaceOnAlphanumeric_Name(Request_SpaceOnAlphanumeric value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_SpaceOnAlphanumeric_descriptor(), value);
}
inline bool Request_SpaceOnAlphanumeric_Parse(
    const ::std::string& name, Request_SpaceOnAlphanumeric* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_SpaceOnAlphanumeric>(
    Request_SpaceOnAlphanumeric_descriptor(), name, value);
}
enum Request_EmojiCarrierType {
  Request_EmojiCarrierType_UNICODE_EMOJI = 1,
  Request_EmojiCarrierType_DOCOMO_EMOJI = 2,
  Request_EmojiCarrierType_SOFTBANK_EMOJI = 4,
  Request_EmojiCarrierType_KDDI_EMOJI = 8
};
bool Request_EmojiCarrierType_IsValid(int value);
const Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MIN = Request_EmojiCarrierType_UNICODE_EMOJI;
const Request_EmojiCarrierType Request_EmojiCarrierType_EmojiCarrierType_MAX = Request_EmojiCarrierType_KDDI_EMOJI;
const int Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE = Request_EmojiCarrierType_EmojiCarrierType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_EmojiCarrierType_descriptor();
inline const ::std::string& Request_EmojiCarrierType_Name(Request_EmojiCarrierType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_EmojiCarrierType_descriptor(), value);
}
inline bool Request_EmojiCarrierType_Parse(
    const ::std::string& name, Request_EmojiCarrierType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_EmojiCarrierType>(
    Request_EmojiCarrierType_descriptor(), name, value);
}
enum Request_RewriterCapability {
  Request_RewriterCapability_NOT_AVAILABLE = 0,
  Request_RewriterCapability_CONVERSION = 1,
  Request_RewriterCapability_PREDICTION = 2,
  Request_RewriterCapability_SUGGESTION = 4,
  Request_RewriterCapability_ALL = 7
};
bool Request_RewriterCapability_IsValid(int value);
const Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MIN = Request_RewriterCapability_NOT_AVAILABLE;
const Request_RewriterCapability Request_RewriterCapability_RewriterCapability_MAX = Request_RewriterCapability_ALL;
const int Request_RewriterCapability_RewriterCapability_ARRAYSIZE = Request_RewriterCapability_RewriterCapability_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_RewriterCapability_descriptor();
inline const ::std::string& Request_RewriterCapability_Name(Request_RewriterCapability value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_RewriterCapability_descriptor(), value);
}
inline bool Request_RewriterCapability_Parse(
    const ::std::string& name, Request_RewriterCapability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_RewriterCapability>(
    Request_RewriterCapability_descriptor(), name, value);
}
enum Request_CrossingEdgeBehavior {
  Request_CrossingEdgeBehavior_DO_NOTHING = 0,
  Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING = 1
};
bool Request_CrossingEdgeBehavior_IsValid(int value);
const Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN = Request_CrossingEdgeBehavior_DO_NOTHING;
const Request_CrossingEdgeBehavior Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX = Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
const int Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE = Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_CrossingEdgeBehavior_descriptor();
inline const ::std::string& Request_CrossingEdgeBehavior_Name(Request_CrossingEdgeBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_CrossingEdgeBehavior_descriptor(), value);
}
inline bool Request_CrossingEdgeBehavior_Parse(
    const ::std::string& name, Request_CrossingEdgeBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_CrossingEdgeBehavior>(
    Request_CrossingEdgeBehavior_descriptor(), name, value);
}
enum Request_LanguageAwareInputBehavior {
  Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR = 0,
  Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT = 1,
  Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION = 2
};
bool Request_LanguageAwareInputBehavior_IsValid(int value);
const Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN = Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
const Request_LanguageAwareInputBehavior Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX = Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
const int Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE = Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* Request_LanguageAwareInputBehavior_descriptor();
inline const ::std::string& Request_LanguageAwareInputBehavior_Name(Request_LanguageAwareInputBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    Request_LanguageAwareInputBehavior_descriptor(), value);
}
inline bool Request_LanguageAwareInputBehavior_Parse(
    const ::std::string& name, Request_LanguageAwareInputBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Request_LanguageAwareInputBehavior>(
    Request_LanguageAwareInputBehavior_descriptor(), name, value);
}
enum Input_CommandType {
  Input_CommandType_NONE = 0,
  Input_CommandType_CREATE_SESSION = 1,
  Input_CommandType_DELETE_SESSION = 2,
  Input_CommandType_SEND_KEY = 3,
  Input_CommandType_TEST_SEND_KEY = 4,
  Input_CommandType_SEND_COMMAND = 5,
  Input_CommandType_GET_CONFIG = 6,
  Input_CommandType_SET_CONFIG = 7,
  Input_CommandType_SET_IMPOSED_CONFIG = 22,
  Input_CommandType_SET_REQUEST = 17,
  Input_CommandType_SYNC_DATA = 8,
  Input_CommandType_SHUTDOWN = 9,
  Input_CommandType_RELOAD = 10,
  Input_CommandType_CLEAR_USER_HISTORY = 11,
  Input_CommandType_CLEAR_USER_PREDICTION = 12,
  Input_CommandType_CLEAR_UNUSED_USER_PREDICTION = 16,
  Input_CommandType_CLEANUP = 13,
  Input_CommandType_NO_OPERATION = 14,
  Input_CommandType_OBSOLETE_START_CLOUD_SYNC = 18,
  Input_CommandType_OBSOLETE_GET_CLOUD_SYNC_STATUS = 23,
  Input_CommandType_OBSOLETE_ADD_AUTH_CODE = 24,
  Input_CommandType_INSERT_TO_STORAGE = 20,
  Input_CommandType_READ_ALL_FROM_STORAGE = 21,
  Input_CommandType_CLEAR_STORAGE = 25,
  Input_CommandType_SEND_USER_DICTIONARY_COMMAND = 26,
  Input_CommandType_NUM_OF_COMMANDS = 27
};
bool Input_CommandType_IsValid(int value);
const Input_CommandType Input_CommandType_CommandType_MIN = Input_CommandType_NONE;
const Input_CommandType Input_CommandType_CommandType_MAX = Input_CommandType_NUM_OF_COMMANDS;
const int Input_CommandType_CommandType_ARRAYSIZE = Input_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Input_CommandType_descriptor();
inline const ::std::string& Input_CommandType_Name(Input_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Input_CommandType_descriptor(), value);
}
inline bool Input_CommandType_Parse(
    const ::std::string& name, Input_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Input_CommandType>(
    Input_CommandType_descriptor(), name, value);
}
enum Input_TouchAction {
  Input_TouchAction_TOUCH_DOWN = 1,
  Input_TouchAction_TOUCH_MOVE = 2,
  Input_TouchAction_TOUCH_UP = 3
};
bool Input_TouchAction_IsValid(int value);
const Input_TouchAction Input_TouchAction_TouchAction_MIN = Input_TouchAction_TOUCH_DOWN;
const Input_TouchAction Input_TouchAction_TouchAction_MAX = Input_TouchAction_TOUCH_UP;
const int Input_TouchAction_TouchAction_ARRAYSIZE = Input_TouchAction_TouchAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Input_TouchAction_descriptor();
inline const ::std::string& Input_TouchAction_Name(Input_TouchAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Input_TouchAction_descriptor(), value);
}
inline bool Input_TouchAction_Parse(
    const ::std::string& name, Input_TouchAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Input_TouchAction>(
    Input_TouchAction_descriptor(), name, value);
}
enum Result_ResultType {
  Result_ResultType_NONE = 0,
  Result_ResultType_STRING = 1
};
bool Result_ResultType_IsValid(int value);
const Result_ResultType Result_ResultType_ResultType_MIN = Result_ResultType_NONE;
const Result_ResultType Result_ResultType_ResultType_MAX = Result_ResultType_STRING;
const int Result_ResultType_ResultType_ARRAYSIZE = Result_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_ResultType_descriptor();
inline const ::std::string& Result_ResultType_Name(Result_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_ResultType_descriptor(), value);
}
inline bool Result_ResultType_Parse(
    const ::std::string& name, Result_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result_ResultType>(
    Result_ResultType_descriptor(), name, value);
}
enum Preedit_Segment_Annotation {
  Preedit_Segment_Annotation_NONE = 0,
  Preedit_Segment_Annotation_UNDERLINE = 1,
  Preedit_Segment_Annotation_HIGHLIGHT = 2
};
bool Preedit_Segment_Annotation_IsValid(int value);
const Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MIN = Preedit_Segment_Annotation_NONE;
const Preedit_Segment_Annotation Preedit_Segment_Annotation_Annotation_MAX = Preedit_Segment_Annotation_HIGHLIGHT;
const int Preedit_Segment_Annotation_Annotation_ARRAYSIZE = Preedit_Segment_Annotation_Annotation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Preedit_Segment_Annotation_descriptor();
inline const ::std::string& Preedit_Segment_Annotation_Name(Preedit_Segment_Annotation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Preedit_Segment_Annotation_descriptor(), value);
}
inline bool Preedit_Segment_Annotation_Parse(
    const ::std::string& name, Preedit_Segment_Annotation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Preedit_Segment_Annotation>(
    Preedit_Segment_Annotation_descriptor(), name, value);
}
enum Output_PreeditMethod {
  Output_PreeditMethod_ASCII = 0,
  Output_PreeditMethod_KANA = 1
};
bool Output_PreeditMethod_IsValid(int value);
const Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MIN = Output_PreeditMethod_ASCII;
const Output_PreeditMethod Output_PreeditMethod_PreeditMethod_MAX = Output_PreeditMethod_KANA;
const int Output_PreeditMethod_PreeditMethod_ARRAYSIZE = Output_PreeditMethod_PreeditMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_PreeditMethod_descriptor();
inline const ::std::string& Output_PreeditMethod_Name(Output_PreeditMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_PreeditMethod_descriptor(), value);
}
inline bool Output_PreeditMethod_Parse(
    const ::std::string& name, Output_PreeditMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_PreeditMethod>(
    Output_PreeditMethod_descriptor(), name, value);
}
enum Output_ErrorCode {
  Output_ErrorCode_SESSION_SUCCESS = 0,
  Output_ErrorCode_SESSION_FAILURE = 1
};
bool Output_ErrorCode_IsValid(int value);
const Output_ErrorCode Output_ErrorCode_ErrorCode_MIN = Output_ErrorCode_SESSION_SUCCESS;
const Output_ErrorCode Output_ErrorCode_ErrorCode_MAX = Output_ErrorCode_SESSION_FAILURE;
const int Output_ErrorCode_ErrorCode_ARRAYSIZE = Output_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_ErrorCode_descriptor();
inline const ::std::string& Output_ErrorCode_Name(Output_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_ErrorCode_descriptor(), value);
}
inline bool Output_ErrorCode_Parse(
    const ::std::string& name, Output_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_ErrorCode>(
    Output_ErrorCode_descriptor(), name, value);
}
enum Output_ToolMode {
  Output_ToolMode_NO_TOOL = 0,
  Output_ToolMode_CONFIG_DIALOG = 1,
  Output_ToolMode_DICTIONARY_TOOL = 2,
  Output_ToolMode_WORD_REGISTER_DIALOG = 3
};
bool Output_ToolMode_IsValid(int value);
const Output_ToolMode Output_ToolMode_ToolMode_MIN = Output_ToolMode_NO_TOOL;
const Output_ToolMode Output_ToolMode_ToolMode_MAX = Output_ToolMode_WORD_REGISTER_DIALOG;
const int Output_ToolMode_ToolMode_ARRAYSIZE = Output_ToolMode_ToolMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Output_ToolMode_descriptor();
inline const ::std::string& Output_ToolMode_Name(Output_ToolMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Output_ToolMode_descriptor(), value);
}
inline bool Output_ToolMode_Parse(
    const ::std::string& name, Output_ToolMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Output_ToolMode>(
    Output_ToolMode_descriptor(), name, value);
}
enum CompositionMode {
  DIRECT = 0,
  HIRAGANA = 1,
  FULL_KATAKANA = 2,
  HALF_ASCII = 3,
  FULL_ASCII = 4,
  HALF_KATAKANA = 5,
  NUM_OF_COMPOSITIONS = 6
};
bool CompositionMode_IsValid(int value);
const CompositionMode CompositionMode_MIN = DIRECT;
const CompositionMode CompositionMode_MAX = NUM_OF_COMPOSITIONS;
const int CompositionMode_ARRAYSIZE = CompositionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompositionMode_descriptor();
inline const ::std::string& CompositionMode_Name(CompositionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompositionMode_descriptor(), value);
}
inline bool CompositionMode_Parse(
    const ::std::string& name, CompositionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompositionMode>(
    CompositionMode_descriptor(), name, value);
}
// ===================================================================

class KeyEvent_ProbableKeyEvent : public ::google::protobuf::Message {
 public:
  KeyEvent_ProbableKeyEvent();
  virtual ~KeyEvent_ProbableKeyEvent();

  KeyEvent_ProbableKeyEvent(const KeyEvent_ProbableKeyEvent& from);

  inline KeyEvent_ProbableKeyEvent& operator=(const KeyEvent_ProbableKeyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyEvent_ProbableKeyEvent& default_instance();

  void Swap(KeyEvent_ProbableKeyEvent* other);

  // implements Message ----------------------------------------------

  KeyEvent_ProbableKeyEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyEvent_ProbableKeyEvent& from);
  void MergeFrom(const KeyEvent_ProbableKeyEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 key_code = 1;
  inline bool has_key_code() const;
  inline void clear_key_code();
  static const int kKeyCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 key_code() const;
  inline void set_key_code(::google::protobuf::uint32 value);

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  inline bool has_special_key() const;
  inline void clear_special_key();
  static const int kSpecialKeyFieldNumber = 3;
  inline ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  inline void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);

  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  inline int modifier_keys_size() const;
  inline void clear_modifier_keys();
  static const int kModifierKeysFieldNumber = 4;
  inline ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  inline void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  inline void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  inline const ::google::protobuf::RepeatedField<int>& modifier_keys() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_modifier_keys();

  // optional double probability = 10;
  inline bool has_probability() const;
  inline void clear_probability();
  static const int kProbabilityFieldNumber = 10;
  inline double probability() const;
  inline void set_probability(double value);

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent.ProbableKeyEvent)
 private:
  inline void set_has_key_code();
  inline void clear_has_key_code();
  inline void set_has_special_key();
  inline void clear_has_special_key();
  inline void set_has_probability();
  inline void clear_has_probability();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 key_code_;
  int special_key_;
  ::google::protobuf::RepeatedField<int> modifier_keys_;
  double probability_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static KeyEvent_ProbableKeyEvent* default_instance_;
};
// -------------------------------------------------------------------

class KeyEvent : public ::google::protobuf::Message {
 public:
  KeyEvent();
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyEvent& default_instance();

  void Swap(KeyEvent* other);

  // implements Message ----------------------------------------------

  KeyEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef KeyEvent_ProbableKeyEvent ProbableKeyEvent;

  typedef KeyEvent_SpecialKey SpecialKey;
  static const SpecialKey NO_SPECIALKEY = KeyEvent_SpecialKey_NO_SPECIALKEY;
  static const SpecialKey DIGIT = KeyEvent_SpecialKey_DIGIT;
  static const SpecialKey ON = KeyEvent_SpecialKey_ON;
  static const SpecialKey OFF = KeyEvent_SpecialKey_OFF;
  static const SpecialKey SPACE = KeyEvent_SpecialKey_SPACE;
  static const SpecialKey ENTER = KeyEvent_SpecialKey_ENTER;
  static const SpecialKey LEFT = KeyEvent_SpecialKey_LEFT;
  static const SpecialKey RIGHT = KeyEvent_SpecialKey_RIGHT;
  static const SpecialKey UP = KeyEvent_SpecialKey_UP;
  static const SpecialKey DOWN = KeyEvent_SpecialKey_DOWN;
  static const SpecialKey ESCAPE = KeyEvent_SpecialKey_ESCAPE;
  static const SpecialKey DEL = KeyEvent_SpecialKey_DEL;
  static const SpecialKey BACKSPACE = KeyEvent_SpecialKey_BACKSPACE;
  static const SpecialKey HENKAN = KeyEvent_SpecialKey_HENKAN;
  static const SpecialKey MUHENKAN = KeyEvent_SpecialKey_MUHENKAN;
  static const SpecialKey KANA = KeyEvent_SpecialKey_KANA;
  static const SpecialKey HOME = KeyEvent_SpecialKey_HOME;
  static const SpecialKey END = KeyEvent_SpecialKey_END;
  static const SpecialKey TAB = KeyEvent_SpecialKey_TAB;
  static const SpecialKey F1 = KeyEvent_SpecialKey_F1;
  static const SpecialKey F2 = KeyEvent_SpecialKey_F2;
  static const SpecialKey F3 = KeyEvent_SpecialKey_F3;
  static const SpecialKey F4 = KeyEvent_SpecialKey_F4;
  static const SpecialKey F5 = KeyEvent_SpecialKey_F5;
  static const SpecialKey F6 = KeyEvent_SpecialKey_F6;
  static const SpecialKey F7 = KeyEvent_SpecialKey_F7;
  static const SpecialKey F8 = KeyEvent_SpecialKey_F8;
  static const SpecialKey F9 = KeyEvent_SpecialKey_F9;
  static const SpecialKey F10 = KeyEvent_SpecialKey_F10;
  static const SpecialKey F11 = KeyEvent_SpecialKey_F11;
  static const SpecialKey F12 = KeyEvent_SpecialKey_F12;
  static const SpecialKey PAGE_UP = KeyEvent_SpecialKey_PAGE_UP;
  static const SpecialKey PAGE_DOWN = KeyEvent_SpecialKey_PAGE_DOWN;
  static const SpecialKey INSERT = KeyEvent_SpecialKey_INSERT;
  static const SpecialKey F13 = KeyEvent_SpecialKey_F13;
  static const SpecialKey F14 = KeyEvent_SpecialKey_F14;
  static const SpecialKey F15 = KeyEvent_SpecialKey_F15;
  static const SpecialKey F16 = KeyEvent_SpecialKey_F16;
  static const SpecialKey F17 = KeyEvent_SpecialKey_F17;
  static const SpecialKey F18 = KeyEvent_SpecialKey_F18;
  static const SpecialKey F19 = KeyEvent_SpecialKey_F19;
  static const SpecialKey F20 = KeyEvent_SpecialKey_F20;
  static const SpecialKey F21 = KeyEvent_SpecialKey_F21;
  static const SpecialKey F22 = KeyEvent_SpecialKey_F22;
  static const SpecialKey F23 = KeyEvent_SpecialKey_F23;
  static const SpecialKey F24 = KeyEvent_SpecialKey_F24;
  static const SpecialKey EISU = KeyEvent_SpecialKey_EISU;
  static const SpecialKey NUMPAD0 = KeyEvent_SpecialKey_NUMPAD0;
  static const SpecialKey NUMPAD1 = KeyEvent_SpecialKey_NUMPAD1;
  static const SpecialKey NUMPAD2 = KeyEvent_SpecialKey_NUMPAD2;
  static const SpecialKey NUMPAD3 = KeyEvent_SpecialKey_NUMPAD3;
  static const SpecialKey NUMPAD4 = KeyEvent_SpecialKey_NUMPAD4;
  static const SpecialKey NUMPAD5 = KeyEvent_SpecialKey_NUMPAD5;
  static const SpecialKey NUMPAD6 = KeyEvent_SpecialKey_NUMPAD6;
  static const SpecialKey NUMPAD7 = KeyEvent_SpecialKey_NUMPAD7;
  static const SpecialKey NUMPAD8 = KeyEvent_SpecialKey_NUMPAD8;
  static const SpecialKey NUMPAD9 = KeyEvent_SpecialKey_NUMPAD9;
  static const SpecialKey MULTIPLY = KeyEvent_SpecialKey_MULTIPLY;
  static const SpecialKey ADD = KeyEvent_SpecialKey_ADD;
  static const SpecialKey SEPARATOR = KeyEvent_SpecialKey_SEPARATOR;
  static const SpecialKey SUBTRACT = KeyEvent_SpecialKey_SUBTRACT;
  static const SpecialKey DECIMAL = KeyEvent_SpecialKey_DECIMAL;
  static const SpecialKey DIVIDE = KeyEvent_SpecialKey_DIVIDE;
  static const SpecialKey EQUALS = KeyEvent_SpecialKey_EQUALS;
  static const SpecialKey TEXT_INPUT = KeyEvent_SpecialKey_TEXT_INPUT;
  static const SpecialKey HANKAKU = KeyEvent_SpecialKey_HANKAKU;
  static const SpecialKey KANJI = KeyEvent_SpecialKey_KANJI;
  static const SpecialKey KATAKANA = KeyEvent_SpecialKey_KATAKANA;
  static const SpecialKey CAPS_LOCK = KeyEvent_SpecialKey_CAPS_LOCK;
  static const SpecialKey UNDEFINED_KEY = KeyEvent_SpecialKey_UNDEFINED_KEY;
  static const SpecialKey COMMA = KeyEvent_SpecialKey_COMMA;
  static const SpecialKey CLEAR = KeyEvent_SpecialKey_CLEAR;
  static const SpecialKey VIRTUAL_LEFT = KeyEvent_SpecialKey_VIRTUAL_LEFT;
  static const SpecialKey VIRTUAL_RIGHT = KeyEvent_SpecialKey_VIRTUAL_RIGHT;
  static const SpecialKey VIRTUAL_ENTER = KeyEvent_SpecialKey_VIRTUAL_ENTER;
  static const SpecialKey NUM_SPECIALKEYS = KeyEvent_SpecialKey_NUM_SPECIALKEYS;
  static inline bool SpecialKey_IsValid(int value) {
    return KeyEvent_SpecialKey_IsValid(value);
  }
  static const SpecialKey SpecialKey_MIN =
    KeyEvent_SpecialKey_SpecialKey_MIN;
  static const SpecialKey SpecialKey_MAX =
    KeyEvent_SpecialKey_SpecialKey_MAX;
  static const int SpecialKey_ARRAYSIZE =
    KeyEvent_SpecialKey_SpecialKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpecialKey_descriptor() {
    return KeyEvent_SpecialKey_descriptor();
  }
  static inline const ::std::string& SpecialKey_Name(SpecialKey value) {
    return KeyEvent_SpecialKey_Name(value);
  }
  static inline bool SpecialKey_Parse(const ::std::string& name,
      SpecialKey* value) {
    return KeyEvent_SpecialKey_Parse(name, value);
  }

  typedef KeyEvent_ModifierKey ModifierKey;
  static const ModifierKey CTRL = KeyEvent_ModifierKey_CTRL;
  static const ModifierKey ALT = KeyEvent_ModifierKey_ALT;
  static const ModifierKey SHIFT = KeyEvent_ModifierKey_SHIFT;
  static const ModifierKey KEY_DOWN = KeyEvent_ModifierKey_KEY_DOWN;
  static const ModifierKey KEY_UP = KeyEvent_ModifierKey_KEY_UP;
  static const ModifierKey LEFT_CTRL = KeyEvent_ModifierKey_LEFT_CTRL;
  static const ModifierKey LEFT_ALT = KeyEvent_ModifierKey_LEFT_ALT;
  static const ModifierKey LEFT_SHIFT = KeyEvent_ModifierKey_LEFT_SHIFT;
  static const ModifierKey RIGHT_CTRL = KeyEvent_ModifierKey_RIGHT_CTRL;
  static const ModifierKey RIGHT_ALT = KeyEvent_ModifierKey_RIGHT_ALT;
  static const ModifierKey RIGHT_SHIFT = KeyEvent_ModifierKey_RIGHT_SHIFT;
  static const ModifierKey CAPS = KeyEvent_ModifierKey_CAPS;
  static inline bool ModifierKey_IsValid(int value) {
    return KeyEvent_ModifierKey_IsValid(value);
  }
  static const ModifierKey ModifierKey_MIN =
    KeyEvent_ModifierKey_ModifierKey_MIN;
  static const ModifierKey ModifierKey_MAX =
    KeyEvent_ModifierKey_ModifierKey_MAX;
  static const int ModifierKey_ARRAYSIZE =
    KeyEvent_ModifierKey_ModifierKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModifierKey_descriptor() {
    return KeyEvent_ModifierKey_descriptor();
  }
  static inline const ::std::string& ModifierKey_Name(ModifierKey value) {
    return KeyEvent_ModifierKey_Name(value);
  }
  static inline bool ModifierKey_Parse(const ::std::string& name,
      ModifierKey* value) {
    return KeyEvent_ModifierKey_Parse(name, value);
  }

  typedef KeyEvent_InputStyle InputStyle;
  static const InputStyle FOLLOW_MODE = KeyEvent_InputStyle_FOLLOW_MODE;
  static const InputStyle AS_IS = KeyEvent_InputStyle_AS_IS;
  static const InputStyle DIRECT_INPUT = KeyEvent_InputStyle_DIRECT_INPUT;
  static inline bool InputStyle_IsValid(int value) {
    return KeyEvent_InputStyle_IsValid(value);
  }
  static const InputStyle InputStyle_MIN =
    KeyEvent_InputStyle_InputStyle_MIN;
  static const InputStyle InputStyle_MAX =
    KeyEvent_InputStyle_InputStyle_MAX;
  static const int InputStyle_ARRAYSIZE =
    KeyEvent_InputStyle_InputStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InputStyle_descriptor() {
    return KeyEvent_InputStyle_descriptor();
  }
  static inline const ::std::string& InputStyle_Name(InputStyle value) {
    return KeyEvent_InputStyle_Name(value);
  }
  static inline bool InputStyle_Parse(const ::std::string& name,
      InputStyle* value) {
    return KeyEvent_InputStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 key_code = 1;
  inline bool has_key_code() const;
  inline void clear_key_code();
  static const int kKeyCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 key_code() const;
  inline void set_key_code(::google::protobuf::uint32 value);

  // optional uint32 modifiers = 2;
  inline bool has_modifiers() const;
  inline void clear_modifiers();
  static const int kModifiersFieldNumber = 2;
  inline ::google::protobuf::uint32 modifiers() const;
  inline void set_modifiers(::google::protobuf::uint32 value);

  // optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
  inline bool has_special_key() const;
  inline void clear_special_key();
  static const int kSpecialKeyFieldNumber = 3;
  inline ::mozc::commands::KeyEvent_SpecialKey special_key() const;
  inline void set_special_key(::mozc::commands::KeyEvent_SpecialKey value);

  // repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
  inline int modifier_keys_size() const;
  inline void clear_modifier_keys();
  static const int kModifierKeysFieldNumber = 4;
  inline ::mozc::commands::KeyEvent_ModifierKey modifier_keys(int index) const;
  inline void set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value);
  inline void add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value);
  inline const ::google::protobuf::RepeatedField<int>& modifier_keys() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_modifier_keys();

  // optional string key_string = 5;
  inline bool has_key_string() const;
  inline void clear_key_string();
  static const int kKeyStringFieldNumber = 5;
  inline const ::std::string& key_string() const;
  inline void set_key_string(const ::std::string& value);
  inline void set_key_string(const char* value);
  inline void set_key_string(const char* value, size_t size);
  inline ::std::string* mutable_key_string();
  inline ::std::string* release_key_string();
  inline void set_allocated_key_string(::std::string* key_string);

  // optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
  inline bool has_input_style() const;
  inline void clear_input_style();
  static const int kInputStyleFieldNumber = 6;
  inline ::mozc::commands::KeyEvent_InputStyle input_style() const;
  inline void set_input_style(::mozc::commands::KeyEvent_InputStyle value);

  // optional .mozc.commands.CompositionMode mode = 7;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 7;
  inline ::mozc::commands::CompositionMode mode() const;
  inline void set_mode(::mozc::commands::CompositionMode value);

  // repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
  inline int probable_key_event_size() const;
  inline void clear_probable_key_event();
  static const int kProbableKeyEventFieldNumber = 8;
  inline const ::mozc::commands::KeyEvent_ProbableKeyEvent& probable_key_event(int index) const;
  inline ::mozc::commands::KeyEvent_ProbableKeyEvent* mutable_probable_key_event(int index);
  inline ::mozc::commands::KeyEvent_ProbableKeyEvent* add_probable_key_event();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
      probable_key_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
      mutable_probable_key_event();

  // optional bool activated = 9;
  inline bool has_activated() const;
  inline void clear_activated();
  static const int kActivatedFieldNumber = 9;
  inline bool activated() const;
  inline void set_activated(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.KeyEvent)
 private:
  inline void set_has_key_code();
  inline void clear_has_key_code();
  inline void set_has_modifiers();
  inline void clear_has_modifiers();
  inline void set_has_special_key();
  inline void clear_has_special_key();
  inline void set_has_key_string();
  inline void clear_has_key_string();
  inline void set_has_input_style();
  inline void clear_has_input_style();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_activated();
  inline void clear_has_activated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 key_code_;
  ::google::protobuf::uint32 modifiers_;
  ::google::protobuf::RepeatedField<int> modifier_keys_;
  int special_key_;
  int input_style_;
  ::std::string* key_string_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent > probable_key_event_;
  int mode_;
  bool activated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static KeyEvent* default_instance_;
};
// -------------------------------------------------------------------

class GenericStorageEntry : public ::google::protobuf::Message {
 public:
  GenericStorageEntry();
  virtual ~GenericStorageEntry();

  GenericStorageEntry(const GenericStorageEntry& from);

  inline GenericStorageEntry& operator=(const GenericStorageEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericStorageEntry& default_instance();

  void Swap(GenericStorageEntry* other);

  // implements Message ----------------------------------------------

  GenericStorageEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericStorageEntry& from);
  void MergeFrom(const GenericStorageEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GenericStorageEntry_StorageType StorageType;
  static const StorageType SYMBOL_HISTORY = GenericStorageEntry_StorageType_SYMBOL_HISTORY;
  static const StorageType EMOTICON_HISTORY = GenericStorageEntry_StorageType_EMOTICON_HISTORY;
  static const StorageType EMOJI_HISTORY = GenericStorageEntry_StorageType_EMOJI_HISTORY;
  static inline bool StorageType_IsValid(int value) {
    return GenericStorageEntry_StorageType_IsValid(value);
  }
  static const StorageType StorageType_MIN =
    GenericStorageEntry_StorageType_StorageType_MIN;
  static const StorageType StorageType_MAX =
    GenericStorageEntry_StorageType_StorageType_MAX;
  static const int StorageType_ARRAYSIZE =
    GenericStorageEntry_StorageType_StorageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StorageType_descriptor() {
    return GenericStorageEntry_StorageType_descriptor();
  }
  static inline const ::std::string& StorageType_Name(StorageType value) {
    return GenericStorageEntry_StorageType_Name(value);
  }
  static inline bool StorageType_Parse(const ::std::string& name,
      StorageType* value) {
    return GenericStorageEntry_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mozc::commands::GenericStorageEntry_StorageType type() const;
  inline void set_type(::mozc::commands::GenericStorageEntry_StorageType value);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // repeated bytes value = 3;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const void* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:mozc.commands.GenericStorageEntry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static GenericStorageEntry* default_instance_;
};
// -------------------------------------------------------------------

class SessionCommand : public ::google::protobuf::Message {
 public:
  SessionCommand();
  virtual ~SessionCommand();

  SessionCommand(const SessionCommand& from);

  inline SessionCommand& operator=(const SessionCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionCommand& default_instance();

  void Swap(SessionCommand* other);

  // implements Message ----------------------------------------------

  SessionCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionCommand& from);
  void MergeFrom(const SessionCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SessionCommand_CommandType CommandType;
  static const CommandType REVERT = SessionCommand_CommandType_REVERT;
  static const CommandType SUBMIT = SessionCommand_CommandType_SUBMIT;
  static const CommandType SELECT_CANDIDATE = SessionCommand_CommandType_SELECT_CANDIDATE;
  static const CommandType HIGHLIGHT_CANDIDATE = SessionCommand_CommandType_HIGHLIGHT_CANDIDATE;
  static const CommandType SWITCH_INPUT_MODE = SessionCommand_CommandType_SWITCH_INPUT_MODE;
  static const CommandType GET_STATUS = SessionCommand_CommandType_GET_STATUS;
  static const CommandType SUBMIT_CANDIDATE = SessionCommand_CommandType_SUBMIT_CANDIDATE;
  static const CommandType CONVERT_REVERSE = SessionCommand_CommandType_CONVERT_REVERSE;
  static const CommandType UNDO = SessionCommand_CommandType_UNDO;
  static const CommandType RESET_CONTEXT = SessionCommand_CommandType_RESET_CONTEXT;
  static const CommandType MOVE_CURSOR = SessionCommand_CommandType_MOVE_CURSOR;
  static const CommandType SWITCH_INPUT_FIELD_TYPE = SessionCommand_CommandType_SWITCH_INPUT_FIELD_TYPE;
  static const CommandType USAGE_STATS_EVENT = SessionCommand_CommandType_USAGE_STATS_EVENT;
  static const CommandType UNDO_OR_REWIND = SessionCommand_CommandType_UNDO_OR_REWIND;
  static const CommandType EXPAND_SUGGESTION = SessionCommand_CommandType_EXPAND_SUGGESTION;
  static const CommandType SEND_CARET_LOCATION = SessionCommand_CommandType_SEND_CARET_LOCATION;
  static const CommandType OBSOLETE_SEND_LANGUAGE_BAR_COMMAND = SessionCommand_CommandType_OBSOLETE_SEND_LANGUAGE_BAR_COMMAND;
  static const CommandType GET_ASYNC_RESULT = SessionCommand_CommandType_GET_ASYNC_RESULT;
  static const CommandType COMMIT_RAW_TEXT = SessionCommand_CommandType_COMMIT_RAW_TEXT;
  static const CommandType CONVERT_PREV_PAGE = SessionCommand_CommandType_CONVERT_PREV_PAGE;
  static const CommandType CONVERT_NEXT_PAGE = SessionCommand_CommandType_CONVERT_NEXT_PAGE;
  static const CommandType TURN_ON_IME = SessionCommand_CommandType_TURN_ON_IME;
  static const CommandType TURN_OFF_IME = SessionCommand_CommandType_TURN_OFF_IME;
  static const CommandType NUM_OF_COMMANDS = SessionCommand_CommandType_NUM_OF_COMMANDS;
  static inline bool CommandType_IsValid(int value) {
    return SessionCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    SessionCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    SessionCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    SessionCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return SessionCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return SessionCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return SessionCommand_CommandType_Parse(name, value);
  }

  typedef SessionCommand_UsageStatsEvent UsageStatsEvent;
  static const UsageStatsEvent INFOLIST_WINDOW_SHOW = SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_SHOW;
  static const UsageStatsEvent INFOLIST_WINDOW_HIDE = SessionCommand_UsageStatsEvent_INFOLIST_WINDOW_HIDE;
  static const UsageStatsEvent HANDWRITING_OPEN_EVENT = SessionCommand_UsageStatsEvent_HANDWRITING_OPEN_EVENT;
  static const UsageStatsEvent HANDWRITING_COMMIT_EVENT = SessionCommand_UsageStatsEvent_HANDWRITING_COMMIT_EVENT;
  static const UsageStatsEvent CHARACTER_PALETTE_OPEN_EVENT = SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_OPEN_EVENT;
  static const UsageStatsEvent CHARACTER_PALETTE_COMMIT_EVENT = SessionCommand_UsageStatsEvent_CHARACTER_PALETTE_COMMIT_EVENT;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE = SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_LANDSCAPE;
  static const UsageStatsEvent SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT = SessionCommand_UsageStatsEvent_SOFTWARE_KEYBOARD_LAYOUT_PORTRAIT;
  static inline bool UsageStatsEvent_IsValid(int value) {
    return SessionCommand_UsageStatsEvent_IsValid(value);
  }
  static const UsageStatsEvent UsageStatsEvent_MIN =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MIN;
  static const UsageStatsEvent UsageStatsEvent_MAX =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_MAX;
  static const int UsageStatsEvent_ARRAYSIZE =
    SessionCommand_UsageStatsEvent_UsageStatsEvent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UsageStatsEvent_descriptor() {
    return SessionCommand_UsageStatsEvent_descriptor();
  }
  static inline const ::std::string& UsageStatsEvent_Name(UsageStatsEvent value) {
    return SessionCommand_UsageStatsEvent_Name(value);
  }
  static inline bool UsageStatsEvent_Parse(const ::std::string& name,
      UsageStatsEvent* value) {
    return SessionCommand_UsageStatsEvent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mozc.commands.SessionCommand.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mozc::commands::SessionCommand_CommandType type() const;
  inline void set_type(::mozc::commands::SessionCommand_CommandType value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .mozc.commands.CompositionMode composition_mode = 3;
  inline bool has_composition_mode() const;
  inline void clear_composition_mode();
  static const int kCompositionModeFieldNumber = 3;
  inline ::mozc::commands::CompositionMode composition_mode() const;
  inline void set_composition_mode(::mozc::commands::CompositionMode value);

  // optional string text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional uint32 cursor_position = 5;
  inline bool has_cursor_position() const;
  inline void clear_cursor_position();
  static const int kCursorPositionFieldNumber = 5;
  inline ::google::protobuf::uint32 cursor_position() const;
  inline void set_cursor_position(::google::protobuf::uint32 value);

  // optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
  inline bool has_usage_stats_event() const;
  inline void clear_usage_stats_event();
  static const int kUsageStatsEventFieldNumber = 7;
  inline ::mozc::commands::SessionCommand_UsageStatsEvent usage_stats_event() const;
  inline void set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value);

  // optional int32 usage_stats_event_int_value = 9;
  inline bool has_usage_stats_event_int_value() const;
  inline void clear_usage_stats_event_int_value();
  static const int kUsageStatsEventIntValueFieldNumber = 9;
  inline ::google::protobuf::int32 usage_stats_event_int_value() const;
  inline void set_usage_stats_event_int_value(::google::protobuf::int32 value);

  // optional .mozc.commands.Rectangle caret_rectangle = 8;
  inline bool has_caret_rectangle() const;
  inline void clear_caret_rectangle();
  static const int kCaretRectangleFieldNumber = 8;
  inline const ::mozc::commands::Rectangle& caret_rectangle() const;
  inline ::mozc::commands::Rectangle* mutable_caret_rectangle();
  inline ::mozc::commands::Rectangle* release_caret_rectangle();
  inline void set_allocated_caret_rectangle(::mozc::commands::Rectangle* caret_rectangle);

  // optional int32 asynchronous_request_id = 10;
  inline bool has_asynchronous_request_id() const;
  inline void clear_asynchronous_request_id();
  static const int kAsynchronousRequestIdFieldNumber = 10;
  inline ::google::protobuf::int32 asynchronous_request_id() const;
  inline void set_asynchronous_request_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.SessionCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_composition_mode();
  inline void clear_has_composition_mode();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_cursor_position();
  inline void clear_has_cursor_position();
  inline void set_has_usage_stats_event();
  inline void clear_has_usage_stats_event();
  inline void set_has_usage_stats_event_int_value();
  inline void clear_has_usage_stats_event_int_value();
  inline void set_has_caret_rectangle();
  inline void clear_has_caret_rectangle();
  inline void set_has_asynchronous_request_id();
  inline void clear_has_asynchronous_request_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::std::string* text_;
  int composition_mode_;
  ::google::protobuf::uint32 cursor_position_;
  int usage_stats_event_;
  ::google::protobuf::int32 usage_stats_event_int_value_;
  ::mozc::commands::Rectangle* caret_rectangle_;
  ::google::protobuf::int32 asynchronous_request_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static SessionCommand* default_instance_;
};
// -------------------------------------------------------------------

class Context : public ::google::protobuf::Message {
 public:
  Context();
  virtual ~Context();

  Context(const Context& from);

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Context& default_instance();

  void Swap(Context* other);

  // implements Message ----------------------------------------------

  Context* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Context_InputFieldType InputFieldType;
  static const InputFieldType NORMAL = Context_InputFieldType_NORMAL;
  static const InputFieldType PASSWORD = Context_InputFieldType_PASSWORD;
  static const InputFieldType TEL = Context_InputFieldType_TEL;
  static const InputFieldType NUMBER = Context_InputFieldType_NUMBER;
  static inline bool InputFieldType_IsValid(int value) {
    return Context_InputFieldType_IsValid(value);
  }
  static const InputFieldType InputFieldType_MIN =
    Context_InputFieldType_InputFieldType_MIN;
  static const InputFieldType InputFieldType_MAX =
    Context_InputFieldType_InputFieldType_MAX;
  static const int InputFieldType_ARRAYSIZE =
    Context_InputFieldType_InputFieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InputFieldType_descriptor() {
    return Context_InputFieldType_descriptor();
  }
  static inline const ::std::string& InputFieldType_Name(InputFieldType value) {
    return Context_InputFieldType_Name(value);
  }
  static inline bool InputFieldType_Parse(const ::std::string& name,
      InputFieldType* value) {
    return Context_InputFieldType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string preceding_text = 1;
  inline bool has_preceding_text() const;
  inline void clear_preceding_text();
  static const int kPrecedingTextFieldNumber = 1;
  inline const ::std::string& preceding_text() const;
  inline void set_preceding_text(const ::std::string& value);
  inline void set_preceding_text(const char* value);
  inline void set_preceding_text(const char* value, size_t size);
  inline ::std::string* mutable_preceding_text();
  inline ::std::string* release_preceding_text();
  inline void set_allocated_preceding_text(::std::string* preceding_text);

  // optional string following_text = 2;
  inline bool has_following_text() const;
  inline void clear_following_text();
  static const int kFollowingTextFieldNumber = 2;
  inline const ::std::string& following_text() const;
  inline void set_following_text(const ::std::string& value);
  inline void set_following_text(const char* value);
  inline void set_following_text(const char* value, size_t size);
  inline ::std::string* mutable_following_text();
  inline ::std::string* release_following_text();
  inline void set_allocated_following_text(::std::string* following_text);

  // optional bool suppress_suggestion = 3 [default = false];
  inline bool has_suppress_suggestion() const;
  inline void clear_suppress_suggestion();
  static const int kSuppressSuggestionFieldNumber = 3;
  inline bool suppress_suggestion() const;
  inline void set_suppress_suggestion(bool value);

  // optional .mozc.commands.Context.InputFieldType input_field_type = 4;
  inline bool has_input_field_type() const;
  inline void clear_input_field_type();
  static const int kInputFieldTypeFieldNumber = 4;
  inline ::mozc::commands::Context_InputFieldType input_field_type() const;
  inline void set_input_field_type(::mozc::commands::Context_InputFieldType value);

  // optional int32 revision = 5 [default = 0];
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 5;
  inline ::google::protobuf::int32 revision() const;
  inline void set_revision(::google::protobuf::int32 value);

  // repeated string experimental_features = 100;
  inline int experimental_features_size() const;
  inline void clear_experimental_features();
  static const int kExperimentalFeaturesFieldNumber = 100;
  inline const ::std::string& experimental_features(int index) const;
  inline ::std::string* mutable_experimental_features(int index);
  inline void set_experimental_features(int index, const ::std::string& value);
  inline void set_experimental_features(int index, const char* value);
  inline void set_experimental_features(int index, const char* value, size_t size);
  inline ::std::string* add_experimental_features();
  inline void add_experimental_features(const ::std::string& value);
  inline void add_experimental_features(const char* value);
  inline void add_experimental_features(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& experimental_features() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_experimental_features();

  // @@protoc_insertion_point(class_scope:mozc.commands.Context)
 private:
  inline void set_has_preceding_text();
  inline void clear_has_preceding_text();
  inline void set_has_following_text();
  inline void clear_has_following_text();
  inline void set_has_suppress_suggestion();
  inline void clear_has_suppress_suggestion();
  inline void set_has_input_field_type();
  inline void clear_has_input_field_type();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* preceding_text_;
  ::std::string* following_text_;
  bool suppress_suggestion_;
  int input_field_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> experimental_features_;
  ::google::protobuf::int32 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Context* default_instance_;
};
// -------------------------------------------------------------------

class Capability : public ::google::protobuf::Message {
 public:
  Capability();
  virtual ~Capability();

  Capability(const Capability& from);

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Capability& default_instance();

  void Swap(Capability* other);

  // implements Message ----------------------------------------------

  Capability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Capability_TextDeletionCapabilityType TextDeletionCapabilityType;
  static const TextDeletionCapabilityType NO_TEXT_DELETION_CAPABILITY = Capability_TextDeletionCapabilityType_NO_TEXT_DELETION_CAPABILITY;
  static const TextDeletionCapabilityType DELETE_PRECEDING_TEXT = Capability_TextDeletionCapabilityType_DELETE_PRECEDING_TEXT;
  static inline bool TextDeletionCapabilityType_IsValid(int value) {
    return Capability_TextDeletionCapabilityType_IsValid(value);
  }
  static const TextDeletionCapabilityType TextDeletionCapabilityType_MIN =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MIN;
  static const TextDeletionCapabilityType TextDeletionCapabilityType_MAX =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_MAX;
  static const int TextDeletionCapabilityType_ARRAYSIZE =
    Capability_TextDeletionCapabilityType_TextDeletionCapabilityType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TextDeletionCapabilityType_descriptor() {
    return Capability_TextDeletionCapabilityType_descriptor();
  }
  static inline const ::std::string& TextDeletionCapabilityType_Name(TextDeletionCapabilityType value) {
    return Capability_TextDeletionCapabilityType_Name(value);
  }
  static inline bool TextDeletionCapabilityType_Parse(const ::std::string& name,
      TextDeletionCapabilityType* value) {
    return Capability_TextDeletionCapabilityType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
  inline bool has_text_deletion() const;
  inline void clear_text_deletion();
  static const int kTextDeletionFieldNumber = 1;
  inline ::mozc::commands::Capability_TextDeletionCapabilityType text_deletion() const;
  inline void set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Capability)
 private:
  inline void set_has_text_deletion();
  inline void clear_has_text_deletion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int text_deletion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Capability* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_SpecialRomanjiTable SpecialRomanjiTable;
  static const SpecialRomanjiTable DEFAULT_TABLE = Request_SpecialRomanjiTable_DEFAULT_TABLE;
  static const SpecialRomanjiTable TWELVE_KEYS_TO_HIRAGANA = Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HIRAGANA;
  static const SpecialRomanjiTable TWELVE_KEYS_TO_HALFWIDTHASCII = Request_SpecialRomanjiTable_TWELVE_KEYS_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable TWELVE_KEYS_TO_NUMBER = Request_SpecialRomanjiTable_TWELVE_KEYS_TO_NUMBER;
  static const SpecialRomanjiTable FLICK_TO_HIRAGANA = Request_SpecialRomanjiTable_FLICK_TO_HIRAGANA;
  static const SpecialRomanjiTable FLICK_TO_HALFWIDTHASCII = Request_SpecialRomanjiTable_FLICK_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable FLICK_TO_NUMBER = Request_SpecialRomanjiTable_FLICK_TO_NUMBER;
  static const SpecialRomanjiTable TOGGLE_FLICK_TO_HIRAGANA = Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HIRAGANA;
  static const SpecialRomanjiTable TOGGLE_FLICK_TO_HALFWIDTHASCII = Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable TOGGLE_FLICK_TO_NUMBER = Request_SpecialRomanjiTable_TOGGLE_FLICK_TO_NUMBER;
  static const SpecialRomanjiTable QWERTY_MOBILE_TO_HIRAGANA = Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA;
  static const SpecialRomanjiTable QWERTY_MOBILE_TO_HIRAGANA_NUMBER = Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HIRAGANA_NUMBER;
  static const SpecialRomanjiTable QWERTY_MOBILE_TO_HALFWIDTHASCII = Request_SpecialRomanjiTable_QWERTY_MOBILE_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable GODAN_TO_HIRAGANA = Request_SpecialRomanjiTable_GODAN_TO_HIRAGANA;
  static const SpecialRomanjiTable GODAN_TO_HALFWIDTHASCII = Request_SpecialRomanjiTable_GODAN_TO_HALFWIDTHASCII;
  static const SpecialRomanjiTable GODAN_TO_NUMBER = Request_SpecialRomanjiTable_GODAN_TO_NUMBER;
  static inline bool SpecialRomanjiTable_IsValid(int value) {
    return Request_SpecialRomanjiTable_IsValid(value);
  }
  static const SpecialRomanjiTable SpecialRomanjiTable_MIN =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MIN;
  static const SpecialRomanjiTable SpecialRomanjiTable_MAX =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_MAX;
  static const int SpecialRomanjiTable_ARRAYSIZE =
    Request_SpecialRomanjiTable_SpecialRomanjiTable_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpecialRomanjiTable_descriptor() {
    return Request_SpecialRomanjiTable_descriptor();
  }
  static inline const ::std::string& SpecialRomanjiTable_Name(SpecialRomanjiTable value) {
    return Request_SpecialRomanjiTable_Name(value);
  }
  static inline bool SpecialRomanjiTable_Parse(const ::std::string& name,
      SpecialRomanjiTable* value) {
    return Request_SpecialRomanjiTable_Parse(name, value);
  }

  typedef Request_SpaceOnAlphanumeric SpaceOnAlphanumeric;
  static const SpaceOnAlphanumeric SPACE_OR_CONVERT_KEEPING_COMPOSITION = Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_KEEPING_COMPOSITION;
  static const SpaceOnAlphanumeric SPACE_OR_CONVERT_COMMITING_COMPOSITION = Request_SpaceOnAlphanumeric_SPACE_OR_CONVERT_COMMITING_COMPOSITION;
  static const SpaceOnAlphanumeric COMMIT = Request_SpaceOnAlphanumeric_COMMIT;
  static inline bool SpaceOnAlphanumeric_IsValid(int value) {
    return Request_SpaceOnAlphanumeric_IsValid(value);
  }
  static const SpaceOnAlphanumeric SpaceOnAlphanumeric_MIN =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MIN;
  static const SpaceOnAlphanumeric SpaceOnAlphanumeric_MAX =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_MAX;
  static const int SpaceOnAlphanumeric_ARRAYSIZE =
    Request_SpaceOnAlphanumeric_SpaceOnAlphanumeric_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpaceOnAlphanumeric_descriptor() {
    return Request_SpaceOnAlphanumeric_descriptor();
  }
  static inline const ::std::string& SpaceOnAlphanumeric_Name(SpaceOnAlphanumeric value) {
    return Request_SpaceOnAlphanumeric_Name(value);
  }
  static inline bool SpaceOnAlphanumeric_Parse(const ::std::string& name,
      SpaceOnAlphanumeric* value) {
    return Request_SpaceOnAlphanumeric_Parse(name, value);
  }

  typedef Request_EmojiCarrierType EmojiCarrierType;
  static const EmojiCarrierType UNICODE_EMOJI = Request_EmojiCarrierType_UNICODE_EMOJI;
  static const EmojiCarrierType DOCOMO_EMOJI = Request_EmojiCarrierType_DOCOMO_EMOJI;
  static const EmojiCarrierType SOFTBANK_EMOJI = Request_EmojiCarrierType_SOFTBANK_EMOJI;
  static const EmojiCarrierType KDDI_EMOJI = Request_EmojiCarrierType_KDDI_EMOJI;
  static inline bool EmojiCarrierType_IsValid(int value) {
    return Request_EmojiCarrierType_IsValid(value);
  }
  static const EmojiCarrierType EmojiCarrierType_MIN =
    Request_EmojiCarrierType_EmojiCarrierType_MIN;
  static const EmojiCarrierType EmojiCarrierType_MAX =
    Request_EmojiCarrierType_EmojiCarrierType_MAX;
  static const int EmojiCarrierType_ARRAYSIZE =
    Request_EmojiCarrierType_EmojiCarrierType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EmojiCarrierType_descriptor() {
    return Request_EmojiCarrierType_descriptor();
  }
  static inline const ::std::string& EmojiCarrierType_Name(EmojiCarrierType value) {
    return Request_EmojiCarrierType_Name(value);
  }
  static inline bool EmojiCarrierType_Parse(const ::std::string& name,
      EmojiCarrierType* value) {
    return Request_EmojiCarrierType_Parse(name, value);
  }

  typedef Request_RewriterCapability RewriterCapability;
  static const RewriterCapability NOT_AVAILABLE = Request_RewriterCapability_NOT_AVAILABLE;
  static const RewriterCapability CONVERSION = Request_RewriterCapability_CONVERSION;
  static const RewriterCapability PREDICTION = Request_RewriterCapability_PREDICTION;
  static const RewriterCapability SUGGESTION = Request_RewriterCapability_SUGGESTION;
  static const RewriterCapability ALL = Request_RewriterCapability_ALL;
  static inline bool RewriterCapability_IsValid(int value) {
    return Request_RewriterCapability_IsValid(value);
  }
  static const RewriterCapability RewriterCapability_MIN =
    Request_RewriterCapability_RewriterCapability_MIN;
  static const RewriterCapability RewriterCapability_MAX =
    Request_RewriterCapability_RewriterCapability_MAX;
  static const int RewriterCapability_ARRAYSIZE =
    Request_RewriterCapability_RewriterCapability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RewriterCapability_descriptor() {
    return Request_RewriterCapability_descriptor();
  }
  static inline const ::std::string& RewriterCapability_Name(RewriterCapability value) {
    return Request_RewriterCapability_Name(value);
  }
  static inline bool RewriterCapability_Parse(const ::std::string& name,
      RewriterCapability* value) {
    return Request_RewriterCapability_Parse(name, value);
  }

  typedef Request_CrossingEdgeBehavior CrossingEdgeBehavior;
  static const CrossingEdgeBehavior DO_NOTHING = Request_CrossingEdgeBehavior_DO_NOTHING;
  static const CrossingEdgeBehavior COMMIT_WITHOUT_CONSUMING = Request_CrossingEdgeBehavior_COMMIT_WITHOUT_CONSUMING;
  static inline bool CrossingEdgeBehavior_IsValid(int value) {
    return Request_CrossingEdgeBehavior_IsValid(value);
  }
  static const CrossingEdgeBehavior CrossingEdgeBehavior_MIN =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MIN;
  static const CrossingEdgeBehavior CrossingEdgeBehavior_MAX =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_MAX;
  static const int CrossingEdgeBehavior_ARRAYSIZE =
    Request_CrossingEdgeBehavior_CrossingEdgeBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CrossingEdgeBehavior_descriptor() {
    return Request_CrossingEdgeBehavior_descriptor();
  }
  static inline const ::std::string& CrossingEdgeBehavior_Name(CrossingEdgeBehavior value) {
    return Request_CrossingEdgeBehavior_Name(value);
  }
  static inline bool CrossingEdgeBehavior_Parse(const ::std::string& name,
      CrossingEdgeBehavior* value) {
    return Request_CrossingEdgeBehavior_Parse(name, value);
  }

  typedef Request_LanguageAwareInputBehavior LanguageAwareInputBehavior;
  static const LanguageAwareInputBehavior DEFAULT_LANGUAGE_AWARE_BEHAVIOR = Request_LanguageAwareInputBehavior_DEFAULT_LANGUAGE_AWARE_BEHAVIOR;
  static const LanguageAwareInputBehavior NO_LANGUAGE_AWARE_INPUT = Request_LanguageAwareInputBehavior_NO_LANGUAGE_AWARE_INPUT;
  static const LanguageAwareInputBehavior LANGUAGE_AWARE_SUGGESTION = Request_LanguageAwareInputBehavior_LANGUAGE_AWARE_SUGGESTION;
  static inline bool LanguageAwareInputBehavior_IsValid(int value) {
    return Request_LanguageAwareInputBehavior_IsValid(value);
  }
  static const LanguageAwareInputBehavior LanguageAwareInputBehavior_MIN =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MIN;
  static const LanguageAwareInputBehavior LanguageAwareInputBehavior_MAX =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_MAX;
  static const int LanguageAwareInputBehavior_ARRAYSIZE =
    Request_LanguageAwareInputBehavior_LanguageAwareInputBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LanguageAwareInputBehavior_descriptor() {
    return Request_LanguageAwareInputBehavior_descriptor();
  }
  static inline const ::std::string& LanguageAwareInputBehavior_Name(LanguageAwareInputBehavior value) {
    return Request_LanguageAwareInputBehavior_Name(value);
  }
  static inline bool LanguageAwareInputBehavior_Parse(const ::std::string& name,
      LanguageAwareInputBehavior* value) {
    return Request_LanguageAwareInputBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool zero_query_suggestion = 1 [default = false];
  inline bool has_zero_query_suggestion() const;
  inline void clear_zero_query_suggestion();
  static const int kZeroQuerySuggestionFieldNumber = 1;
  inline bool zero_query_suggestion() const;
  inline void set_zero_query_suggestion(bool value);

  // optional bool mixed_conversion = 2 [default = false];
  inline bool has_mixed_conversion() const;
  inline void clear_mixed_conversion();
  static const int kMixedConversionFieldNumber = 2;
  inline bool mixed_conversion() const;
  inline void set_mixed_conversion(bool value);

  // optional bool combine_all_segments = 3 [default = false];
  inline bool has_combine_all_segments() const;
  inline void clear_combine_all_segments();
  static const int kCombineAllSegmentsFieldNumber = 3;
  inline bool combine_all_segments() const;
  inline void set_combine_all_segments(bool value);

  // optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
  inline bool has_special_romanji_table() const;
  inline void clear_special_romanji_table();
  static const int kSpecialRomanjiTableFieldNumber = 4;
  inline ::mozc::commands::Request_SpecialRomanjiTable special_romanji_table() const;
  inline void set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value);

  // optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
  inline bool has_space_on_alphanumeric() const;
  inline void clear_space_on_alphanumeric();
  static const int kSpaceOnAlphanumericFieldNumber = 6;
  inline ::mozc::commands::Request_SpaceOnAlphanumeric space_on_alphanumeric() const;
  inline void set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value);

  // optional string keyboard_name = 7;
  inline bool has_keyboard_name() const;
  inline void clear_keyboard_name();
  static const int kKeyboardNameFieldNumber = 7;
  inline const ::std::string& keyboard_name() const;
  inline void set_keyboard_name(const ::std::string& value);
  inline void set_keyboard_name(const char* value);
  inline void set_keyboard_name(const char* value, size_t size);
  inline ::std::string* mutable_keyboard_name();
  inline ::std::string* release_keyboard_name();
  inline void set_allocated_keyboard_name(::std::string* keyboard_name);

  // optional bool update_input_mode_from_surrounding_text = 8 [default = true];
  inline bool has_update_input_mode_from_surrounding_text() const;
  inline void clear_update_input_mode_from_surrounding_text();
  static const int kUpdateInputModeFromSurroundingTextFieldNumber = 8;
  inline bool update_input_mode_from_surrounding_text() const;
  inline void set_update_input_mode_from_surrounding_text(bool value);

  // optional bool kana_modifier_insensitive_conversion = 9 [default = false];
  inline bool has_kana_modifier_insensitive_conversion() const;
  inline void clear_kana_modifier_insensitive_conversion();
  static const int kKanaModifierInsensitiveConversionFieldNumber = 9;
  inline bool kana_modifier_insensitive_conversion() const;
  inline void set_kana_modifier_insensitive_conversion(bool value);

  // optional bool auto_partial_suggestion = 10 [default = false];
  inline bool has_auto_partial_suggestion() const;
  inline void clear_auto_partial_suggestion();
  static const int kAutoPartialSuggestionFieldNumber = 10;
  inline bool auto_partial_suggestion() const;
  inline void set_auto_partial_suggestion(bool value);

  // optional int32 available_emoji_carrier = 11 [default = 1];
  inline bool has_available_emoji_carrier() const;
  inline void clear_available_emoji_carrier();
  static const int kAvailableEmojiCarrierFieldNumber = 11;
  inline ::google::protobuf::int32 available_emoji_carrier() const;
  inline void set_available_emoji_carrier(::google::protobuf::int32 value);

  // optional int32 emoji_rewriter_capability = 12 [default = 1];
  inline bool has_emoji_rewriter_capability() const;
  inline void clear_emoji_rewriter_capability();
  static const int kEmojiRewriterCapabilityFieldNumber = 12;
  inline ::google::protobuf::int32 emoji_rewriter_capability() const;
  inline void set_emoji_rewriter_capability(::google::protobuf::int32 value);

  // optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
  inline bool has_crossing_edge_behavior() const;
  inline void clear_crossing_edge_behavior();
  static const int kCrossingEdgeBehaviorFieldNumber = 13;
  inline ::mozc::commands::Request_CrossingEdgeBehavior crossing_edge_behavior() const;
  inline void set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value);

  // optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
  inline bool has_language_aware_input() const;
  inline void clear_language_aware_input();
  static const int kLanguageAwareInputFieldNumber = 14;
  inline ::mozc::commands::Request_LanguageAwareInputBehavior language_aware_input() const;
  inline void set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Request)
 private:
  inline void set_has_zero_query_suggestion();
  inline void clear_has_zero_query_suggestion();
  inline void set_has_mixed_conversion();
  inline void clear_has_mixed_conversion();
  inline void set_has_combine_all_segments();
  inline void clear_has_combine_all_segments();
  inline void set_has_special_romanji_table();
  inline void clear_has_special_romanji_table();
  inline void set_has_space_on_alphanumeric();
  inline void clear_has_space_on_alphanumeric();
  inline void set_has_keyboard_name();
  inline void clear_has_keyboard_name();
  inline void set_has_update_input_mode_from_surrounding_text();
  inline void clear_has_update_input_mode_from_surrounding_text();
  inline void set_has_kana_modifier_insensitive_conversion();
  inline void clear_has_kana_modifier_insensitive_conversion();
  inline void set_has_auto_partial_suggestion();
  inline void clear_has_auto_partial_suggestion();
  inline void set_has_available_emoji_carrier();
  inline void clear_has_available_emoji_carrier();
  inline void set_has_emoji_rewriter_capability();
  inline void clear_has_emoji_rewriter_capability();
  inline void set_has_crossing_edge_behavior();
  inline void clear_has_crossing_edge_behavior();
  inline void set_has_language_aware_input();
  inline void clear_has_language_aware_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool zero_query_suggestion_;
  bool mixed_conversion_;
  bool combine_all_segments_;
  bool update_input_mode_from_surrounding_text_;
  int special_romanji_table_;
  ::std::string* keyboard_name_;
  int space_on_alphanumeric_;
  bool kana_modifier_insensitive_conversion_;
  bool auto_partial_suggestion_;
  ::google::protobuf::int32 available_emoji_carrier_;
  ::google::protobuf::int32 emoji_rewriter_capability_;
  int crossing_edge_behavior_;
  int language_aware_input_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class ApplicationInfo : public ::google::protobuf::Message {
 public:
  ApplicationInfo();
  virtual ~ApplicationInfo();

  ApplicationInfo(const ApplicationInfo& from);

  inline ApplicationInfo& operator=(const ApplicationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplicationInfo& default_instance();

  void Swap(ApplicationInfo* other);

  // implements Message ----------------------------------------------

  ApplicationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplicationInfo& from);
  void MergeFrom(const ApplicationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 process_id = 1;
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 1;
  inline ::google::protobuf::uint32 process_id() const;
  inline void set_process_id(::google::protobuf::uint32 value);

  // optional uint32 thread_id = 2;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 2;
  inline ::google::protobuf::uint32 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint32 value);

  // optional int32 timezone_offset = 3;
  inline bool has_timezone_offset() const;
  inline void clear_timezone_offset();
  static const int kTimezoneOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 timezone_offset() const;
  inline void set_timezone_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.ApplicationInfo)
 private:
  inline void set_has_process_id();
  inline void clear_has_process_id();
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_timezone_offset();
  inline void clear_has_timezone_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 process_id_;
  ::google::protobuf::uint32 thread_id_;
  ::google::protobuf::int32 timezone_offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static ApplicationInfo* default_instance_;
};
// -------------------------------------------------------------------

class Input_TouchPosition : public ::google::protobuf::Message {
 public:
  Input_TouchPosition();
  virtual ~Input_TouchPosition();

  Input_TouchPosition(const Input_TouchPosition& from);

  inline Input_TouchPosition& operator=(const Input_TouchPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_TouchPosition& default_instance();

  void Swap(Input_TouchPosition* other);

  // implements Message ----------------------------------------------

  Input_TouchPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input_TouchPosition& from);
  void MergeFrom(const Input_TouchPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozc.commands.Input.TouchAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::mozc::commands::Input_TouchAction action() const;
  inline void set_action(::mozc::commands::Input_TouchAction value);

  // optional float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // optional int64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchPosition)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int action_;
  float x_;
  ::google::protobuf::int64 timestamp_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Input_TouchPosition* default_instance_;
};
// -------------------------------------------------------------------

class Input_TouchEvent : public ::google::protobuf::Message {
 public:
  Input_TouchEvent();
  virtual ~Input_TouchEvent();

  Input_TouchEvent(const Input_TouchEvent& from);

  inline Input_TouchEvent& operator=(const Input_TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input_TouchEvent& default_instance();

  void Swap(Input_TouchEvent* other);

  // implements Message ----------------------------------------------

  Input_TouchEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input_TouchEvent& from);
  void MergeFrom(const Input_TouchEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 source_id = 1;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  // repeated .mozc.commands.Input.TouchPosition stroke = 2;
  inline int stroke_size() const;
  inline void clear_stroke();
  static const int kStrokeFieldNumber = 2;
  inline const ::mozc::commands::Input_TouchPosition& stroke(int index) const;
  inline ::mozc::commands::Input_TouchPosition* mutable_stroke(int index);
  inline ::mozc::commands::Input_TouchPosition* add_stroke();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
      stroke() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
      mutable_stroke();

  // @@protoc_insertion_point(class_scope:mozc.commands.Input.TouchEvent)
 private:
  inline void set_has_source_id();
  inline void clear_has_source_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition > stroke_;
  ::google::protobuf::uint32 source_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Input_TouchEvent* default_instance_;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  void Swap(Input* other);

  // implements Message ----------------------------------------------

  Input* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Input_TouchPosition TouchPosition;
  typedef Input_TouchEvent TouchEvent;

  typedef Input_CommandType CommandType;
  static const CommandType NONE = Input_CommandType_NONE;
  static const CommandType CREATE_SESSION = Input_CommandType_CREATE_SESSION;
  static const CommandType DELETE_SESSION = Input_CommandType_DELETE_SESSION;
  static const CommandType SEND_KEY = Input_CommandType_SEND_KEY;
  static const CommandType TEST_SEND_KEY = Input_CommandType_TEST_SEND_KEY;
  static const CommandType SEND_COMMAND = Input_CommandType_SEND_COMMAND;
  static const CommandType GET_CONFIG = Input_CommandType_GET_CONFIG;
  static const CommandType SET_CONFIG = Input_CommandType_SET_CONFIG;
  static const CommandType SET_IMPOSED_CONFIG = Input_CommandType_SET_IMPOSED_CONFIG;
  static const CommandType SET_REQUEST = Input_CommandType_SET_REQUEST;
  static const CommandType SYNC_DATA = Input_CommandType_SYNC_DATA;
  static const CommandType SHUTDOWN = Input_CommandType_SHUTDOWN;
  static const CommandType RELOAD = Input_CommandType_RELOAD;
  static const CommandType CLEAR_USER_HISTORY = Input_CommandType_CLEAR_USER_HISTORY;
  static const CommandType CLEAR_USER_PREDICTION = Input_CommandType_CLEAR_USER_PREDICTION;
  static const CommandType CLEAR_UNUSED_USER_PREDICTION = Input_CommandType_CLEAR_UNUSED_USER_PREDICTION;
  static const CommandType CLEANUP = Input_CommandType_CLEANUP;
  static const CommandType NO_OPERATION = Input_CommandType_NO_OPERATION;
  static const CommandType OBSOLETE_START_CLOUD_SYNC = Input_CommandType_OBSOLETE_START_CLOUD_SYNC;
  static const CommandType OBSOLETE_GET_CLOUD_SYNC_STATUS = Input_CommandType_OBSOLETE_GET_CLOUD_SYNC_STATUS;
  static const CommandType OBSOLETE_ADD_AUTH_CODE = Input_CommandType_OBSOLETE_ADD_AUTH_CODE;
  static const CommandType INSERT_TO_STORAGE = Input_CommandType_INSERT_TO_STORAGE;
  static const CommandType READ_ALL_FROM_STORAGE = Input_CommandType_READ_ALL_FROM_STORAGE;
  static const CommandType CLEAR_STORAGE = Input_CommandType_CLEAR_STORAGE;
  static const CommandType SEND_USER_DICTIONARY_COMMAND = Input_CommandType_SEND_USER_DICTIONARY_COMMAND;
  static const CommandType NUM_OF_COMMANDS = Input_CommandType_NUM_OF_COMMANDS;
  static inline bool CommandType_IsValid(int value) {
    return Input_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Input_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Input_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Input_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Input_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Input_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Input_CommandType_Parse(name, value);
  }

  typedef Input_TouchAction TouchAction;
  static const TouchAction TOUCH_DOWN = Input_TouchAction_TOUCH_DOWN;
  static const TouchAction TOUCH_MOVE = Input_TouchAction_TOUCH_MOVE;
  static const TouchAction TOUCH_UP = Input_TouchAction_TOUCH_UP;
  static inline bool TouchAction_IsValid(int value) {
    return Input_TouchAction_IsValid(value);
  }
  static const TouchAction TouchAction_MIN =
    Input_TouchAction_TouchAction_MIN;
  static const TouchAction TouchAction_MAX =
    Input_TouchAction_TouchAction_MAX;
  static const int TouchAction_ARRAYSIZE =
    Input_TouchAction_TouchAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TouchAction_descriptor() {
    return Input_TouchAction_descriptor();
  }
  static inline const ::std::string& TouchAction_Name(TouchAction value) {
    return Input_TouchAction_Name(value);
  }
  static inline bool TouchAction_Parse(const ::std::string& name,
      TouchAction* value) {
    return Input_TouchAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mozc.commands.Input.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mozc::commands::Input_CommandType type() const;
  inline void set_type(::mozc::commands::Input_CommandType value);

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional .mozc.commands.KeyEvent key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::mozc::commands::KeyEvent& key() const;
  inline ::mozc::commands::KeyEvent* mutable_key();
  inline ::mozc::commands::KeyEvent* release_key();
  inline void set_allocated_key(::mozc::commands::KeyEvent* key);

  // optional .mozc.commands.SessionCommand command = 4;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 4;
  inline const ::mozc::commands::SessionCommand& command() const;
  inline ::mozc::commands::SessionCommand* mutable_command();
  inline ::mozc::commands::SessionCommand* release_command();
  inline void set_allocated_command(::mozc::commands::SessionCommand* command);

  // optional .mozc.config.Config config = 5;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 5;
  inline const ::mozc::config::Config& config() const;
  inline ::mozc::config::Config* mutable_config();
  inline ::mozc::config::Config* release_config();
  inline void set_allocated_config(::mozc::config::Config* config);

  // optional .mozc.commands.Context context = 6;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 6;
  inline const ::mozc::commands::Context& context() const;
  inline ::mozc::commands::Context* mutable_context();
  inline ::mozc::commands::Context* release_context();
  inline void set_allocated_context(::mozc::commands::Context* context);

  // optional .mozc.commands.Capability capability = 7;
  inline bool has_capability() const;
  inline void clear_capability();
  static const int kCapabilityFieldNumber = 7;
  inline const ::mozc::commands::Capability& capability() const;
  inline ::mozc::commands::Capability* mutable_capability();
  inline ::mozc::commands::Capability* release_capability();
  inline void set_allocated_capability(::mozc::commands::Capability* capability);

  // optional .mozc.commands.ApplicationInfo application_info = 8;
  inline bool has_application_info() const;
  inline void clear_application_info();
  static const int kApplicationInfoFieldNumber = 8;
  inline const ::mozc::commands::ApplicationInfo& application_info() const;
  inline ::mozc::commands::ApplicationInfo* mutable_application_info();
  inline ::mozc::commands::ApplicationInfo* release_application_info();
  inline void set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info);

  // optional .mozc.commands.Request request = 9;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 9;
  inline const ::mozc::commands::Request& request() const;
  inline ::mozc::commands::Request* mutable_request();
  inline ::mozc::commands::Request* release_request();
  inline void set_allocated_request(::mozc::commands::Request* request);

  // optional .mozc.commands.GenericStorageEntry storage_entry = 10;
  inline bool has_storage_entry() const;
  inline void clear_storage_entry();
  static const int kStorageEntryFieldNumber = 10;
  inline const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  inline ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  inline ::mozc::commands::GenericStorageEntry* release_storage_entry();
  inline void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);

  // repeated .mozc.commands.Input.TouchEvent touch_events = 12;
  inline int touch_events_size() const;
  inline void clear_touch_events();
  static const int kTouchEventsFieldNumber = 12;
  inline const ::mozc::commands::Input_TouchEvent& touch_events(int index) const;
  inline ::mozc::commands::Input_TouchEvent* mutable_touch_events(int index);
  inline ::mozc::commands::Input_TouchEvent* add_touch_events();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
      touch_events() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
      mutable_touch_events();

  // optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
  inline bool has_user_dictionary_command() const;
  inline void clear_user_dictionary_command();
  static const int kUserDictionaryCommandFieldNumber = 13;
  inline const ::mozc::user_dictionary::UserDictionaryCommand& user_dictionary_command() const;
  inline ::mozc::user_dictionary::UserDictionaryCommand* mutable_user_dictionary_command();
  inline ::mozc::user_dictionary::UserDictionaryCommand* release_user_dictionary_command();
  inline void set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command);

  // optional bool request_suggestion = 14 [default = true];
  inline bool has_request_suggestion() const;
  inline void clear_request_suggestion();
  static const int kRequestSuggestionFieldNumber = 14;
  inline bool request_suggestion() const;
  inline void set_request_suggestion(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Input)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_capability();
  inline void clear_has_capability();
  inline void set_has_application_info();
  inline void clear_has_application_info();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_storage_entry();
  inline void clear_has_storage_entry();
  inline void set_has_user_dictionary_command();
  inline void clear_has_user_dictionary_command();
  inline void set_has_request_suggestion();
  inline void clear_has_request_suggestion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::mozc::commands::KeyEvent* key_;
  ::mozc::commands::SessionCommand* command_;
  ::mozc::config::Config* config_;
  ::mozc::commands::Context* context_;
  ::mozc::commands::Capability* capability_;
  int type_;
  bool request_suggestion_;
  ::mozc::commands::ApplicationInfo* application_info_;
  ::mozc::commands::Request* request_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent > touch_events_;
  ::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Input* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Result_ResultType ResultType;
  static const ResultType NONE = Result_ResultType_NONE;
  static const ResultType STRING = Result_ResultType_STRING;
  static inline bool ResultType_IsValid(int value) {
    return Result_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    Result_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    Result_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    Result_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return Result_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return Result_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return Result_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mozc.commands.Result.ResultType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::mozc::commands::Result_ResultType type() const;
  inline void set_type(::mozc::commands::Result_ResultType value);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional int32 cursor_offset = 4 [default = 0];
  inline bool has_cursor_offset() const;
  inline void clear_cursor_offset();
  static const int kCursorOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 cursor_offset() const;
  inline void set_cursor_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Result)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_cursor_offset();
  inline void clear_has_cursor_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  int type_;
  ::google::protobuf::int32 cursor_offset_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// -------------------------------------------------------------------

class Preedit_Segment : public ::google::protobuf::Message {
 public:
  Preedit_Segment();
  virtual ~Preedit_Segment();

  Preedit_Segment(const Preedit_Segment& from);

  inline Preedit_Segment& operator=(const Preedit_Segment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Preedit_Segment& default_instance();

  void Swap(Preedit_Segment* other);

  // implements Message ----------------------------------------------

  Preedit_Segment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Preedit_Segment& from);
  void MergeFrom(const Preedit_Segment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Preedit_Segment_Annotation Annotation;
  static const Annotation NONE = Preedit_Segment_Annotation_NONE;
  static const Annotation UNDERLINE = Preedit_Segment_Annotation_UNDERLINE;
  static const Annotation HIGHLIGHT = Preedit_Segment_Annotation_HIGHLIGHT;
  static inline bool Annotation_IsValid(int value) {
    return Preedit_Segment_Annotation_IsValid(value);
  }
  static const Annotation Annotation_MIN =
    Preedit_Segment_Annotation_Annotation_MIN;
  static const Annotation Annotation_MAX =
    Preedit_Segment_Annotation_Annotation_MAX;
  static const int Annotation_ARRAYSIZE =
    Preedit_Segment_Annotation_Annotation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Annotation_descriptor() {
    return Preedit_Segment_Annotation_descriptor();
  }
  static inline const ::std::string& Annotation_Name(Annotation value) {
    return Preedit_Segment_Annotation_Name(value);
  }
  static inline bool Annotation_Parse(const ::std::string& name,
      Annotation* value) {
    return Preedit_Segment_Annotation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 3;
  inline ::mozc::commands::Preedit_Segment_Annotation annotation() const;
  inline void set_annotation(::mozc::commands::Preedit_Segment_Annotation value);

  // required string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // required uint32 value_length = 5;
  inline bool has_value_length() const;
  inline void clear_value_length();
  static const int kValueLengthFieldNumber = 5;
  inline ::google::protobuf::uint32 value_length() const;
  inline void set_value_length(::google::protobuf::uint32 value);

  // optional string key = 6;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 6;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit.Segment)
 private:
  inline void set_has_annotation();
  inline void clear_has_annotation();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_value_length();
  inline void clear_has_value_length();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  int annotation_;
  ::google::protobuf::uint32 value_length_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Preedit_Segment* default_instance_;
};
// -------------------------------------------------------------------

class Preedit : public ::google::protobuf::Message {
 public:
  Preedit();
  virtual ~Preedit();

  Preedit(const Preedit& from);

  inline Preedit& operator=(const Preedit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Preedit& default_instance();

  void Swap(Preedit* other);

  // implements Message ----------------------------------------------

  Preedit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Preedit& from);
  void MergeFrom(const Preedit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Preedit_Segment Segment;

  // accessors -------------------------------------------------------

  // required uint32 cursor = 1;
  inline bool has_cursor() const;
  inline void clear_cursor();
  static const int kCursorFieldNumber = 1;
  inline ::google::protobuf::uint32 cursor() const;
  inline void set_cursor(::google::protobuf::uint32 value);

  // repeated group Segment = 2 {
  inline int segment_size() const;
  inline void clear_segment();
  static const int kSegmentFieldNumber = 2;
  inline const ::mozc::commands::Preedit_Segment& segment(int index) const;
  inline ::mozc::commands::Preedit_Segment* mutable_segment(int index);
  inline ::mozc::commands::Preedit_Segment* add_segment();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
      segment() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
      mutable_segment();

  // optional uint32 highlighted_position = 3;
  inline bool has_highlighted_position() const;
  inline void clear_highlighted_position();
  static const int kHighlightedPositionFieldNumber = 3;
  inline ::google::protobuf::uint32 highlighted_position() const;
  inline void set_highlighted_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Preedit)
 private:
  inline void set_has_cursor();
  inline void clear_has_cursor();
  inline void set_has_highlighted_position();
  inline void clear_has_highlighted_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment > segment_;
  ::google::protobuf::uint32 cursor_;
  ::google::protobuf::uint32 highlighted_position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Preedit* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool activated = 1;
  inline bool has_activated() const;
  inline void clear_activated();
  static const int kActivatedFieldNumber = 1;
  inline bool activated() const;
  inline void set_activated(bool value);

  // optional .mozc.commands.CompositionMode mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mozc::commands::CompositionMode mode() const;
  inline void set_mode(::mozc::commands::CompositionMode value);

  // optional .mozc.commands.CompositionMode comeback_mode = 3;
  inline bool has_comeback_mode() const;
  inline void clear_comeback_mode();
  static const int kComebackModeFieldNumber = 3;
  inline ::mozc::commands::CompositionMode comeback_mode() const;
  inline void set_comeback_mode(::mozc::commands::CompositionMode value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Status)
 private:
  inline void set_has_activated();
  inline void clear_has_activated();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_comeback_mode();
  inline void clear_has_comeback_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool activated_;
  int mode_;
  int comeback_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class DeletionRange : public ::google::protobuf::Message {
 public:
  DeletionRange();
  virtual ~DeletionRange();

  DeletionRange(const DeletionRange& from);

  inline DeletionRange& operator=(const DeletionRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeletionRange& default_instance();

  void Swap(DeletionRange* other);

  // implements Message ----------------------------------------------

  DeletionRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeletionRange& from);
  void MergeFrom(const DeletionRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional int32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.DeletionRange)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 offset_;
  ::google::protobuf::int32 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static DeletionRange* default_instance_;
};
// -------------------------------------------------------------------

class Output_Callback : public ::google::protobuf::Message {
 public:
  Output_Callback();
  virtual ~Output_Callback();

  Output_Callback(const Output_Callback& from);

  inline Output_Callback& operator=(const Output_Callback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output_Callback& default_instance();

  void Swap(Output_Callback* other);

  // implements Message ----------------------------------------------

  Output_Callback* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output_Callback& from);
  void MergeFrom(const Output_Callback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozc.commands.SessionCommand session_command = 1;
  inline bool has_session_command() const;
  inline void clear_session_command();
  static const int kSessionCommandFieldNumber = 1;
  inline const ::mozc::commands::SessionCommand& session_command() const;
  inline ::mozc::commands::SessionCommand* mutable_session_command();
  inline ::mozc::commands::SessionCommand* release_session_command();
  inline void set_allocated_session_command(::mozc::commands::SessionCommand* session_command);

  // optional uint32 delay_millisec = 2;
  inline bool has_delay_millisec() const;
  inline void clear_delay_millisec();
  static const int kDelayMillisecFieldNumber = 2;
  inline ::google::protobuf::uint32 delay_millisec() const;
  inline void set_delay_millisec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Output.Callback)
 private:
  inline void set_has_session_command();
  inline void clear_has_session_command();
  inline void set_has_delay_millisec();
  inline void clear_has_delay_millisec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mozc::commands::SessionCommand* session_command_;
  ::google::protobuf::uint32 delay_millisec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Output_Callback* default_instance_;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  void Swap(Output* other);

  // implements Message ----------------------------------------------

  Output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Output_Callback Callback;

  typedef Output_PreeditMethod PreeditMethod;
  static const PreeditMethod ASCII = Output_PreeditMethod_ASCII;
  static const PreeditMethod KANA = Output_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Output_PreeditMethod_IsValid(value);
  }
  static const PreeditMethod PreeditMethod_MIN =
    Output_PreeditMethod_PreeditMethod_MIN;
  static const PreeditMethod PreeditMethod_MAX =
    Output_PreeditMethod_PreeditMethod_MAX;
  static const int PreeditMethod_ARRAYSIZE =
    Output_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Output_PreeditMethod_descriptor();
  }
  static inline const ::std::string& PreeditMethod_Name(PreeditMethod value) {
    return Output_PreeditMethod_Name(value);
  }
  static inline bool PreeditMethod_Parse(const ::std::string& name,
      PreeditMethod* value) {
    return Output_PreeditMethod_Parse(name, value);
  }

  typedef Output_ErrorCode ErrorCode;
  static const ErrorCode SESSION_SUCCESS = Output_ErrorCode_SESSION_SUCCESS;
  static const ErrorCode SESSION_FAILURE = Output_ErrorCode_SESSION_FAILURE;
  static inline bool ErrorCode_IsValid(int value) {
    return Output_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    Output_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    Output_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    Output_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return Output_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return Output_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return Output_ErrorCode_Parse(name, value);
  }

  typedef Output_ToolMode ToolMode;
  static const ToolMode NO_TOOL = Output_ToolMode_NO_TOOL;
  static const ToolMode CONFIG_DIALOG = Output_ToolMode_CONFIG_DIALOG;
  static const ToolMode DICTIONARY_TOOL = Output_ToolMode_DICTIONARY_TOOL;
  static const ToolMode WORD_REGISTER_DIALOG = Output_ToolMode_WORD_REGISTER_DIALOG;
  static inline bool ToolMode_IsValid(int value) {
    return Output_ToolMode_IsValid(value);
  }
  static const ToolMode ToolMode_MIN =
    Output_ToolMode_ToolMode_MIN;
  static const ToolMode ToolMode_MAX =
    Output_ToolMode_ToolMode_MAX;
  static const int ToolMode_ARRAYSIZE =
    Output_ToolMode_ToolMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ToolMode_descriptor() {
    return Output_ToolMode_descriptor();
  }
  static inline const ::std::string& ToolMode_Name(ToolMode value) {
    return Output_ToolMode_Name(value);
  }
  static inline bool ToolMode_Parse(const ::std::string& name,
      ToolMode* value) {
    return Output_ToolMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional .mozc.commands.CompositionMode mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::mozc::commands::CompositionMode mode() const;
  inline void set_mode(::mozc::commands::CompositionMode value);

  // optional bool consumed = 3;
  inline bool has_consumed() const;
  inline void clear_consumed();
  static const int kConsumedFieldNumber = 3;
  inline bool consumed() const;
  inline void set_consumed(bool value);

  // optional .mozc.commands.Result result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline const ::mozc::commands::Result& result() const;
  inline ::mozc::commands::Result* mutable_result();
  inline ::mozc::commands::Result* release_result();
  inline void set_allocated_result(::mozc::commands::Result* result);

  // optional .mozc.commands.Preedit preedit = 5;
  inline bool has_preedit() const;
  inline void clear_preedit();
  static const int kPreeditFieldNumber = 5;
  inline const ::mozc::commands::Preedit& preedit() const;
  inline ::mozc::commands::Preedit* mutable_preedit();
  inline ::mozc::commands::Preedit* release_preedit();
  inline void set_allocated_preedit(::mozc::commands::Preedit* preedit);

  // optional .mozc.commands.Candidates candidates = 6;
  inline bool has_candidates() const;
  inline void clear_candidates();
  static const int kCandidatesFieldNumber = 6;
  inline const ::mozc::commands::Candidates& candidates() const;
  inline ::mozc::commands::Candidates* mutable_candidates();
  inline ::mozc::commands::Candidates* release_candidates();
  inline void set_allocated_candidates(::mozc::commands::Candidates* candidates);

  // optional .mozc.commands.KeyEvent key = 7;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline const ::mozc::commands::KeyEvent& key() const;
  inline ::mozc::commands::KeyEvent* mutable_key();
  inline ::mozc::commands::KeyEvent* release_key();
  inline void set_allocated_key(::mozc::commands::KeyEvent* key);

  // optional string url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .mozc.config.Config config = 9;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 9;
  inline const ::mozc::config::Config& config() const;
  inline ::mozc::config::Config* mutable_config();
  inline ::mozc::config::Config* release_config();
  inline void set_allocated_config(::mozc::config::Config* config);

  // optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
  inline bool has_preedit_method() const;
  inline void clear_preedit_method();
  static const int kPreeditMethodFieldNumber = 10;
  inline ::mozc::commands::Output_PreeditMethod preedit_method() const;
  inline void set_preedit_method(::mozc::commands::Output_PreeditMethod value);

  // optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 11;
  inline ::mozc::commands::Output_ErrorCode error_code() const;
  inline void set_error_code(::mozc::commands::Output_ErrorCode value);

  // optional .mozc.commands.Status status = 13;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 13;
  inline const ::mozc::commands::Status& status() const;
  inline ::mozc::commands::Status* mutable_status();
  inline ::mozc::commands::Status* release_status();
  inline void set_allocated_status(::mozc::commands::Status* status);

  // optional .mozc.commands.CandidateList all_candidate_words = 14;
  inline bool has_all_candidate_words() const;
  inline void clear_all_candidate_words();
  static const int kAllCandidateWordsFieldNumber = 14;
  inline const ::mozc::commands::CandidateList& all_candidate_words() const;
  inline ::mozc::commands::CandidateList* mutable_all_candidate_words();
  inline ::mozc::commands::CandidateList* release_all_candidate_words();
  inline void set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words);

  // optional .mozc.commands.DeletionRange deletion_range = 16;
  inline bool has_deletion_range() const;
  inline void clear_deletion_range();
  static const int kDeletionRangeFieldNumber = 16;
  inline const ::mozc::commands::DeletionRange& deletion_range() const;
  inline ::mozc::commands::DeletionRange* mutable_deletion_range();
  inline ::mozc::commands::DeletionRange* release_deletion_range();
  inline void set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range);

  // optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
  inline bool has_launch_tool_mode() const;
  inline void clear_launch_tool_mode();
  static const int kLaunchToolModeFieldNumber = 17;
  inline ::mozc::commands::Output_ToolMode launch_tool_mode() const;
  inline void set_launch_tool_mode(::mozc::commands::Output_ToolMode value);

  // optional .mozc.commands.Output.Callback callback = 18;
  inline bool has_callback() const;
  inline void clear_callback();
  static const int kCallbackFieldNumber = 18;
  inline const ::mozc::commands::Output_Callback& callback() const;
  inline ::mozc::commands::Output_Callback* mutable_callback();
  inline ::mozc::commands::Output_Callback* release_callback();
  inline void set_allocated_callback(::mozc::commands::Output_Callback* callback);

  // optional .mozc.commands.GenericStorageEntry storage_entry = 19;
  inline bool has_storage_entry() const;
  inline void clear_storage_entry();
  static const int kStorageEntryFieldNumber = 19;
  inline const ::mozc::commands::GenericStorageEntry& storage_entry() const;
  inline ::mozc::commands::GenericStorageEntry* mutable_storage_entry();
  inline ::mozc::commands::GenericStorageEntry* release_storage_entry();
  inline void set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry);

  // optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
  inline bool has_user_dictionary_command_status() const;
  inline void clear_user_dictionary_command_status();
  static const int kUserDictionaryCommandStatusFieldNumber = 21;
  inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& user_dictionary_command_status() const;
  inline ::mozc::user_dictionary::UserDictionaryCommandStatus* mutable_user_dictionary_command_status();
  inline ::mozc::user_dictionary::UserDictionaryCommandStatus* release_user_dictionary_command_status();
  inline void set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status);

  // @@protoc_insertion_point(class_scope:mozc.commands.Output)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_consumed();
  inline void clear_has_consumed();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_preedit();
  inline void clear_has_preedit();
  inline void set_has_candidates();
  inline void clear_has_candidates();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_preedit_method();
  inline void clear_has_preedit_method();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_all_candidate_words();
  inline void clear_has_all_candidate_words();
  inline void set_has_deletion_range();
  inline void clear_has_deletion_range();
  inline void set_has_launch_tool_mode();
  inline void clear_has_launch_tool_mode();
  inline void set_has_callback();
  inline void clear_has_callback();
  inline void set_has_storage_entry();
  inline void clear_has_storage_entry();
  inline void set_has_user_dictionary_command_status();
  inline void clear_has_user_dictionary_command_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int mode_;
  bool consumed_;
  ::mozc::commands::Result* result_;
  ::mozc::commands::Preedit* preedit_;
  ::mozc::commands::Candidates* candidates_;
  ::mozc::commands::KeyEvent* key_;
  ::std::string* url_;
  ::mozc::config::Config* config_;
  int preedit_method_;
  int error_code_;
  ::mozc::commands::Status* status_;
  ::mozc::commands::CandidateList* all_candidate_words_;
  ::mozc::commands::DeletionRange* deletion_range_;
  ::mozc::commands::Output_Callback* callback_;
  ::mozc::commands::GenericStorageEntry* storage_entry_;
  ::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status_;
  int launch_tool_mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Output* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mozc.commands.Input input = 1;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 1;
  inline const ::mozc::commands::Input& input() const;
  inline ::mozc::commands::Input* mutable_input();
  inline ::mozc::commands::Input* release_input();
  inline void set_allocated_input(::mozc::commands::Input* input);

  // required .mozc.commands.Output output = 2;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 2;
  inline const ::mozc::commands::Output& output() const;
  inline ::mozc::commands::Output* mutable_output();
  inline ::mozc::commands::Output* release_output();
  inline void set_allocated_output(::mozc::commands::Output* output);

  // @@protoc_insertion_point(class_scope:mozc.commands.Command)
 private:
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mozc::commands::Input* input_;
  ::mozc::commands::Output* output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class CommandList : public ::google::protobuf::Message {
 public:
  CommandList();
  virtual ~CommandList();

  CommandList(const CommandList& from);

  inline CommandList& operator=(const CommandList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandList& default_instance();

  void Swap(CommandList* other);

  // implements Message ----------------------------------------------

  CommandList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandList& from);
  void MergeFrom(const CommandList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozc.commands.Command commands = 1;
  inline int commands_size() const;
  inline void clear_commands();
  static const int kCommandsFieldNumber = 1;
  inline const ::mozc::commands::Command& commands(int index) const;
  inline ::mozc::commands::Command* mutable_commands(int index);
  inline ::mozc::commands::Command* add_commands();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >&
      commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >*
      mutable_commands();

  // @@protoc_insertion_point(class_scope:mozc.commands.CommandList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command > commands_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcommands_2eproto();
  friend void protobuf_AssignDesc_session_2fcommands_2eproto();
  friend void protobuf_ShutdownFile_session_2fcommands_2eproto();

  void InitAsDefaultInstance();
  static CommandList* default_instance_;
};
// ===================================================================


// ===================================================================

// KeyEvent_ProbableKeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent_ProbableKeyEvent::has_key_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_key_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_key_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent_ProbableKeyEvent::clear_key_code() {
  key_code_ = 0u;
  clear_has_key_code();
}
inline ::google::protobuf::uint32 KeyEvent_ProbableKeyEvent::key_code() const {
  return key_code_;
}
inline void KeyEvent_ProbableKeyEvent::set_key_code(::google::protobuf::uint32 value) {
  set_has_key_code();
  key_code_ = value;
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent_ProbableKeyEvent::has_special_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_special_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_special_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent_ProbableKeyEvent::clear_special_key() {
  special_key_ = 0;
  clear_has_special_key();
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent_ProbableKeyEvent::special_key() const {
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline void KeyEvent_ProbableKeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  set_has_special_key();
  special_key_ = value;
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent_ProbableKeyEvent::modifier_keys_size() const {
  return modifier_keys_.size();
}
inline void KeyEvent_ProbableKeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent_ProbableKeyEvent::modifier_keys(int index) const {
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline void KeyEvent_ProbableKeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
}
inline void KeyEvent_ProbableKeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
KeyEvent_ProbableKeyEvent::modifier_keys() const {
  return modifier_keys_;
}
inline ::google::protobuf::RepeatedField<int>*
KeyEvent_ProbableKeyEvent::mutable_modifier_keys() {
  return &modifier_keys_;
}

// optional double probability = 10;
inline bool KeyEvent_ProbableKeyEvent::has_probability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyEvent_ProbableKeyEvent::set_has_probability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyEvent_ProbableKeyEvent::clear_has_probability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyEvent_ProbableKeyEvent::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double KeyEvent_ProbableKeyEvent::probability() const {
  return probability_;
}
inline void KeyEvent_ProbableKeyEvent::set_probability(double value) {
  set_has_probability();
  probability_ = value;
}

// -------------------------------------------------------------------

// KeyEvent

// optional uint32 key_code = 1;
inline bool KeyEvent::has_key_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyEvent::set_has_key_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyEvent::clear_has_key_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyEvent::clear_key_code() {
  key_code_ = 0u;
  clear_has_key_code();
}
inline ::google::protobuf::uint32 KeyEvent::key_code() const {
  return key_code_;
}
inline void KeyEvent::set_key_code(::google::protobuf::uint32 value) {
  set_has_key_code();
  key_code_ = value;
}

// optional uint32 modifiers = 2;
inline bool KeyEvent::has_modifiers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyEvent::set_has_modifiers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyEvent::clear_has_modifiers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyEvent::clear_modifiers() {
  modifiers_ = 0u;
  clear_has_modifiers();
}
inline ::google::protobuf::uint32 KeyEvent::modifiers() const {
  return modifiers_;
}
inline void KeyEvent::set_modifiers(::google::protobuf::uint32 value) {
  set_has_modifiers();
  modifiers_ = value;
}

// optional .mozc.commands.KeyEvent.SpecialKey special_key = 3;
inline bool KeyEvent::has_special_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyEvent::set_has_special_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyEvent::clear_has_special_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyEvent::clear_special_key() {
  special_key_ = 0;
  clear_has_special_key();
}
inline ::mozc::commands::KeyEvent_SpecialKey KeyEvent::special_key() const {
  return static_cast< ::mozc::commands::KeyEvent_SpecialKey >(special_key_);
}
inline void KeyEvent::set_special_key(::mozc::commands::KeyEvent_SpecialKey value) {
  assert(::mozc::commands::KeyEvent_SpecialKey_IsValid(value));
  set_has_special_key();
  special_key_ = value;
}

// repeated .mozc.commands.KeyEvent.ModifierKey modifier_keys = 4;
inline int KeyEvent::modifier_keys_size() const {
  return modifier_keys_.size();
}
inline void KeyEvent::clear_modifier_keys() {
  modifier_keys_.Clear();
}
inline ::mozc::commands::KeyEvent_ModifierKey KeyEvent::modifier_keys(int index) const {
  return static_cast< ::mozc::commands::KeyEvent_ModifierKey >(modifier_keys_.Get(index));
}
inline void KeyEvent::set_modifier_keys(int index, ::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Set(index, value);
}
inline void KeyEvent::add_modifier_keys(::mozc::commands::KeyEvent_ModifierKey value) {
  assert(::mozc::commands::KeyEvent_ModifierKey_IsValid(value));
  modifier_keys_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
KeyEvent::modifier_keys() const {
  return modifier_keys_;
}
inline ::google::protobuf::RepeatedField<int>*
KeyEvent::mutable_modifier_keys() {
  return &modifier_keys_;
}

// optional string key_string = 5;
inline bool KeyEvent::has_key_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KeyEvent::set_has_key_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void KeyEvent::clear_has_key_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void KeyEvent::clear_key_string() {
  if (key_string_ != &::google::protobuf::internal::kEmptyString) {
    key_string_->clear();
  }
  clear_has_key_string();
}
inline const ::std::string& KeyEvent::key_string() const {
  return *key_string_;
}
inline void KeyEvent::set_key_string(const ::std::string& value) {
  set_has_key_string();
  if (key_string_ == &::google::protobuf::internal::kEmptyString) {
    key_string_ = new ::std::string;
  }
  key_string_->assign(value);
}
inline void KeyEvent::set_key_string(const char* value) {
  set_has_key_string();
  if (key_string_ == &::google::protobuf::internal::kEmptyString) {
    key_string_ = new ::std::string;
  }
  key_string_->assign(value);
}
inline void KeyEvent::set_key_string(const char* value, size_t size) {
  set_has_key_string();
  if (key_string_ == &::google::protobuf::internal::kEmptyString) {
    key_string_ = new ::std::string;
  }
  key_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyEvent::mutable_key_string() {
  set_has_key_string();
  if (key_string_ == &::google::protobuf::internal::kEmptyString) {
    key_string_ = new ::std::string;
  }
  return key_string_;
}
inline ::std::string* KeyEvent::release_key_string() {
  clear_has_key_string();
  if (key_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_string_;
    key_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyEvent::set_allocated_key_string(::std::string* key_string) {
  if (key_string_ != &::google::protobuf::internal::kEmptyString) {
    delete key_string_;
  }
  if (key_string) {
    set_has_key_string();
    key_string_ = key_string;
  } else {
    clear_has_key_string();
    key_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mozc.commands.KeyEvent.InputStyle input_style = 6 [default = FOLLOW_MODE];
inline bool KeyEvent::has_input_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void KeyEvent::set_has_input_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void KeyEvent::clear_has_input_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void KeyEvent::clear_input_style() {
  input_style_ = 0;
  clear_has_input_style();
}
inline ::mozc::commands::KeyEvent_InputStyle KeyEvent::input_style() const {
  return static_cast< ::mozc::commands::KeyEvent_InputStyle >(input_style_);
}
inline void KeyEvent::set_input_style(::mozc::commands::KeyEvent_InputStyle value) {
  assert(::mozc::commands::KeyEvent_InputStyle_IsValid(value));
  set_has_input_style();
  input_style_ = value;
}

// optional .mozc.commands.CompositionMode mode = 7;
inline bool KeyEvent::has_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void KeyEvent::set_has_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void KeyEvent::clear_has_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void KeyEvent::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode KeyEvent::mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void KeyEvent::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .mozc.commands.KeyEvent.ProbableKeyEvent probable_key_event = 8;
inline int KeyEvent::probable_key_event_size() const {
  return probable_key_event_.size();
}
inline void KeyEvent::clear_probable_key_event() {
  probable_key_event_.Clear();
}
inline const ::mozc::commands::KeyEvent_ProbableKeyEvent& KeyEvent::probable_key_event(int index) const {
  return probable_key_event_.Get(index);
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::mutable_probable_key_event(int index) {
  return probable_key_event_.Mutable(index);
}
inline ::mozc::commands::KeyEvent_ProbableKeyEvent* KeyEvent::add_probable_key_event() {
  return probable_key_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >&
KeyEvent::probable_key_event() const {
  return probable_key_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::KeyEvent_ProbableKeyEvent >*
KeyEvent::mutable_probable_key_event() {
  return &probable_key_event_;
}

// optional bool activated = 9;
inline bool KeyEvent::has_activated() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void KeyEvent::set_has_activated() {
  _has_bits_[0] |= 0x00000100u;
}
inline void KeyEvent::clear_has_activated() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void KeyEvent::clear_activated() {
  activated_ = false;
  clear_has_activated();
}
inline bool KeyEvent::activated() const {
  return activated_;
}
inline void KeyEvent::set_activated(bool value) {
  set_has_activated();
  activated_ = value;
}

// -------------------------------------------------------------------

// GenericStorageEntry

// optional .mozc.commands.GenericStorageEntry.StorageType type = 1;
inline bool GenericStorageEntry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericStorageEntry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericStorageEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericStorageEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::GenericStorageEntry_StorageType GenericStorageEntry::type() const {
  return static_cast< ::mozc::commands::GenericStorageEntry_StorageType >(type_);
}
inline void GenericStorageEntry::set_type(::mozc::commands::GenericStorageEntry_StorageType value) {
  assert(::mozc::commands::GenericStorageEntry_StorageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string key = 2;
inline bool GenericStorageEntry::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenericStorageEntry::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenericStorageEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenericStorageEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& GenericStorageEntry::key() const {
  return *key_;
}
inline void GenericStorageEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GenericStorageEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GenericStorageEntry::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericStorageEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* GenericStorageEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GenericStorageEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes value = 3;
inline int GenericStorageEntry::value_size() const {
  return value_.size();
}
inline void GenericStorageEntry::clear_value() {
  value_.Clear();
}
inline const ::std::string& GenericStorageEntry::value(int index) const {
  return value_.Get(index);
}
inline ::std::string* GenericStorageEntry::mutable_value(int index) {
  return value_.Mutable(index);
}
inline void GenericStorageEntry::set_value(int index, const ::std::string& value) {
  value_.Mutable(index)->assign(value);
}
inline void GenericStorageEntry::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
}
inline void GenericStorageEntry::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericStorageEntry::add_value() {
  return value_.Add();
}
inline void GenericStorageEntry::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
}
inline void GenericStorageEntry::add_value(const char* value) {
  value_.Add()->assign(value);
}
inline void GenericStorageEntry::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GenericStorageEntry::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GenericStorageEntry::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// SessionCommand

// required .mozc.commands.SessionCommand.CommandType type = 1;
inline bool SessionCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionCommand::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mozc::commands::SessionCommand_CommandType SessionCommand::type() const {
  return static_cast< ::mozc::commands::SessionCommand_CommandType >(type_);
}
inline void SessionCommand::set_type(::mozc::commands::SessionCommand_CommandType value) {
  assert(::mozc::commands::SessionCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool SessionCommand::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionCommand::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SessionCommand::id() const {
  return id_;
}
inline void SessionCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .mozc.commands.CompositionMode composition_mode = 3;
inline bool SessionCommand::has_composition_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionCommand::set_has_composition_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionCommand::clear_has_composition_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionCommand::clear_composition_mode() {
  composition_mode_ = 0;
  clear_has_composition_mode();
}
inline ::mozc::commands::CompositionMode SessionCommand::composition_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(composition_mode_);
}
inline void SessionCommand::set_composition_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_composition_mode();
  composition_mode_ = value;
}

// optional string text = 4;
inline bool SessionCommand::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionCommand::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionCommand::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionCommand::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SessionCommand::text() const {
  return *text_;
}
inline void SessionCommand::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SessionCommand::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SessionCommand::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionCommand::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SessionCommand::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionCommand::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cursor_position = 5;
inline bool SessionCommand::has_cursor_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionCommand::set_has_cursor_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionCommand::clear_has_cursor_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionCommand::clear_cursor_position() {
  cursor_position_ = 0u;
  clear_has_cursor_position();
}
inline ::google::protobuf::uint32 SessionCommand::cursor_position() const {
  return cursor_position_;
}
inline void SessionCommand::set_cursor_position(::google::protobuf::uint32 value) {
  set_has_cursor_position();
  cursor_position_ = value;
}

// optional .mozc.commands.SessionCommand.UsageStatsEvent usage_stats_event = 7;
inline bool SessionCommand::has_usage_stats_event() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionCommand::set_has_usage_stats_event() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionCommand::clear_has_usage_stats_event() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionCommand::clear_usage_stats_event() {
  usage_stats_event_ = 1;
  clear_has_usage_stats_event();
}
inline ::mozc::commands::SessionCommand_UsageStatsEvent SessionCommand::usage_stats_event() const {
  return static_cast< ::mozc::commands::SessionCommand_UsageStatsEvent >(usage_stats_event_);
}
inline void SessionCommand::set_usage_stats_event(::mozc::commands::SessionCommand_UsageStatsEvent value) {
  assert(::mozc::commands::SessionCommand_UsageStatsEvent_IsValid(value));
  set_has_usage_stats_event();
  usage_stats_event_ = value;
}

// optional int32 usage_stats_event_int_value = 9;
inline bool SessionCommand::has_usage_stats_event_int_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SessionCommand::set_has_usage_stats_event_int_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SessionCommand::clear_has_usage_stats_event_int_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SessionCommand::clear_usage_stats_event_int_value() {
  usage_stats_event_int_value_ = 0;
  clear_has_usage_stats_event_int_value();
}
inline ::google::protobuf::int32 SessionCommand::usage_stats_event_int_value() const {
  return usage_stats_event_int_value_;
}
inline void SessionCommand::set_usage_stats_event_int_value(::google::protobuf::int32 value) {
  set_has_usage_stats_event_int_value();
  usage_stats_event_int_value_ = value;
}

// optional .mozc.commands.Rectangle caret_rectangle = 8;
inline bool SessionCommand::has_caret_rectangle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SessionCommand::set_has_caret_rectangle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SessionCommand::clear_has_caret_rectangle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SessionCommand::clear_caret_rectangle() {
  if (caret_rectangle_ != NULL) caret_rectangle_->::mozc::commands::Rectangle::Clear();
  clear_has_caret_rectangle();
}
inline const ::mozc::commands::Rectangle& SessionCommand::caret_rectangle() const {
  return caret_rectangle_ != NULL ? *caret_rectangle_ : *default_instance_->caret_rectangle_;
}
inline ::mozc::commands::Rectangle* SessionCommand::mutable_caret_rectangle() {
  set_has_caret_rectangle();
  if (caret_rectangle_ == NULL) caret_rectangle_ = new ::mozc::commands::Rectangle;
  return caret_rectangle_;
}
inline ::mozc::commands::Rectangle* SessionCommand::release_caret_rectangle() {
  clear_has_caret_rectangle();
  ::mozc::commands::Rectangle* temp = caret_rectangle_;
  caret_rectangle_ = NULL;
  return temp;
}
inline void SessionCommand::set_allocated_caret_rectangle(::mozc::commands::Rectangle* caret_rectangle) {
  delete caret_rectangle_;
  caret_rectangle_ = caret_rectangle;
  if (caret_rectangle) {
    set_has_caret_rectangle();
  } else {
    clear_has_caret_rectangle();
  }
}

// optional int32 asynchronous_request_id = 10;
inline bool SessionCommand::has_asynchronous_request_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SessionCommand::set_has_asynchronous_request_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SessionCommand::clear_has_asynchronous_request_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SessionCommand::clear_asynchronous_request_id() {
  asynchronous_request_id_ = 0;
  clear_has_asynchronous_request_id();
}
inline ::google::protobuf::int32 SessionCommand::asynchronous_request_id() const {
  return asynchronous_request_id_;
}
inline void SessionCommand::set_asynchronous_request_id(::google::protobuf::int32 value) {
  set_has_asynchronous_request_id();
  asynchronous_request_id_ = value;
}

// -------------------------------------------------------------------

// Context

// optional string preceding_text = 1;
inline bool Context::has_preceding_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Context::set_has_preceding_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Context::clear_has_preceding_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Context::clear_preceding_text() {
  if (preceding_text_ != &::google::protobuf::internal::kEmptyString) {
    preceding_text_->clear();
  }
  clear_has_preceding_text();
}
inline const ::std::string& Context::preceding_text() const {
  return *preceding_text_;
}
inline void Context::set_preceding_text(const ::std::string& value) {
  set_has_preceding_text();
  if (preceding_text_ == &::google::protobuf::internal::kEmptyString) {
    preceding_text_ = new ::std::string;
  }
  preceding_text_->assign(value);
}
inline void Context::set_preceding_text(const char* value) {
  set_has_preceding_text();
  if (preceding_text_ == &::google::protobuf::internal::kEmptyString) {
    preceding_text_ = new ::std::string;
  }
  preceding_text_->assign(value);
}
inline void Context::set_preceding_text(const char* value, size_t size) {
  set_has_preceding_text();
  if (preceding_text_ == &::google::protobuf::internal::kEmptyString) {
    preceding_text_ = new ::std::string;
  }
  preceding_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Context::mutable_preceding_text() {
  set_has_preceding_text();
  if (preceding_text_ == &::google::protobuf::internal::kEmptyString) {
    preceding_text_ = new ::std::string;
  }
  return preceding_text_;
}
inline ::std::string* Context::release_preceding_text() {
  clear_has_preceding_text();
  if (preceding_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = preceding_text_;
    preceding_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Context::set_allocated_preceding_text(::std::string* preceding_text) {
  if (preceding_text_ != &::google::protobuf::internal::kEmptyString) {
    delete preceding_text_;
  }
  if (preceding_text) {
    set_has_preceding_text();
    preceding_text_ = preceding_text;
  } else {
    clear_has_preceding_text();
    preceding_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string following_text = 2;
inline bool Context::has_following_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Context::set_has_following_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Context::clear_has_following_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Context::clear_following_text() {
  if (following_text_ != &::google::protobuf::internal::kEmptyString) {
    following_text_->clear();
  }
  clear_has_following_text();
}
inline const ::std::string& Context::following_text() const {
  return *following_text_;
}
inline void Context::set_following_text(const ::std::string& value) {
  set_has_following_text();
  if (following_text_ == &::google::protobuf::internal::kEmptyString) {
    following_text_ = new ::std::string;
  }
  following_text_->assign(value);
}
inline void Context::set_following_text(const char* value) {
  set_has_following_text();
  if (following_text_ == &::google::protobuf::internal::kEmptyString) {
    following_text_ = new ::std::string;
  }
  following_text_->assign(value);
}
inline void Context::set_following_text(const char* value, size_t size) {
  set_has_following_text();
  if (following_text_ == &::google::protobuf::internal::kEmptyString) {
    following_text_ = new ::std::string;
  }
  following_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Context::mutable_following_text() {
  set_has_following_text();
  if (following_text_ == &::google::protobuf::internal::kEmptyString) {
    following_text_ = new ::std::string;
  }
  return following_text_;
}
inline ::std::string* Context::release_following_text() {
  clear_has_following_text();
  if (following_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = following_text_;
    following_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Context::set_allocated_following_text(::std::string* following_text) {
  if (following_text_ != &::google::protobuf::internal::kEmptyString) {
    delete following_text_;
  }
  if (following_text) {
    set_has_following_text();
    following_text_ = following_text;
  } else {
    clear_has_following_text();
    following_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool suppress_suggestion = 3 [default = false];
inline bool Context::has_suppress_suggestion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Context::set_has_suppress_suggestion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Context::clear_has_suppress_suggestion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Context::clear_suppress_suggestion() {
  suppress_suggestion_ = false;
  clear_has_suppress_suggestion();
}
inline bool Context::suppress_suggestion() const {
  return suppress_suggestion_;
}
inline void Context::set_suppress_suggestion(bool value) {
  set_has_suppress_suggestion();
  suppress_suggestion_ = value;
}

// optional .mozc.commands.Context.InputFieldType input_field_type = 4;
inline bool Context::has_input_field_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Context::set_has_input_field_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Context::clear_has_input_field_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Context::clear_input_field_type() {
  input_field_type_ = 1;
  clear_has_input_field_type();
}
inline ::mozc::commands::Context_InputFieldType Context::input_field_type() const {
  return static_cast< ::mozc::commands::Context_InputFieldType >(input_field_type_);
}
inline void Context::set_input_field_type(::mozc::commands::Context_InputFieldType value) {
  assert(::mozc::commands::Context_InputFieldType_IsValid(value));
  set_has_input_field_type();
  input_field_type_ = value;
}

// optional int32 revision = 5 [default = 0];
inline bool Context::has_revision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Context::set_has_revision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Context::clear_has_revision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Context::clear_revision() {
  revision_ = 0;
  clear_has_revision();
}
inline ::google::protobuf::int32 Context::revision() const {
  return revision_;
}
inline void Context::set_revision(::google::protobuf::int32 value) {
  set_has_revision();
  revision_ = value;
}

// repeated string experimental_features = 100;
inline int Context::experimental_features_size() const {
  return experimental_features_.size();
}
inline void Context::clear_experimental_features() {
  experimental_features_.Clear();
}
inline const ::std::string& Context::experimental_features(int index) const {
  return experimental_features_.Get(index);
}
inline ::std::string* Context::mutable_experimental_features(int index) {
  return experimental_features_.Mutable(index);
}
inline void Context::set_experimental_features(int index, const ::std::string& value) {
  experimental_features_.Mutable(index)->assign(value);
}
inline void Context::set_experimental_features(int index, const char* value) {
  experimental_features_.Mutable(index)->assign(value);
}
inline void Context::set_experimental_features(int index, const char* value, size_t size) {
  experimental_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Context::add_experimental_features() {
  return experimental_features_.Add();
}
inline void Context::add_experimental_features(const ::std::string& value) {
  experimental_features_.Add()->assign(value);
}
inline void Context::add_experimental_features(const char* value) {
  experimental_features_.Add()->assign(value);
}
inline void Context::add_experimental_features(const char* value, size_t size) {
  experimental_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Context::experimental_features() const {
  return experimental_features_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Context::mutable_experimental_features() {
  return &experimental_features_;
}

// -------------------------------------------------------------------

// Capability

// optional .mozc.commands.Capability.TextDeletionCapabilityType text_deletion = 1 [default = NO_TEXT_DELETION_CAPABILITY];
inline bool Capability::has_text_deletion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Capability::set_has_text_deletion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Capability::clear_has_text_deletion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Capability::clear_text_deletion() {
  text_deletion_ = 0;
  clear_has_text_deletion();
}
inline ::mozc::commands::Capability_TextDeletionCapabilityType Capability::text_deletion() const {
  return static_cast< ::mozc::commands::Capability_TextDeletionCapabilityType >(text_deletion_);
}
inline void Capability::set_text_deletion(::mozc::commands::Capability_TextDeletionCapabilityType value) {
  assert(::mozc::commands::Capability_TextDeletionCapabilityType_IsValid(value));
  set_has_text_deletion();
  text_deletion_ = value;
}

// -------------------------------------------------------------------

// Request

// optional bool zero_query_suggestion = 1 [default = false];
inline bool Request::has_zero_query_suggestion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_zero_query_suggestion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_zero_query_suggestion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_zero_query_suggestion() {
  zero_query_suggestion_ = false;
  clear_has_zero_query_suggestion();
}
inline bool Request::zero_query_suggestion() const {
  return zero_query_suggestion_;
}
inline void Request::set_zero_query_suggestion(bool value) {
  set_has_zero_query_suggestion();
  zero_query_suggestion_ = value;
}

// optional bool mixed_conversion = 2 [default = false];
inline bool Request::has_mixed_conversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_mixed_conversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_mixed_conversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_mixed_conversion() {
  mixed_conversion_ = false;
  clear_has_mixed_conversion();
}
inline bool Request::mixed_conversion() const {
  return mixed_conversion_;
}
inline void Request::set_mixed_conversion(bool value) {
  set_has_mixed_conversion();
  mixed_conversion_ = value;
}

// optional bool combine_all_segments = 3 [default = false];
inline bool Request::has_combine_all_segments() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_combine_all_segments() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_combine_all_segments() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_combine_all_segments() {
  combine_all_segments_ = false;
  clear_has_combine_all_segments();
}
inline bool Request::combine_all_segments() const {
  return combine_all_segments_;
}
inline void Request::set_combine_all_segments(bool value) {
  set_has_combine_all_segments();
  combine_all_segments_ = value;
}

// optional .mozc.commands.Request.SpecialRomanjiTable special_romanji_table = 4 [default = DEFAULT_TABLE];
inline bool Request::has_special_romanji_table() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_special_romanji_table() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_special_romanji_table() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_special_romanji_table() {
  special_romanji_table_ = 0;
  clear_has_special_romanji_table();
}
inline ::mozc::commands::Request_SpecialRomanjiTable Request::special_romanji_table() const {
  return static_cast< ::mozc::commands::Request_SpecialRomanjiTable >(special_romanji_table_);
}
inline void Request::set_special_romanji_table(::mozc::commands::Request_SpecialRomanjiTable value) {
  assert(::mozc::commands::Request_SpecialRomanjiTable_IsValid(value));
  set_has_special_romanji_table();
  special_romanji_table_ = value;
}

// optional .mozc.commands.Request.SpaceOnAlphanumeric space_on_alphanumeric = 6 [default = SPACE_OR_CONVERT_KEEPING_COMPOSITION];
inline bool Request::has_space_on_alphanumeric() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_space_on_alphanumeric() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_space_on_alphanumeric() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_space_on_alphanumeric() {
  space_on_alphanumeric_ = 0;
  clear_has_space_on_alphanumeric();
}
inline ::mozc::commands::Request_SpaceOnAlphanumeric Request::space_on_alphanumeric() const {
  return static_cast< ::mozc::commands::Request_SpaceOnAlphanumeric >(space_on_alphanumeric_);
}
inline void Request::set_space_on_alphanumeric(::mozc::commands::Request_SpaceOnAlphanumeric value) {
  assert(::mozc::commands::Request_SpaceOnAlphanumeric_IsValid(value));
  set_has_space_on_alphanumeric();
  space_on_alphanumeric_ = value;
}

// optional string keyboard_name = 7;
inline bool Request::has_keyboard_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_keyboard_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_keyboard_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_keyboard_name() {
  if (keyboard_name_ != &::google::protobuf::internal::kEmptyString) {
    keyboard_name_->clear();
  }
  clear_has_keyboard_name();
}
inline const ::std::string& Request::keyboard_name() const {
  return *keyboard_name_;
}
inline void Request::set_keyboard_name(const ::std::string& value) {
  set_has_keyboard_name();
  if (keyboard_name_ == &::google::protobuf::internal::kEmptyString) {
    keyboard_name_ = new ::std::string;
  }
  keyboard_name_->assign(value);
}
inline void Request::set_keyboard_name(const char* value) {
  set_has_keyboard_name();
  if (keyboard_name_ == &::google::protobuf::internal::kEmptyString) {
    keyboard_name_ = new ::std::string;
  }
  keyboard_name_->assign(value);
}
inline void Request::set_keyboard_name(const char* value, size_t size) {
  set_has_keyboard_name();
  if (keyboard_name_ == &::google::protobuf::internal::kEmptyString) {
    keyboard_name_ = new ::std::string;
  }
  keyboard_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_keyboard_name() {
  set_has_keyboard_name();
  if (keyboard_name_ == &::google::protobuf::internal::kEmptyString) {
    keyboard_name_ = new ::std::string;
  }
  return keyboard_name_;
}
inline ::std::string* Request::release_keyboard_name() {
  clear_has_keyboard_name();
  if (keyboard_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyboard_name_;
    keyboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Request::set_allocated_keyboard_name(::std::string* keyboard_name) {
  if (keyboard_name_ != &::google::protobuf::internal::kEmptyString) {
    delete keyboard_name_;
  }
  if (keyboard_name) {
    set_has_keyboard_name();
    keyboard_name_ = keyboard_name;
  } else {
    clear_has_keyboard_name();
    keyboard_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool update_input_mode_from_surrounding_text = 8 [default = true];
inline bool Request::has_update_input_mode_from_surrounding_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_update_input_mode_from_surrounding_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_update_input_mode_from_surrounding_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_update_input_mode_from_surrounding_text() {
  update_input_mode_from_surrounding_text_ = true;
  clear_has_update_input_mode_from_surrounding_text();
}
inline bool Request::update_input_mode_from_surrounding_text() const {
  return update_input_mode_from_surrounding_text_;
}
inline void Request::set_update_input_mode_from_surrounding_text(bool value) {
  set_has_update_input_mode_from_surrounding_text();
  update_input_mode_from_surrounding_text_ = value;
}

// optional bool kana_modifier_insensitive_conversion = 9 [default = false];
inline bool Request::has_kana_modifier_insensitive_conversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_kana_modifier_insensitive_conversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_kana_modifier_insensitive_conversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_kana_modifier_insensitive_conversion() {
  kana_modifier_insensitive_conversion_ = false;
  clear_has_kana_modifier_insensitive_conversion();
}
inline bool Request::kana_modifier_insensitive_conversion() const {
  return kana_modifier_insensitive_conversion_;
}
inline void Request::set_kana_modifier_insensitive_conversion(bool value) {
  set_has_kana_modifier_insensitive_conversion();
  kana_modifier_insensitive_conversion_ = value;
}

// optional bool auto_partial_suggestion = 10 [default = false];
inline bool Request::has_auto_partial_suggestion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_auto_partial_suggestion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_auto_partial_suggestion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_auto_partial_suggestion() {
  auto_partial_suggestion_ = false;
  clear_has_auto_partial_suggestion();
}
inline bool Request::auto_partial_suggestion() const {
  return auto_partial_suggestion_;
}
inline void Request::set_auto_partial_suggestion(bool value) {
  set_has_auto_partial_suggestion();
  auto_partial_suggestion_ = value;
}

// optional int32 available_emoji_carrier = 11 [default = 1];
inline bool Request::has_available_emoji_carrier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_available_emoji_carrier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_available_emoji_carrier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_available_emoji_carrier() {
  available_emoji_carrier_ = 1;
  clear_has_available_emoji_carrier();
}
inline ::google::protobuf::int32 Request::available_emoji_carrier() const {
  return available_emoji_carrier_;
}
inline void Request::set_available_emoji_carrier(::google::protobuf::int32 value) {
  set_has_available_emoji_carrier();
  available_emoji_carrier_ = value;
}

// optional int32 emoji_rewriter_capability = 12 [default = 1];
inline bool Request::has_emoji_rewriter_capability() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_emoji_rewriter_capability() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_emoji_rewriter_capability() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_emoji_rewriter_capability() {
  emoji_rewriter_capability_ = 1;
  clear_has_emoji_rewriter_capability();
}
inline ::google::protobuf::int32 Request::emoji_rewriter_capability() const {
  return emoji_rewriter_capability_;
}
inline void Request::set_emoji_rewriter_capability(::google::protobuf::int32 value) {
  set_has_emoji_rewriter_capability();
  emoji_rewriter_capability_ = value;
}

// optional .mozc.commands.Request.CrossingEdgeBehavior crossing_edge_behavior = 13 [default = DO_NOTHING];
inline bool Request::has_crossing_edge_behavior() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_crossing_edge_behavior() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_crossing_edge_behavior() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_crossing_edge_behavior() {
  crossing_edge_behavior_ = 0;
  clear_has_crossing_edge_behavior();
}
inline ::mozc::commands::Request_CrossingEdgeBehavior Request::crossing_edge_behavior() const {
  return static_cast< ::mozc::commands::Request_CrossingEdgeBehavior >(crossing_edge_behavior_);
}
inline void Request::set_crossing_edge_behavior(::mozc::commands::Request_CrossingEdgeBehavior value) {
  assert(::mozc::commands::Request_CrossingEdgeBehavior_IsValid(value));
  set_has_crossing_edge_behavior();
  crossing_edge_behavior_ = value;
}

// optional .mozc.commands.Request.LanguageAwareInputBehavior language_aware_input = 14 [default = DEFAULT_LANGUAGE_AWARE_BEHAVIOR];
inline bool Request::has_language_aware_input() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_language_aware_input() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_language_aware_input() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_language_aware_input() {
  language_aware_input_ = 0;
  clear_has_language_aware_input();
}
inline ::mozc::commands::Request_LanguageAwareInputBehavior Request::language_aware_input() const {
  return static_cast< ::mozc::commands::Request_LanguageAwareInputBehavior >(language_aware_input_);
}
inline void Request::set_language_aware_input(::mozc::commands::Request_LanguageAwareInputBehavior value) {
  assert(::mozc::commands::Request_LanguageAwareInputBehavior_IsValid(value));
  set_has_language_aware_input();
  language_aware_input_ = value;
}

// -------------------------------------------------------------------

// ApplicationInfo

// optional uint32 process_id = 1;
inline bool ApplicationInfo::has_process_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationInfo::set_has_process_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplicationInfo::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplicationInfo::clear_process_id() {
  process_id_ = 0u;
  clear_has_process_id();
}
inline ::google::protobuf::uint32 ApplicationInfo::process_id() const {
  return process_id_;
}
inline void ApplicationInfo::set_process_id(::google::protobuf::uint32 value) {
  set_has_process_id();
  process_id_ = value;
}

// optional uint32 thread_id = 2;
inline bool ApplicationInfo::has_thread_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationInfo::set_has_thread_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplicationInfo::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplicationInfo::clear_thread_id() {
  thread_id_ = 0u;
  clear_has_thread_id();
}
inline ::google::protobuf::uint32 ApplicationInfo::thread_id() const {
  return thread_id_;
}
inline void ApplicationInfo::set_thread_id(::google::protobuf::uint32 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// optional int32 timezone_offset = 3;
inline bool ApplicationInfo::has_timezone_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplicationInfo::set_has_timezone_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplicationInfo::clear_has_timezone_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplicationInfo::clear_timezone_offset() {
  timezone_offset_ = 0;
  clear_has_timezone_offset();
}
inline ::google::protobuf::int32 ApplicationInfo::timezone_offset() const {
  return timezone_offset_;
}
inline void ApplicationInfo::set_timezone_offset(::google::protobuf::int32 value) {
  set_has_timezone_offset();
  timezone_offset_ = value;
}

// -------------------------------------------------------------------

// Input_TouchPosition

// optional .mozc.commands.Input.TouchAction action = 1;
inline bool Input_TouchPosition::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_TouchPosition::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_TouchPosition::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_TouchPosition::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::mozc::commands::Input_TouchAction Input_TouchPosition::action() const {
  return static_cast< ::mozc::commands::Input_TouchAction >(action_);
}
inline void Input_TouchPosition::set_action(::mozc::commands::Input_TouchAction value) {
  assert(::mozc::commands::Input_TouchAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional float x = 2;
inline bool Input_TouchPosition::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input_TouchPosition::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input_TouchPosition::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input_TouchPosition::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Input_TouchPosition::x() const {
  return x_;
}
inline void Input_TouchPosition::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 3;
inline bool Input_TouchPosition::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input_TouchPosition::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input_TouchPosition::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input_TouchPosition::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Input_TouchPosition::y() const {
  return y_;
}
inline void Input_TouchPosition::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional int64 timestamp = 4;
inline bool Input_TouchPosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input_TouchPosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input_TouchPosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input_TouchPosition::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Input_TouchPosition::timestamp() const {
  return timestamp_;
}
inline void Input_TouchPosition::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Input_TouchEvent

// optional uint32 source_id = 1;
inline bool Input_TouchEvent::has_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input_TouchEvent::set_has_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input_TouchEvent::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input_TouchEvent::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 Input_TouchEvent::source_id() const {
  return source_id_;
}
inline void Input_TouchEvent::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
}

// repeated .mozc.commands.Input.TouchPosition stroke = 2;
inline int Input_TouchEvent::stroke_size() const {
  return stroke_.size();
}
inline void Input_TouchEvent::clear_stroke() {
  stroke_.Clear();
}
inline const ::mozc::commands::Input_TouchPosition& Input_TouchEvent::stroke(int index) const {
  return stroke_.Get(index);
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::mutable_stroke(int index) {
  return stroke_.Mutable(index);
}
inline ::mozc::commands::Input_TouchPosition* Input_TouchEvent::add_stroke() {
  return stroke_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >&
Input_TouchEvent::stroke() const {
  return stroke_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchPosition >*
Input_TouchEvent::mutable_stroke() {
  return &stroke_;
}

// -------------------------------------------------------------------

// Input

// required .mozc.commands.Input.CommandType type = 1;
inline bool Input::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::Input_CommandType Input::type() const {
  return static_cast< ::mozc::commands::Input_CommandType >(type_);
}
inline void Input::set_type(::mozc::commands::Input_CommandType value) {
  assert(::mozc::commands::Input_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 id = 2;
inline bool Input::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Input::id() const {
  return id_;
}
inline void Input::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional .mozc.commands.KeyEvent key = 3;
inline bool Input::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_key() {
  if (key_ != NULL) key_->::mozc::commands::KeyEvent::Clear();
  clear_has_key();
}
inline const ::mozc::commands::KeyEvent& Input::key() const {
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::mozc::commands::KeyEvent* Input::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::mozc::commands::KeyEvent;
  return key_;
}
inline ::mozc::commands::KeyEvent* Input::release_key() {
  clear_has_key();
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Input::set_allocated_key(::mozc::commands::KeyEvent* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
}

// optional .mozc.commands.SessionCommand command = 4;
inline bool Input::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input::clear_command() {
  if (command_ != NULL) command_->::mozc::commands::SessionCommand::Clear();
  clear_has_command();
}
inline const ::mozc::commands::SessionCommand& Input::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::mozc::commands::SessionCommand* Input::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::mozc::commands::SessionCommand;
  return command_;
}
inline ::mozc::commands::SessionCommand* Input::release_command() {
  clear_has_command();
  ::mozc::commands::SessionCommand* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Input::set_allocated_command(::mozc::commands::SessionCommand* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .mozc.config.Config config = 5;
inline bool Input::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Input::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Input::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Input::clear_config() {
  if (config_ != NULL) config_->::mozc::config::Config::Clear();
  clear_has_config();
}
inline const ::mozc::config::Config& Input::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::mozc::config::Config* Input::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::mozc::config::Config;
  return config_;
}
inline ::mozc::config::Config* Input::release_config() {
  clear_has_config();
  ::mozc::config::Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Input::set_allocated_config(::mozc::config::Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// optional .mozc.commands.Context context = 6;
inline bool Input::has_context() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Input::set_has_context() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Input::clear_has_context() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Input::clear_context() {
  if (context_ != NULL) context_->::mozc::commands::Context::Clear();
  clear_has_context();
}
inline const ::mozc::commands::Context& Input::context() const {
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::mozc::commands::Context* Input::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::mozc::commands::Context;
  return context_;
}
inline ::mozc::commands::Context* Input::release_context() {
  clear_has_context();
  ::mozc::commands::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void Input::set_allocated_context(::mozc::commands::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
}

// optional .mozc.commands.Capability capability = 7;
inline bool Input::has_capability() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Input::set_has_capability() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Input::clear_has_capability() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Input::clear_capability() {
  if (capability_ != NULL) capability_->::mozc::commands::Capability::Clear();
  clear_has_capability();
}
inline const ::mozc::commands::Capability& Input::capability() const {
  return capability_ != NULL ? *capability_ : *default_instance_->capability_;
}
inline ::mozc::commands::Capability* Input::mutable_capability() {
  set_has_capability();
  if (capability_ == NULL) capability_ = new ::mozc::commands::Capability;
  return capability_;
}
inline ::mozc::commands::Capability* Input::release_capability() {
  clear_has_capability();
  ::mozc::commands::Capability* temp = capability_;
  capability_ = NULL;
  return temp;
}
inline void Input::set_allocated_capability(::mozc::commands::Capability* capability) {
  delete capability_;
  capability_ = capability;
  if (capability) {
    set_has_capability();
  } else {
    clear_has_capability();
  }
}

// optional .mozc.commands.ApplicationInfo application_info = 8;
inline bool Input::has_application_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Input::set_has_application_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Input::clear_has_application_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Input::clear_application_info() {
  if (application_info_ != NULL) application_info_->::mozc::commands::ApplicationInfo::Clear();
  clear_has_application_info();
}
inline const ::mozc::commands::ApplicationInfo& Input::application_info() const {
  return application_info_ != NULL ? *application_info_ : *default_instance_->application_info_;
}
inline ::mozc::commands::ApplicationInfo* Input::mutable_application_info() {
  set_has_application_info();
  if (application_info_ == NULL) application_info_ = new ::mozc::commands::ApplicationInfo;
  return application_info_;
}
inline ::mozc::commands::ApplicationInfo* Input::release_application_info() {
  clear_has_application_info();
  ::mozc::commands::ApplicationInfo* temp = application_info_;
  application_info_ = NULL;
  return temp;
}
inline void Input::set_allocated_application_info(::mozc::commands::ApplicationInfo* application_info) {
  delete application_info_;
  application_info_ = application_info;
  if (application_info) {
    set_has_application_info();
  } else {
    clear_has_application_info();
  }
}

// optional .mozc.commands.Request request = 9;
inline bool Input::has_request() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Input::set_has_request() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Input::clear_has_request() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Input::clear_request() {
  if (request_ != NULL) request_->::mozc::commands::Request::Clear();
  clear_has_request();
}
inline const ::mozc::commands::Request& Input::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::mozc::commands::Request* Input::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::mozc::commands::Request;
  return request_;
}
inline ::mozc::commands::Request* Input::release_request() {
  clear_has_request();
  ::mozc::commands::Request* temp = request_;
  request_ = NULL;
  return temp;
}
inline void Input::set_allocated_request(::mozc::commands::Request* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 10;
inline bool Input::has_storage_entry() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Input::set_has_storage_entry() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Input::clear_has_storage_entry() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Input::clear_storage_entry() {
  if (storage_entry_ != NULL) storage_entry_->::mozc::commands::GenericStorageEntry::Clear();
  clear_has_storage_entry();
}
inline const ::mozc::commands::GenericStorageEntry& Input::storage_entry() const {
  return storage_entry_ != NULL ? *storage_entry_ : *default_instance_->storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Input::mutable_storage_entry() {
  set_has_storage_entry();
  if (storage_entry_ == NULL) storage_entry_ = new ::mozc::commands::GenericStorageEntry;
  return storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Input::release_storage_entry() {
  clear_has_storage_entry();
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = NULL;
  return temp;
}
inline void Input::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  delete storage_entry_;
  storage_entry_ = storage_entry;
  if (storage_entry) {
    set_has_storage_entry();
  } else {
    clear_has_storage_entry();
  }
}

// repeated .mozc.commands.Input.TouchEvent touch_events = 12;
inline int Input::touch_events_size() const {
  return touch_events_.size();
}
inline void Input::clear_touch_events() {
  touch_events_.Clear();
}
inline const ::mozc::commands::Input_TouchEvent& Input::touch_events(int index) const {
  return touch_events_.Get(index);
}
inline ::mozc::commands::Input_TouchEvent* Input::mutable_touch_events(int index) {
  return touch_events_.Mutable(index);
}
inline ::mozc::commands::Input_TouchEvent* Input::add_touch_events() {
  return touch_events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >&
Input::touch_events() const {
  return touch_events_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Input_TouchEvent >*
Input::mutable_touch_events() {
  return &touch_events_;
}

// optional .mozc.user_dictionary.UserDictionaryCommand user_dictionary_command = 13;
inline bool Input::has_user_dictionary_command() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Input::set_has_user_dictionary_command() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Input::clear_has_user_dictionary_command() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Input::clear_user_dictionary_command() {
  if (user_dictionary_command_ != NULL) user_dictionary_command_->::mozc::user_dictionary::UserDictionaryCommand::Clear();
  clear_has_user_dictionary_command();
}
inline const ::mozc::user_dictionary::UserDictionaryCommand& Input::user_dictionary_command() const {
  return user_dictionary_command_ != NULL ? *user_dictionary_command_ : *default_instance_->user_dictionary_command_;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::mutable_user_dictionary_command() {
  set_has_user_dictionary_command();
  if (user_dictionary_command_ == NULL) user_dictionary_command_ = new ::mozc::user_dictionary::UserDictionaryCommand;
  return user_dictionary_command_;
}
inline ::mozc::user_dictionary::UserDictionaryCommand* Input::release_user_dictionary_command() {
  clear_has_user_dictionary_command();
  ::mozc::user_dictionary::UserDictionaryCommand* temp = user_dictionary_command_;
  user_dictionary_command_ = NULL;
  return temp;
}
inline void Input::set_allocated_user_dictionary_command(::mozc::user_dictionary::UserDictionaryCommand* user_dictionary_command) {
  delete user_dictionary_command_;
  user_dictionary_command_ = user_dictionary_command;
  if (user_dictionary_command) {
    set_has_user_dictionary_command();
  } else {
    clear_has_user_dictionary_command();
  }
}

// optional bool request_suggestion = 14 [default = true];
inline bool Input::has_request_suggestion() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Input::set_has_request_suggestion() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Input::clear_has_request_suggestion() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Input::clear_request_suggestion() {
  request_suggestion_ = true;
  clear_has_request_suggestion();
}
inline bool Input::request_suggestion() const {
  return request_suggestion_;
}
inline void Input::set_request_suggestion(bool value) {
  set_has_request_suggestion();
  request_suggestion_ = value;
}

// -------------------------------------------------------------------

// Result

// required .mozc.commands.Result.ResultType type = 1;
inline bool Result::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozc::commands::Result_ResultType Result::type() const {
  return static_cast< ::mozc::commands::Result_ResultType >(type_);
}
inline void Result::set_type(::mozc::commands::Result_ResultType value) {
  assert(::mozc::commands::Result_ResultType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string value = 2;
inline bool Result::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Result::value() const {
  return *value_;
}
inline void Result::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Result::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Result::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Result::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Result::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Result::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 3;
inline bool Result::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Result::key() const {
  return *key_;
}
inline void Result::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Result::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Result::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Result::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Result::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Result::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cursor_offset = 4 [default = 0];
inline bool Result::has_cursor_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_cursor_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_cursor_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_cursor_offset() {
  cursor_offset_ = 0;
  clear_has_cursor_offset();
}
inline ::google::protobuf::int32 Result::cursor_offset() const {
  return cursor_offset_;
}
inline void Result::set_cursor_offset(::google::protobuf::int32 value) {
  set_has_cursor_offset();
  cursor_offset_ = value;
}

// -------------------------------------------------------------------

// Preedit_Segment

// required .mozc.commands.Preedit.Segment.Annotation annotation = 3;
inline bool Preedit_Segment::has_annotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Preedit_Segment::set_has_annotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Preedit_Segment::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Preedit_Segment::clear_annotation() {
  annotation_ = 0;
  clear_has_annotation();
}
inline ::mozc::commands::Preedit_Segment_Annotation Preedit_Segment::annotation() const {
  return static_cast< ::mozc::commands::Preedit_Segment_Annotation >(annotation_);
}
inline void Preedit_Segment::set_annotation(::mozc::commands::Preedit_Segment_Annotation value) {
  assert(::mozc::commands::Preedit_Segment_Annotation_IsValid(value));
  set_has_annotation();
  annotation_ = value;
}

// required string value = 4;
inline bool Preedit_Segment::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Preedit_Segment::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Preedit_Segment::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Preedit_Segment::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Preedit_Segment::value() const {
  return *value_;
}
inline void Preedit_Segment::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Preedit_Segment::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Preedit_Segment::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Preedit_Segment::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Preedit_Segment::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Preedit_Segment::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 value_length = 5;
inline bool Preedit_Segment::has_value_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Preedit_Segment::set_has_value_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Preedit_Segment::clear_has_value_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Preedit_Segment::clear_value_length() {
  value_length_ = 0u;
  clear_has_value_length();
}
inline ::google::protobuf::uint32 Preedit_Segment::value_length() const {
  return value_length_;
}
inline void Preedit_Segment::set_value_length(::google::protobuf::uint32 value) {
  set_has_value_length();
  value_length_ = value;
}

// optional string key = 6;
inline bool Preedit_Segment::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Preedit_Segment::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Preedit_Segment::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Preedit_Segment::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Preedit_Segment::key() const {
  return *key_;
}
inline void Preedit_Segment::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Preedit_Segment::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Preedit_Segment::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Preedit_Segment::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Preedit_Segment::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Preedit_Segment::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Preedit

// required uint32 cursor = 1;
inline bool Preedit::has_cursor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Preedit::set_has_cursor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Preedit::clear_has_cursor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Preedit::clear_cursor() {
  cursor_ = 0u;
  clear_has_cursor();
}
inline ::google::protobuf::uint32 Preedit::cursor() const {
  return cursor_;
}
inline void Preedit::set_cursor(::google::protobuf::uint32 value) {
  set_has_cursor();
  cursor_ = value;
}

// repeated group Segment = 2 {
inline int Preedit::segment_size() const {
  return segment_.size();
}
inline void Preedit::clear_segment() {
  segment_.Clear();
}
inline const ::mozc::commands::Preedit_Segment& Preedit::segment(int index) const {
  return segment_.Get(index);
}
inline ::mozc::commands::Preedit_Segment* Preedit::mutable_segment(int index) {
  return segment_.Mutable(index);
}
inline ::mozc::commands::Preedit_Segment* Preedit::add_segment() {
  return segment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >&
Preedit::segment() const {
  return segment_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Preedit_Segment >*
Preedit::mutable_segment() {
  return &segment_;
}

// optional uint32 highlighted_position = 3;
inline bool Preedit::has_highlighted_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Preedit::set_has_highlighted_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Preedit::clear_has_highlighted_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Preedit::clear_highlighted_position() {
  highlighted_position_ = 0u;
  clear_has_highlighted_position();
}
inline ::google::protobuf::uint32 Preedit::highlighted_position() const {
  return highlighted_position_;
}
inline void Preedit::set_highlighted_position(::google::protobuf::uint32 value) {
  set_has_highlighted_position();
  highlighted_position_ = value;
}

// -------------------------------------------------------------------

// Status

// optional bool activated = 1;
inline bool Status::has_activated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_activated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_activated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_activated() {
  activated_ = false;
  clear_has_activated();
}
inline bool Status::activated() const {
  return activated_;
}
inline void Status::set_activated(bool value) {
  set_has_activated();
  activated_ = value;
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Status::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode Status::mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void Status::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional .mozc.commands.CompositionMode comeback_mode = 3;
inline bool Status::has_comeback_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_comeback_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_comeback_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_comeback_mode() {
  comeback_mode_ = 0;
  clear_has_comeback_mode();
}
inline ::mozc::commands::CompositionMode Status::comeback_mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(comeback_mode_);
}
inline void Status::set_comeback_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_comeback_mode();
  comeback_mode_ = value;
}

// -------------------------------------------------------------------

// DeletionRange

// optional int32 offset = 1;
inline bool DeletionRange::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeletionRange::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeletionRange::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeletionRange::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 DeletionRange::offset() const {
  return offset_;
}
inline void DeletionRange::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional int32 length = 2;
inline bool DeletionRange::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeletionRange::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeletionRange::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeletionRange::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 DeletionRange::length() const {
  return length_;
}
inline void DeletionRange::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// Output_Callback

// optional .mozc.commands.SessionCommand session_command = 1;
inline bool Output_Callback::has_session_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output_Callback::set_has_session_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output_Callback::clear_has_session_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output_Callback::clear_session_command() {
  if (session_command_ != NULL) session_command_->::mozc::commands::SessionCommand::Clear();
  clear_has_session_command();
}
inline const ::mozc::commands::SessionCommand& Output_Callback::session_command() const {
  return session_command_ != NULL ? *session_command_ : *default_instance_->session_command_;
}
inline ::mozc::commands::SessionCommand* Output_Callback::mutable_session_command() {
  set_has_session_command();
  if (session_command_ == NULL) session_command_ = new ::mozc::commands::SessionCommand;
  return session_command_;
}
inline ::mozc::commands::SessionCommand* Output_Callback::release_session_command() {
  clear_has_session_command();
  ::mozc::commands::SessionCommand* temp = session_command_;
  session_command_ = NULL;
  return temp;
}
inline void Output_Callback::set_allocated_session_command(::mozc::commands::SessionCommand* session_command) {
  delete session_command_;
  session_command_ = session_command;
  if (session_command) {
    set_has_session_command();
  } else {
    clear_has_session_command();
  }
}

// optional uint32 delay_millisec = 2;
inline bool Output_Callback::has_delay_millisec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output_Callback::set_has_delay_millisec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output_Callback::clear_has_delay_millisec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output_Callback::clear_delay_millisec() {
  delay_millisec_ = 0u;
  clear_has_delay_millisec();
}
inline ::google::protobuf::uint32 Output_Callback::delay_millisec() const {
  return delay_millisec_;
}
inline void Output_Callback::set_delay_millisec(::google::protobuf::uint32 value) {
  set_has_delay_millisec();
  delay_millisec_ = value;
}

// -------------------------------------------------------------------

// Output

// optional uint64 id = 1;
inline bool Output::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Output::id() const {
  return id_;
}
inline void Output::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional .mozc.commands.CompositionMode mode = 2;
inline bool Output::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::mozc::commands::CompositionMode Output::mode() const {
  return static_cast< ::mozc::commands::CompositionMode >(mode_);
}
inline void Output::set_mode(::mozc::commands::CompositionMode value) {
  assert(::mozc::commands::CompositionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional bool consumed = 3;
inline bool Output::has_consumed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Output::set_has_consumed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Output::clear_has_consumed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Output::clear_consumed() {
  consumed_ = false;
  clear_has_consumed();
}
inline bool Output::consumed() const {
  return consumed_;
}
inline void Output::set_consumed(bool value) {
  set_has_consumed();
  consumed_ = value;
}

// optional .mozc.commands.Result result = 4;
inline bool Output::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Output::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Output::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Output::clear_result() {
  if (result_ != NULL) result_->::mozc::commands::Result::Clear();
  clear_has_result();
}
inline const ::mozc::commands::Result& Output::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::mozc::commands::Result* Output::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::mozc::commands::Result;
  return result_;
}
inline ::mozc::commands::Result* Output::release_result() {
  clear_has_result();
  ::mozc::commands::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void Output::set_allocated_result(::mozc::commands::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .mozc.commands.Preedit preedit = 5;
inline bool Output::has_preedit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Output::set_has_preedit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Output::clear_has_preedit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Output::clear_preedit() {
  if (preedit_ != NULL) preedit_->::mozc::commands::Preedit::Clear();
  clear_has_preedit();
}
inline const ::mozc::commands::Preedit& Output::preedit() const {
  return preedit_ != NULL ? *preedit_ : *default_instance_->preedit_;
}
inline ::mozc::commands::Preedit* Output::mutable_preedit() {
  set_has_preedit();
  if (preedit_ == NULL) preedit_ = new ::mozc::commands::Preedit;
  return preedit_;
}
inline ::mozc::commands::Preedit* Output::release_preedit() {
  clear_has_preedit();
  ::mozc::commands::Preedit* temp = preedit_;
  preedit_ = NULL;
  return temp;
}
inline void Output::set_allocated_preedit(::mozc::commands::Preedit* preedit) {
  delete preedit_;
  preedit_ = preedit;
  if (preedit) {
    set_has_preedit();
  } else {
    clear_has_preedit();
  }
}

// optional .mozc.commands.Candidates candidates = 6;
inline bool Output::has_candidates() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Output::set_has_candidates() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Output::clear_has_candidates() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Output::clear_candidates() {
  if (candidates_ != NULL) candidates_->::mozc::commands::Candidates::Clear();
  clear_has_candidates();
}
inline const ::mozc::commands::Candidates& Output::candidates() const {
  return candidates_ != NULL ? *candidates_ : *default_instance_->candidates_;
}
inline ::mozc::commands::Candidates* Output::mutable_candidates() {
  set_has_candidates();
  if (candidates_ == NULL) candidates_ = new ::mozc::commands::Candidates;
  return candidates_;
}
inline ::mozc::commands::Candidates* Output::release_candidates() {
  clear_has_candidates();
  ::mozc::commands::Candidates* temp = candidates_;
  candidates_ = NULL;
  return temp;
}
inline void Output::set_allocated_candidates(::mozc::commands::Candidates* candidates) {
  delete candidates_;
  candidates_ = candidates;
  if (candidates) {
    set_has_candidates();
  } else {
    clear_has_candidates();
  }
}

// optional .mozc.commands.KeyEvent key = 7;
inline bool Output::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Output::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Output::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Output::clear_key() {
  if (key_ != NULL) key_->::mozc::commands::KeyEvent::Clear();
  clear_has_key();
}
inline const ::mozc::commands::KeyEvent& Output::key() const {
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::mozc::commands::KeyEvent* Output::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::mozc::commands::KeyEvent;
  return key_;
}
inline ::mozc::commands::KeyEvent* Output::release_key() {
  clear_has_key();
  ::mozc::commands::KeyEvent* temp = key_;
  key_ = NULL;
  return temp;
}
inline void Output::set_allocated_key(::mozc::commands::KeyEvent* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
}

// optional string url = 8;
inline bool Output::has_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Output::set_has_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Output::clear_has_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Output::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Output::url() const {
  return *url_;
}
inline void Output::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Output::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Output::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Output::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Output::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Output::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mozc.config.Config config = 9;
inline bool Output::has_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Output::set_has_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Output::clear_has_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Output::clear_config() {
  if (config_ != NULL) config_->::mozc::config::Config::Clear();
  clear_has_config();
}
inline const ::mozc::config::Config& Output::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::mozc::config::Config* Output::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::mozc::config::Config;
  return config_;
}
inline ::mozc::config::Config* Output::release_config() {
  clear_has_config();
  ::mozc::config::Config* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Output::set_allocated_config(::mozc::config::Config* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// optional .mozc.commands.Output.PreeditMethod preedit_method = 10 [default = ASCII];
inline bool Output::has_preedit_method() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Output::set_has_preedit_method() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Output::clear_has_preedit_method() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Output::clear_preedit_method() {
  preedit_method_ = 0;
  clear_has_preedit_method();
}
inline ::mozc::commands::Output_PreeditMethod Output::preedit_method() const {
  return static_cast< ::mozc::commands::Output_PreeditMethod >(preedit_method_);
}
inline void Output::set_preedit_method(::mozc::commands::Output_PreeditMethod value) {
  assert(::mozc::commands::Output_PreeditMethod_IsValid(value));
  set_has_preedit_method();
  preedit_method_ = value;
}

// optional .mozc.commands.Output.ErrorCode error_code = 11 [default = SESSION_SUCCESS];
inline bool Output::has_error_code() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Output::set_has_error_code() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Output::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Output::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::mozc::commands::Output_ErrorCode Output::error_code() const {
  return static_cast< ::mozc::commands::Output_ErrorCode >(error_code_);
}
inline void Output::set_error_code(::mozc::commands::Output_ErrorCode value) {
  assert(::mozc::commands::Output_ErrorCode_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional .mozc.commands.Status status = 13;
inline bool Output::has_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Output::set_has_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Output::clear_has_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Output::clear_status() {
  if (status_ != NULL) status_->::mozc::commands::Status::Clear();
  clear_has_status();
}
inline const ::mozc::commands::Status& Output::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::mozc::commands::Status* Output::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::mozc::commands::Status;
  return status_;
}
inline ::mozc::commands::Status* Output::release_status() {
  clear_has_status();
  ::mozc::commands::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Output::set_allocated_status(::mozc::commands::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .mozc.commands.CandidateList all_candidate_words = 14;
inline bool Output::has_all_candidate_words() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Output::set_has_all_candidate_words() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Output::clear_has_all_candidate_words() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Output::clear_all_candidate_words() {
  if (all_candidate_words_ != NULL) all_candidate_words_->::mozc::commands::CandidateList::Clear();
  clear_has_all_candidate_words();
}
inline const ::mozc::commands::CandidateList& Output::all_candidate_words() const {
  return all_candidate_words_ != NULL ? *all_candidate_words_ : *default_instance_->all_candidate_words_;
}
inline ::mozc::commands::CandidateList* Output::mutable_all_candidate_words() {
  set_has_all_candidate_words();
  if (all_candidate_words_ == NULL) all_candidate_words_ = new ::mozc::commands::CandidateList;
  return all_candidate_words_;
}
inline ::mozc::commands::CandidateList* Output::release_all_candidate_words() {
  clear_has_all_candidate_words();
  ::mozc::commands::CandidateList* temp = all_candidate_words_;
  all_candidate_words_ = NULL;
  return temp;
}
inline void Output::set_allocated_all_candidate_words(::mozc::commands::CandidateList* all_candidate_words) {
  delete all_candidate_words_;
  all_candidate_words_ = all_candidate_words;
  if (all_candidate_words) {
    set_has_all_candidate_words();
  } else {
    clear_has_all_candidate_words();
  }
}

// optional .mozc.commands.DeletionRange deletion_range = 16;
inline bool Output::has_deletion_range() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Output::set_has_deletion_range() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Output::clear_has_deletion_range() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Output::clear_deletion_range() {
  if (deletion_range_ != NULL) deletion_range_->::mozc::commands::DeletionRange::Clear();
  clear_has_deletion_range();
}
inline const ::mozc::commands::DeletionRange& Output::deletion_range() const {
  return deletion_range_ != NULL ? *deletion_range_ : *default_instance_->deletion_range_;
}
inline ::mozc::commands::DeletionRange* Output::mutable_deletion_range() {
  set_has_deletion_range();
  if (deletion_range_ == NULL) deletion_range_ = new ::mozc::commands::DeletionRange;
  return deletion_range_;
}
inline ::mozc::commands::DeletionRange* Output::release_deletion_range() {
  clear_has_deletion_range();
  ::mozc::commands::DeletionRange* temp = deletion_range_;
  deletion_range_ = NULL;
  return temp;
}
inline void Output::set_allocated_deletion_range(::mozc::commands::DeletionRange* deletion_range) {
  delete deletion_range_;
  deletion_range_ = deletion_range;
  if (deletion_range) {
    set_has_deletion_range();
  } else {
    clear_has_deletion_range();
  }
}

// optional .mozc.commands.Output.ToolMode launch_tool_mode = 17 [default = NO_TOOL];
inline bool Output::has_launch_tool_mode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Output::set_has_launch_tool_mode() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Output::clear_has_launch_tool_mode() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Output::clear_launch_tool_mode() {
  launch_tool_mode_ = 0;
  clear_has_launch_tool_mode();
}
inline ::mozc::commands::Output_ToolMode Output::launch_tool_mode() const {
  return static_cast< ::mozc::commands::Output_ToolMode >(launch_tool_mode_);
}
inline void Output::set_launch_tool_mode(::mozc::commands::Output_ToolMode value) {
  assert(::mozc::commands::Output_ToolMode_IsValid(value));
  set_has_launch_tool_mode();
  launch_tool_mode_ = value;
}

// optional .mozc.commands.Output.Callback callback = 18;
inline bool Output::has_callback() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Output::set_has_callback() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Output::clear_has_callback() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Output::clear_callback() {
  if (callback_ != NULL) callback_->::mozc::commands::Output_Callback::Clear();
  clear_has_callback();
}
inline const ::mozc::commands::Output_Callback& Output::callback() const {
  return callback_ != NULL ? *callback_ : *default_instance_->callback_;
}
inline ::mozc::commands::Output_Callback* Output::mutable_callback() {
  set_has_callback();
  if (callback_ == NULL) callback_ = new ::mozc::commands::Output_Callback;
  return callback_;
}
inline ::mozc::commands::Output_Callback* Output::release_callback() {
  clear_has_callback();
  ::mozc::commands::Output_Callback* temp = callback_;
  callback_ = NULL;
  return temp;
}
inline void Output::set_allocated_callback(::mozc::commands::Output_Callback* callback) {
  delete callback_;
  callback_ = callback;
  if (callback) {
    set_has_callback();
  } else {
    clear_has_callback();
  }
}

// optional .mozc.commands.GenericStorageEntry storage_entry = 19;
inline bool Output::has_storage_entry() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Output::set_has_storage_entry() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Output::clear_has_storage_entry() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Output::clear_storage_entry() {
  if (storage_entry_ != NULL) storage_entry_->::mozc::commands::GenericStorageEntry::Clear();
  clear_has_storage_entry();
}
inline const ::mozc::commands::GenericStorageEntry& Output::storage_entry() const {
  return storage_entry_ != NULL ? *storage_entry_ : *default_instance_->storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Output::mutable_storage_entry() {
  set_has_storage_entry();
  if (storage_entry_ == NULL) storage_entry_ = new ::mozc::commands::GenericStorageEntry;
  return storage_entry_;
}
inline ::mozc::commands::GenericStorageEntry* Output::release_storage_entry() {
  clear_has_storage_entry();
  ::mozc::commands::GenericStorageEntry* temp = storage_entry_;
  storage_entry_ = NULL;
  return temp;
}
inline void Output::set_allocated_storage_entry(::mozc::commands::GenericStorageEntry* storage_entry) {
  delete storage_entry_;
  storage_entry_ = storage_entry;
  if (storage_entry) {
    set_has_storage_entry();
  } else {
    clear_has_storage_entry();
  }
}

// optional .mozc.user_dictionary.UserDictionaryCommandStatus user_dictionary_command_status = 21;
inline bool Output::has_user_dictionary_command_status() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Output::set_has_user_dictionary_command_status() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Output::clear_has_user_dictionary_command_status() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Output::clear_user_dictionary_command_status() {
  if (user_dictionary_command_status_ != NULL) user_dictionary_command_status_->::mozc::user_dictionary::UserDictionaryCommandStatus::Clear();
  clear_has_user_dictionary_command_status();
}
inline const ::mozc::user_dictionary::UserDictionaryCommandStatus& Output::user_dictionary_command_status() const {
  return user_dictionary_command_status_ != NULL ? *user_dictionary_command_status_ : *default_instance_->user_dictionary_command_status_;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::mutable_user_dictionary_command_status() {
  set_has_user_dictionary_command_status();
  if (user_dictionary_command_status_ == NULL) user_dictionary_command_status_ = new ::mozc::user_dictionary::UserDictionaryCommandStatus;
  return user_dictionary_command_status_;
}
inline ::mozc::user_dictionary::UserDictionaryCommandStatus* Output::release_user_dictionary_command_status() {
  clear_has_user_dictionary_command_status();
  ::mozc::user_dictionary::UserDictionaryCommandStatus* temp = user_dictionary_command_status_;
  user_dictionary_command_status_ = NULL;
  return temp;
}
inline void Output::set_allocated_user_dictionary_command_status(::mozc::user_dictionary::UserDictionaryCommandStatus* user_dictionary_command_status) {
  delete user_dictionary_command_status_;
  user_dictionary_command_status_ = user_dictionary_command_status;
  if (user_dictionary_command_status) {
    set_has_user_dictionary_command_status();
  } else {
    clear_has_user_dictionary_command_status();
  }
}

// -------------------------------------------------------------------

// Command

// required .mozc.commands.Input input = 1;
inline bool Command::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_input() {
  if (input_ != NULL) input_->::mozc::commands::Input::Clear();
  clear_has_input();
}
inline const ::mozc::commands::Input& Command::input() const {
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::mozc::commands::Input* Command::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::mozc::commands::Input;
  return input_;
}
inline ::mozc::commands::Input* Command::release_input() {
  clear_has_input();
  ::mozc::commands::Input* temp = input_;
  input_ = NULL;
  return temp;
}
inline void Command::set_allocated_input(::mozc::commands::Input* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// required .mozc.commands.Output output = 2;
inline bool Command::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_output() {
  if (output_ != NULL) output_->::mozc::commands::Output::Clear();
  clear_has_output();
}
inline const ::mozc::commands::Output& Command::output() const {
  return output_ != NULL ? *output_ : *default_instance_->output_;
}
inline ::mozc::commands::Output* Command::mutable_output() {
  set_has_output();
  if (output_ == NULL) output_ = new ::mozc::commands::Output;
  return output_;
}
inline ::mozc::commands::Output* Command::release_output() {
  clear_has_output();
  ::mozc::commands::Output* temp = output_;
  output_ = NULL;
  return temp;
}
inline void Command::set_allocated_output(::mozc::commands::Output* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
}

// -------------------------------------------------------------------

// CommandList

// repeated .mozc.commands.Command commands = 1;
inline int CommandList::commands_size() const {
  return commands_.size();
}
inline void CommandList::clear_commands() {
  commands_.Clear();
}
inline const ::mozc::commands::Command& CommandList::commands(int index) const {
  return commands_.Get(index);
}
inline ::mozc::commands::Command* CommandList::mutable_commands(int index) {
  return commands_.Mutable(index);
}
inline ::mozc::commands::Command* CommandList::add_commands() {
  return commands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >&
CommandList::commands() const {
  return commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Command >*
CommandList::mutable_commands() {
  return &commands_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace mozc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_SpecialKey>() {
  return ::mozc::commands::KeyEvent_SpecialKey_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_ModifierKey>() {
  return ::mozc::commands::KeyEvent_ModifierKey_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::KeyEvent_InputStyle>() {
  return ::mozc::commands::KeyEvent_InputStyle_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::GenericStorageEntry_StorageType>() {
  return ::mozc::commands::GenericStorageEntry_StorageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_CommandType>() {
  return ::mozc::commands::SessionCommand_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::SessionCommand_UsageStatsEvent>() {
  return ::mozc::commands::SessionCommand_UsageStatsEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Context_InputFieldType>() {
  return ::mozc::commands::Context_InputFieldType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Capability_TextDeletionCapabilityType>() {
  return ::mozc::commands::Capability_TextDeletionCapabilityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpecialRomanjiTable>() {
  return ::mozc::commands::Request_SpecialRomanjiTable_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_SpaceOnAlphanumeric>() {
  return ::mozc::commands::Request_SpaceOnAlphanumeric_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_EmojiCarrierType>() {
  return ::mozc::commands::Request_EmojiCarrierType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_RewriterCapability>() {
  return ::mozc::commands::Request_RewriterCapability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_CrossingEdgeBehavior>() {
  return ::mozc::commands::Request_CrossingEdgeBehavior_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Request_LanguageAwareInputBehavior>() {
  return ::mozc::commands::Request_LanguageAwareInputBehavior_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_CommandType>() {
  return ::mozc::commands::Input_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Input_TouchAction>() {
  return ::mozc::commands::Input_TouchAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Result_ResultType>() {
  return ::mozc::commands::Result_ResultType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Preedit_Segment_Annotation>() {
  return ::mozc::commands::Preedit_Segment_Annotation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_PreeditMethod>() {
  return ::mozc::commands::Output_PreeditMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ErrorCode>() {
  return ::mozc::commands::Output_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Output_ToolMode>() {
  return ::mozc::commands::Output_ToolMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::CompositionMode>() {
  return ::mozc::commands::CompositionMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_session_2fcommands_2eproto__INCLUDED
