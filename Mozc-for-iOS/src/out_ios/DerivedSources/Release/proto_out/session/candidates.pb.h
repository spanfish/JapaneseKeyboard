// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session/candidates.proto

#ifndef PROTOBUF_session_2fcandidates_2eproto__INCLUDED
#define PROTOBUF_session_2fcandidates_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mozc {
namespace commands {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_session_2fcandidates_2eproto();
void protobuf_AssignDesc_session_2fcandidates_2eproto();
void protobuf_ShutdownFile_session_2fcandidates_2eproto();

class Annotation;
class Information;
class Rectangle;
class InformationList;
class Footer;
class CandidateWord;
class CandidateList;
class Candidates;
class Candidates_Candidate;

enum Candidates_Direction {
  Candidates_Direction_VERTICAL = 0,
  Candidates_Direction_HORIZONTAL = 1
};
bool Candidates_Direction_IsValid(int value);
const Candidates_Direction Candidates_Direction_Direction_MIN = Candidates_Direction_VERTICAL;
const Candidates_Direction Candidates_Direction_Direction_MAX = Candidates_Direction_HORIZONTAL;
const int Candidates_Direction_Direction_ARRAYSIZE = Candidates_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Candidates_Direction_descriptor();
inline const ::std::string& Candidates_Direction_Name(Candidates_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Candidates_Direction_descriptor(), value);
}
inline bool Candidates_Direction_Parse(
    const ::std::string& name, Candidates_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Candidates_Direction>(
    Candidates_Direction_descriptor(), name, value);
}
enum Candidates_CandidateWindowLocation {
  Candidates_CandidateWindowLocation_CARET = 0,
  Candidates_CandidateWindowLocation_COMPOSITION = 1
};
bool Candidates_CandidateWindowLocation_IsValid(int value);
const Candidates_CandidateWindowLocation Candidates_CandidateWindowLocation_CandidateWindowLocation_MIN = Candidates_CandidateWindowLocation_CARET;
const Candidates_CandidateWindowLocation Candidates_CandidateWindowLocation_CandidateWindowLocation_MAX = Candidates_CandidateWindowLocation_COMPOSITION;
const int Candidates_CandidateWindowLocation_CandidateWindowLocation_ARRAYSIZE = Candidates_CandidateWindowLocation_CandidateWindowLocation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Candidates_CandidateWindowLocation_descriptor();
inline const ::std::string& Candidates_CandidateWindowLocation_Name(Candidates_CandidateWindowLocation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Candidates_CandidateWindowLocation_descriptor(), value);
}
inline bool Candidates_CandidateWindowLocation_Parse(
    const ::std::string& name, Candidates_CandidateWindowLocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Candidates_CandidateWindowLocation>(
    Candidates_CandidateWindowLocation_descriptor(), name, value);
}
enum Category {
  CONVERSION = 0,
  PREDICTION = 1,
  SUGGESTION = 2,
  TRANSLITERATION = 3,
  USAGE = 4
};
bool Category_IsValid(int value);
const Category Category_MIN = CONVERSION;
const Category Category_MAX = USAGE;
const int Category_ARRAYSIZE = Category_MAX + 1;

const ::google::protobuf::EnumDescriptor* Category_descriptor();
inline const ::std::string& Category_Name(Category value) {
  return ::google::protobuf::internal::NameOfEnum(
    Category_descriptor(), value);
}
inline bool Category_Parse(
    const ::std::string& name, Category* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Category>(
    Category_descriptor(), name, value);
}
enum DisplayType {
  MAIN = 0,
  CASCADE = 1
};
bool DisplayType_IsValid(int value);
const DisplayType DisplayType_MIN = MAIN;
const DisplayType DisplayType_MAX = CASCADE;
const int DisplayType_ARRAYSIZE = DisplayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayType_descriptor();
inline const ::std::string& DisplayType_Name(DisplayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayType_descriptor(), value);
}
inline bool DisplayType_Parse(
    const ::std::string& name, DisplayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayType>(
    DisplayType_descriptor(), name, value);
}
// ===================================================================

class Annotation : public ::google::protobuf::Message {
 public:
  Annotation();
  virtual ~Annotation();

  Annotation(const Annotation& from);

  inline Annotation& operator=(const Annotation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Annotation& default_instance();

  void Swap(Annotation* other);

  // implements Message ----------------------------------------------

  Annotation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Annotation& from);
  void MergeFrom(const Annotation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // optional string suffix = 2;
  inline bool has_suffix() const;
  inline void clear_suffix();
  static const int kSuffixFieldNumber = 2;
  inline const ::std::string& suffix() const;
  inline void set_suffix(const ::std::string& value);
  inline void set_suffix(const char* value);
  inline void set_suffix(const char* value, size_t size);
  inline ::std::string* mutable_suffix();
  inline ::std::string* release_suffix();
  inline void set_allocated_suffix(::std::string* suffix);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string shortcut = 4;
  inline bool has_shortcut() const;
  inline void clear_shortcut();
  static const int kShortcutFieldNumber = 4;
  inline const ::std::string& shortcut() const;
  inline void set_shortcut(const ::std::string& value);
  inline void set_shortcut(const char* value);
  inline void set_shortcut(const char* value, size_t size);
  inline ::std::string* mutable_shortcut();
  inline ::std::string* release_shortcut();
  inline void set_allocated_shortcut(::std::string* shortcut);

  // optional bool deletable = 5 [default = false];
  inline bool has_deletable() const;
  inline void clear_deletable();
  static const int kDeletableFieldNumber = 5;
  inline bool deletable() const;
  inline void set_deletable(bool value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Annotation)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_suffix();
  inline void clear_has_suffix();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_shortcut();
  inline void clear_has_shortcut();
  inline void set_has_deletable();
  inline void clear_has_deletable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::std::string* suffix_;
  ::std::string* description_;
  ::std::string* shortcut_;
  bool deletable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Annotation* default_instance_;
};
// -------------------------------------------------------------------

class Information : public ::google::protobuf::Message {
 public:
  Information();
  virtual ~Information();

  Information(const Information& from);

  inline Information& operator=(const Information& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Information& default_instance();

  void Swap(Information* other);

  // implements Message ----------------------------------------------

  Information* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Information& from);
  void MergeFrom(const Information& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated int32 candidate_id = 4;
  inline int candidate_id_size() const;
  inline void clear_candidate_id();
  static const int kCandidateIdFieldNumber = 4;
  inline ::google::protobuf::int32 candidate_id(int index) const;
  inline void set_candidate_id(int index, ::google::protobuf::int32 value);
  inline void add_candidate_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      candidate_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_candidate_id();

  // @@protoc_insertion_point(class_scope:mozc.commands.Information)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::std::string* description_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > candidate_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Information* default_instance_;
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message {
 public:
  Rectangle();
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();

  void Swap(Rectangle* other);

  // implements Message ----------------------------------------------

  Rectangle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Rectangle)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Rectangle* default_instance_;
};
// -------------------------------------------------------------------

class InformationList : public ::google::protobuf::Message {
 public:
  InformationList();
  virtual ~InformationList();

  InformationList(const InformationList& from);

  inline InformationList& operator=(const InformationList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InformationList& default_instance();

  void Swap(InformationList* other);

  // implements Message ----------------------------------------------

  InformationList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InformationList& from);
  void MergeFrom(const InformationList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 focused_index = 1;
  inline bool has_focused_index() const;
  inline void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 focused_index() const;
  inline void set_focused_index(::google::protobuf::uint32 value);

  // repeated .mozc.commands.Information information = 2;
  inline int information_size() const;
  inline void clear_information();
  static const int kInformationFieldNumber = 2;
  inline const ::mozc::commands::Information& information(int index) const;
  inline ::mozc::commands::Information* mutable_information(int index);
  inline ::mozc::commands::Information* add_information();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >&
      information() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >*
      mutable_information();

  // optional .mozc.commands.Category category = 3 [default = CONVERSION];
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 3;
  inline ::mozc::commands::Category category() const;
  inline void set_category(::mozc::commands::Category value);

  // optional .mozc.commands.DisplayType display_type = 4 [default = CASCADE];
  inline bool has_display_type() const;
  inline void clear_display_type();
  static const int kDisplayTypeFieldNumber = 4;
  inline ::mozc::commands::DisplayType display_type() const;
  inline void set_display_type(::mozc::commands::DisplayType value);

  // optional uint32 delay = 5 [default = 500];
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 5;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.InformationList)
 private:
  inline void set_has_focused_index();
  inline void clear_has_focused_index();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_display_type();
  inline void clear_has_display_type();
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information > information_;
  ::google::protobuf::uint32 focused_index_;
  int category_;
  int display_type_;
  ::google::protobuf::uint32 delay_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static InformationList* default_instance_;
};
// -------------------------------------------------------------------

class Footer : public ::google::protobuf::Message {
 public:
  Footer();
  virtual ~Footer();

  Footer(const Footer& from);

  inline Footer& operator=(const Footer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Footer& default_instance();

  void Swap(Footer* other);

  // implements Message ----------------------------------------------

  Footer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Footer& from);
  void MergeFrom(const Footer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool index_visible = 2 [default = false];
  inline bool has_index_visible() const;
  inline void clear_index_visible();
  static const int kIndexVisibleFieldNumber = 2;
  inline bool index_visible() const;
  inline void set_index_visible(bool value);

  // optional bool logo_visible = 3 [default = false];
  inline bool has_logo_visible() const;
  inline void clear_logo_visible();
  static const int kLogoVisibleFieldNumber = 3;
  inline bool logo_visible() const;
  inline void set_logo_visible(bool value);

  // optional string sub_label = 4;
  inline bool has_sub_label() const;
  inline void clear_sub_label();
  static const int kSubLabelFieldNumber = 4;
  inline const ::std::string& sub_label() const;
  inline void set_sub_label(const ::std::string& value);
  inline void set_sub_label(const char* value);
  inline void set_sub_label(const char* value, size_t size);
  inline ::std::string* mutable_sub_label();
  inline ::std::string* release_sub_label();
  inline void set_allocated_sub_label(::std::string* sub_label);

  // @@protoc_insertion_point(class_scope:mozc.commands.Footer)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_index_visible();
  inline void clear_has_index_visible();
  inline void set_has_logo_visible();
  inline void clear_has_logo_visible();
  inline void set_has_sub_label();
  inline void clear_has_sub_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* label_;
  ::std::string* sub_label_;
  bool index_visible_;
  bool logo_visible_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Footer* default_instance_;
};
// -------------------------------------------------------------------

class CandidateWord : public ::google::protobuf::Message {
 public:
  CandidateWord();
  virtual ~CandidateWord();

  CandidateWord(const CandidateWord& from);

  inline CandidateWord& operator=(const CandidateWord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CandidateWord& default_instance();

  void Swap(CandidateWord* other);

  // implements Message ----------------------------------------------

  CandidateWord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CandidateWord& from);
  void MergeFrom(const CandidateWord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .mozc.commands.Annotation annotation = 5;
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 5;
  inline const ::mozc::commands::Annotation& annotation() const;
  inline ::mozc::commands::Annotation* mutable_annotation();
  inline ::mozc::commands::Annotation* release_annotation();
  inline void set_allocated_annotation(::mozc::commands::Annotation* annotation);

  // @@protoc_insertion_point(class_scope:mozc.commands.CandidateWord)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_annotation();
  inline void clear_has_annotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 index_;
  ::std::string* key_;
  ::std::string* value_;
  ::mozc::commands::Annotation* annotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static CandidateWord* default_instance_;
};
// -------------------------------------------------------------------

class CandidateList : public ::google::protobuf::Message {
 public:
  CandidateList();
  virtual ~CandidateList();

  CandidateList(const CandidateList& from);

  inline CandidateList& operator=(const CandidateList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CandidateList& default_instance();

  void Swap(CandidateList* other);

  // implements Message ----------------------------------------------

  CandidateList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CandidateList& from);
  void MergeFrom(const CandidateList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 focused_index = 1;
  inline bool has_focused_index() const;
  inline void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 focused_index() const;
  inline void set_focused_index(::google::protobuf::uint32 value);

  // repeated .mozc.commands.CandidateWord candidates = 2;
  inline int candidates_size() const;
  inline void clear_candidates();
  static const int kCandidatesFieldNumber = 2;
  inline const ::mozc::commands::CandidateWord& candidates(int index) const;
  inline ::mozc::commands::CandidateWord* mutable_candidates(int index);
  inline ::mozc::commands::CandidateWord* add_candidates();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >&
      candidates() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >*
      mutable_candidates();

  // optional .mozc.commands.Category category = 3 [default = CONVERSION];
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 3;
  inline ::mozc::commands::Category category() const;
  inline void set_category(::mozc::commands::Category value);

  // @@protoc_insertion_point(class_scope:mozc.commands.CandidateList)
 private:
  inline void set_has_focused_index();
  inline void clear_has_focused_index();
  inline void set_has_category();
  inline void clear_has_category();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord > candidates_;
  ::google::protobuf::uint32 focused_index_;
  int category_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static CandidateList* default_instance_;
};
// -------------------------------------------------------------------

class Candidates_Candidate : public ::google::protobuf::Message {
 public:
  Candidates_Candidate();
  virtual ~Candidates_Candidate();

  Candidates_Candidate(const Candidates_Candidate& from);

  inline Candidates_Candidate& operator=(const Candidates_Candidate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Candidates_Candidate& default_instance();

  void Swap(Candidates_Candidate* other);

  // implements Message ----------------------------------------------

  Candidates_Candidate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Candidates_Candidate& from);
  void MergeFrom(const Candidates_Candidate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional int32 id = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 9;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .mozc.commands.Annotation annotation = 7;
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 7;
  inline const ::mozc::commands::Annotation& annotation() const;
  inline ::mozc::commands::Annotation* mutable_annotation();
  inline ::mozc::commands::Annotation* release_annotation();
  inline void set_allocated_annotation(::mozc::commands::Annotation* annotation);

  // optional int32 information_id = 10;
  inline bool has_information_id() const;
  inline void clear_information_id();
  static const int kInformationIdFieldNumber = 10;
  inline ::google::protobuf::int32 information_id() const;
  inline void set_information_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Candidates.Candidate)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_annotation();
  inline void clear_has_annotation();
  inline void set_has_information_id();
  inline void clear_has_information_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::int32 id_;
  ::mozc::commands::Annotation* annotation_;
  ::google::protobuf::int32 information_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Candidates_Candidate* default_instance_;
};
// -------------------------------------------------------------------

class Candidates : public ::google::protobuf::Message {
 public:
  Candidates();
  virtual ~Candidates();

  Candidates(const Candidates& from);

  inline Candidates& operator=(const Candidates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Candidates& default_instance();

  void Swap(Candidates* other);

  // implements Message ----------------------------------------------

  Candidates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Candidates& from);
  void MergeFrom(const Candidates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Candidates_Candidate Candidate;

  typedef Candidates_Direction Direction;
  static const Direction VERTICAL = Candidates_Direction_VERTICAL;
  static const Direction HORIZONTAL = Candidates_Direction_HORIZONTAL;
  static inline bool Direction_IsValid(int value) {
    return Candidates_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Candidates_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Candidates_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Candidates_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Candidates_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Candidates_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Candidates_Direction_Parse(name, value);
  }

  typedef Candidates_CandidateWindowLocation CandidateWindowLocation;
  static const CandidateWindowLocation CARET = Candidates_CandidateWindowLocation_CARET;
  static const CandidateWindowLocation COMPOSITION = Candidates_CandidateWindowLocation_COMPOSITION;
  static inline bool CandidateWindowLocation_IsValid(int value) {
    return Candidates_CandidateWindowLocation_IsValid(value);
  }
  static const CandidateWindowLocation CandidateWindowLocation_MIN =
    Candidates_CandidateWindowLocation_CandidateWindowLocation_MIN;
  static const CandidateWindowLocation CandidateWindowLocation_MAX =
    Candidates_CandidateWindowLocation_CandidateWindowLocation_MAX;
  static const int CandidateWindowLocation_ARRAYSIZE =
    Candidates_CandidateWindowLocation_CandidateWindowLocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CandidateWindowLocation_descriptor() {
    return Candidates_CandidateWindowLocation_descriptor();
  }
  static inline const ::std::string& CandidateWindowLocation_Name(CandidateWindowLocation value) {
    return Candidates_CandidateWindowLocation_Name(value);
  }
  static inline bool CandidateWindowLocation_Parse(const ::std::string& name,
      CandidateWindowLocation* value) {
    return Candidates_CandidateWindowLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 focused_index = 1;
  inline bool has_focused_index() const;
  inline void clear_focused_index();
  static const int kFocusedIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 focused_index() const;
  inline void set_focused_index(::google::protobuf::uint32 value);

  // required uint32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // repeated group Candidate = 3 {
  inline int candidate_size() const;
  inline void clear_candidate();
  static const int kCandidateFieldNumber = 3;
  inline const ::mozc::commands::Candidates_Candidate& candidate(int index) const;
  inline ::mozc::commands::Candidates_Candidate* mutable_candidate(int index);
  inline ::mozc::commands::Candidates_Candidate* add_candidate();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >&
      candidate() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >*
      mutable_candidate();

  // required uint32 position = 6;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional .mozc.commands.Candidates subcandidates = 8;
  inline bool has_subcandidates() const;
  inline void clear_subcandidates();
  static const int kSubcandidatesFieldNumber = 8;
  inline const ::mozc::commands::Candidates& subcandidates() const;
  inline ::mozc::commands::Candidates* mutable_subcandidates();
  inline ::mozc::commands::Candidates* release_subcandidates();
  inline void set_allocated_subcandidates(::mozc::commands::Candidates* subcandidates);

  // optional .mozc.commands.InformationList usages = 10;
  inline bool has_usages() const;
  inline void clear_usages();
  static const int kUsagesFieldNumber = 10;
  inline const ::mozc::commands::InformationList& usages() const;
  inline ::mozc::commands::InformationList* mutable_usages();
  inline ::mozc::commands::InformationList* release_usages();
  inline void set_allocated_usages(::mozc::commands::InformationList* usages);

  // optional .mozc.commands.Category category = 11 [default = CONVERSION];
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 11;
  inline ::mozc::commands::Category category() const;
  inline void set_category(::mozc::commands::Category value);

  // optional .mozc.commands.DisplayType display_type = 12 [default = MAIN];
  inline bool has_display_type() const;
  inline void clear_display_type();
  static const int kDisplayTypeFieldNumber = 12;
  inline ::mozc::commands::DisplayType display_type() const;
  inline void set_display_type(::mozc::commands::DisplayType value);

  // optional .mozc.commands.Footer footer = 13;
  inline bool has_footer() const;
  inline void clear_footer();
  static const int kFooterFieldNumber = 13;
  inline const ::mozc::commands::Footer& footer() const;
  inline ::mozc::commands::Footer* mutable_footer();
  inline ::mozc::commands::Footer* release_footer();
  inline void set_allocated_footer(::mozc::commands::Footer* footer);

  // optional .mozc.commands.Candidates.Direction direction = 14 [default = VERTICAL];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 14;
  inline ::mozc::commands::Candidates_Direction direction() const;
  inline void set_direction(::mozc::commands::Candidates_Direction value);

  // optional .mozc.commands.Rectangle composition_rectangle = 15;
  inline bool has_composition_rectangle() const;
  inline void clear_composition_rectangle();
  static const int kCompositionRectangleFieldNumber = 15;
  inline const ::mozc::commands::Rectangle& composition_rectangle() const;
  inline ::mozc::commands::Rectangle* mutable_composition_rectangle();
  inline ::mozc::commands::Rectangle* release_composition_rectangle();
  inline void set_allocated_composition_rectangle(::mozc::commands::Rectangle* composition_rectangle);

  // optional .mozc.commands.Rectangle caret_rectangle = 16;
  inline bool has_caret_rectangle() const;
  inline void clear_caret_rectangle();
  static const int kCaretRectangleFieldNumber = 16;
  inline const ::mozc::commands::Rectangle& caret_rectangle() const;
  inline ::mozc::commands::Rectangle* mutable_caret_rectangle();
  inline ::mozc::commands::Rectangle* release_caret_rectangle();
  inline void set_allocated_caret_rectangle(::mozc::commands::Rectangle* caret_rectangle);

  // optional .mozc.commands.Candidates.CandidateWindowLocation window_location = 17;
  inline bool has_window_location() const;
  inline void clear_window_location();
  static const int kWindowLocationFieldNumber = 17;
  inline ::mozc::commands::Candidates_CandidateWindowLocation window_location() const;
  inline void set_window_location(::mozc::commands::Candidates_CandidateWindowLocation value);

  // @@protoc_insertion_point(class_scope:mozc.commands.Candidates)
 private:
  inline void set_has_focused_index();
  inline void clear_has_focused_index();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_subcandidates();
  inline void clear_has_subcandidates();
  inline void set_has_usages();
  inline void clear_has_usages();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_display_type();
  inline void clear_has_display_type();
  inline void set_has_footer();
  inline void clear_has_footer();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_composition_rectangle();
  inline void clear_has_composition_rectangle();
  inline void set_has_caret_rectangle();
  inline void clear_has_caret_rectangle();
  inline void set_has_window_location();
  inline void clear_has_window_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 focused_index_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate > candidate_;
  ::mozc::commands::Candidates* subcandidates_;
  ::google::protobuf::uint32 position_;
  int category_;
  ::mozc::commands::InformationList* usages_;
  ::mozc::commands::Footer* footer_;
  int display_type_;
  int direction_;
  ::mozc::commands::Rectangle* composition_rectangle_;
  ::mozc::commands::Rectangle* caret_rectangle_;
  int window_location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_session_2fcandidates_2eproto();
  friend void protobuf_AssignDesc_session_2fcandidates_2eproto();
  friend void protobuf_ShutdownFile_session_2fcandidates_2eproto();

  void InitAsDefaultInstance();
  static Candidates* default_instance_;
};
// ===================================================================


// ===================================================================

// Annotation

// optional string prefix = 1;
inline bool Annotation::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Annotation::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Annotation::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Annotation::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& Annotation::prefix() const {
  return *prefix_;
}
inline void Annotation::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void Annotation::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void Annotation::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Annotation::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* Annotation::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Annotation::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suffix = 2;
inline bool Annotation::has_suffix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Annotation::set_has_suffix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Annotation::clear_has_suffix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Annotation::clear_suffix() {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    suffix_->clear();
  }
  clear_has_suffix();
}
inline const ::std::string& Annotation::suffix() const {
  return *suffix_;
}
inline void Annotation::set_suffix(const ::std::string& value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void Annotation::set_suffix(const char* value) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(value);
}
inline void Annotation::set_suffix(const char* value, size_t size) {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  suffix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Annotation::mutable_suffix() {
  set_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    suffix_ = new ::std::string;
  }
  return suffix_;
}
inline ::std::string* Annotation::release_suffix() {
  clear_has_suffix();
  if (suffix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suffix_;
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Annotation::set_allocated_suffix(::std::string* suffix) {
  if (suffix_ != &::google::protobuf::internal::kEmptyString) {
    delete suffix_;
  }
  if (suffix) {
    set_has_suffix();
    suffix_ = suffix;
  } else {
    clear_has_suffix();
    suffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 3;
inline bool Annotation::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Annotation::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Annotation::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Annotation::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Annotation::description() const {
  return *description_;
}
inline void Annotation::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Annotation::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Annotation::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Annotation::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Annotation::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Annotation::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string shortcut = 4;
inline bool Annotation::has_shortcut() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Annotation::set_has_shortcut() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Annotation::clear_has_shortcut() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Annotation::clear_shortcut() {
  if (shortcut_ != &::google::protobuf::internal::kEmptyString) {
    shortcut_->clear();
  }
  clear_has_shortcut();
}
inline const ::std::string& Annotation::shortcut() const {
  return *shortcut_;
}
inline void Annotation::set_shortcut(const ::std::string& value) {
  set_has_shortcut();
  if (shortcut_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_ = new ::std::string;
  }
  shortcut_->assign(value);
}
inline void Annotation::set_shortcut(const char* value) {
  set_has_shortcut();
  if (shortcut_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_ = new ::std::string;
  }
  shortcut_->assign(value);
}
inline void Annotation::set_shortcut(const char* value, size_t size) {
  set_has_shortcut();
  if (shortcut_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_ = new ::std::string;
  }
  shortcut_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Annotation::mutable_shortcut() {
  set_has_shortcut();
  if (shortcut_ == &::google::protobuf::internal::kEmptyString) {
    shortcut_ = new ::std::string;
  }
  return shortcut_;
}
inline ::std::string* Annotation::release_shortcut() {
  clear_has_shortcut();
  if (shortcut_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shortcut_;
    shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Annotation::set_allocated_shortcut(::std::string* shortcut) {
  if (shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete shortcut_;
  }
  if (shortcut) {
    set_has_shortcut();
    shortcut_ = shortcut;
  } else {
    clear_has_shortcut();
    shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool deletable = 5 [default = false];
inline bool Annotation::has_deletable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Annotation::set_has_deletable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Annotation::clear_has_deletable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Annotation::clear_deletable() {
  deletable_ = false;
  clear_has_deletable();
}
inline bool Annotation::deletable() const {
  return deletable_;
}
inline void Annotation::set_deletable(bool value) {
  set_has_deletable();
  deletable_ = value;
}

// -------------------------------------------------------------------

// Information

// optional int32 id = 1;
inline bool Information::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Information::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Information::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Information::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Information::id() const {
  return id_;
}
inline void Information::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string title = 2;
inline bool Information::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Information::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Information::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Information::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Information::title() const {
  return *title_;
}
inline void Information::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Information::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Information::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Information::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Information::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Information::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 3;
inline bool Information::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Information::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Information::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Information::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Information::description() const {
  return *description_;
}
inline void Information::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Information::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Information::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Information::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Information::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Information::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 candidate_id = 4;
inline int Information::candidate_id_size() const {
  return candidate_id_.size();
}
inline void Information::clear_candidate_id() {
  candidate_id_.Clear();
}
inline ::google::protobuf::int32 Information::candidate_id(int index) const {
  return candidate_id_.Get(index);
}
inline void Information::set_candidate_id(int index, ::google::protobuf::int32 value) {
  candidate_id_.Set(index, value);
}
inline void Information::add_candidate_id(::google::protobuf::int32 value) {
  candidate_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Information::candidate_id() const {
  return candidate_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Information::mutable_candidate_id() {
  return &candidate_id_;
}

// -------------------------------------------------------------------

// Rectangle

// required int32 x = 1;
inline bool Rectangle::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rectangle::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rectangle::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rectangle::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Rectangle::x() const {
  return x_;
}
inline void Rectangle::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Rectangle::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rectangle::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rectangle::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rectangle::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Rectangle::y() const {
  return y_;
}
inline void Rectangle::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 width = 3;
inline bool Rectangle::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rectangle::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rectangle::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rectangle::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Rectangle::width() const {
  return width_;
}
inline void Rectangle::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 4;
inline bool Rectangle::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rectangle::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rectangle::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rectangle::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Rectangle::height() const {
  return height_;
}
inline void Rectangle::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// InformationList

// optional uint32 focused_index = 1;
inline bool InformationList::has_focused_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InformationList::set_has_focused_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InformationList::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InformationList::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 InformationList::focused_index() const {
  return focused_index_;
}
inline void InformationList::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
}

// repeated .mozc.commands.Information information = 2;
inline int InformationList::information_size() const {
  return information_.size();
}
inline void InformationList::clear_information() {
  information_.Clear();
}
inline const ::mozc::commands::Information& InformationList::information(int index) const {
  return information_.Get(index);
}
inline ::mozc::commands::Information* InformationList::mutable_information(int index) {
  return information_.Mutable(index);
}
inline ::mozc::commands::Information* InformationList::add_information() {
  return information_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >&
InformationList::information() const {
  return information_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Information >*
InformationList::mutable_information() {
  return &information_;
}

// optional .mozc.commands.Category category = 3 [default = CONVERSION];
inline bool InformationList::has_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InformationList::set_has_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InformationList::clear_has_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InformationList::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category InformationList::category() const {
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void InformationList::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
}

// optional .mozc.commands.DisplayType display_type = 4 [default = CASCADE];
inline bool InformationList::has_display_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InformationList::set_has_display_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InformationList::clear_has_display_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InformationList::clear_display_type() {
  display_type_ = 1;
  clear_has_display_type();
}
inline ::mozc::commands::DisplayType InformationList::display_type() const {
  return static_cast< ::mozc::commands::DisplayType >(display_type_);
}
inline void InformationList::set_display_type(::mozc::commands::DisplayType value) {
  assert(::mozc::commands::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
}

// optional uint32 delay = 5 [default = 500];
inline bool InformationList::has_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InformationList::set_has_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InformationList::clear_has_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InformationList::clear_delay() {
  delay_ = 500u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 InformationList::delay() const {
  return delay_;
}
inline void InformationList::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// -------------------------------------------------------------------

// Footer

// optional string label = 1;
inline bool Footer::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Footer::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Footer::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Footer::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Footer::label() const {
  return *label_;
}
inline void Footer::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Footer::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Footer::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Footer::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Footer::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Footer::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool index_visible = 2 [default = false];
inline bool Footer::has_index_visible() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Footer::set_has_index_visible() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Footer::clear_has_index_visible() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Footer::clear_index_visible() {
  index_visible_ = false;
  clear_has_index_visible();
}
inline bool Footer::index_visible() const {
  return index_visible_;
}
inline void Footer::set_index_visible(bool value) {
  set_has_index_visible();
  index_visible_ = value;
}

// optional bool logo_visible = 3 [default = false];
inline bool Footer::has_logo_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Footer::set_has_logo_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Footer::clear_has_logo_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Footer::clear_logo_visible() {
  logo_visible_ = false;
  clear_has_logo_visible();
}
inline bool Footer::logo_visible() const {
  return logo_visible_;
}
inline void Footer::set_logo_visible(bool value) {
  set_has_logo_visible();
  logo_visible_ = value;
}

// optional string sub_label = 4;
inline bool Footer::has_sub_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Footer::set_has_sub_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Footer::clear_has_sub_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Footer::clear_sub_label() {
  if (sub_label_ != &::google::protobuf::internal::kEmptyString) {
    sub_label_->clear();
  }
  clear_has_sub_label();
}
inline const ::std::string& Footer::sub_label() const {
  return *sub_label_;
}
inline void Footer::set_sub_label(const ::std::string& value) {
  set_has_sub_label();
  if (sub_label_ == &::google::protobuf::internal::kEmptyString) {
    sub_label_ = new ::std::string;
  }
  sub_label_->assign(value);
}
inline void Footer::set_sub_label(const char* value) {
  set_has_sub_label();
  if (sub_label_ == &::google::protobuf::internal::kEmptyString) {
    sub_label_ = new ::std::string;
  }
  sub_label_->assign(value);
}
inline void Footer::set_sub_label(const char* value, size_t size) {
  set_has_sub_label();
  if (sub_label_ == &::google::protobuf::internal::kEmptyString) {
    sub_label_ = new ::std::string;
  }
  sub_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Footer::mutable_sub_label() {
  set_has_sub_label();
  if (sub_label_ == &::google::protobuf::internal::kEmptyString) {
    sub_label_ = new ::std::string;
  }
  return sub_label_;
}
inline ::std::string* Footer::release_sub_label() {
  clear_has_sub_label();
  if (sub_label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sub_label_;
    sub_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Footer::set_allocated_sub_label(::std::string* sub_label) {
  if (sub_label_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_label_;
  }
  if (sub_label) {
    set_has_sub_label();
    sub_label_ = sub_label;
  } else {
    clear_has_sub_label();
    sub_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CandidateWord

// optional int32 id = 1;
inline bool CandidateWord::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CandidateWord::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CandidateWord::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CandidateWord::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CandidateWord::id() const {
  return id_;
}
inline void CandidateWord::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 index = 2;
inline bool CandidateWord::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CandidateWord::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CandidateWord::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CandidateWord::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CandidateWord::index() const {
  return index_;
}
inline void CandidateWord::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional string key = 3;
inline bool CandidateWord::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CandidateWord::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CandidateWord::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CandidateWord::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CandidateWord::key() const {
  return *key_;
}
inline void CandidateWord::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CandidateWord::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CandidateWord::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CandidateWord::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CandidateWord::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CandidateWord::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 4;
inline bool CandidateWord::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CandidateWord::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CandidateWord::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CandidateWord::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CandidateWord::value() const {
  return *value_;
}
inline void CandidateWord::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CandidateWord::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CandidateWord::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CandidateWord::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CandidateWord::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CandidateWord::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mozc.commands.Annotation annotation = 5;
inline bool CandidateWord::has_annotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CandidateWord::set_has_annotation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CandidateWord::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CandidateWord::clear_annotation() {
  if (annotation_ != NULL) annotation_->::mozc::commands::Annotation::Clear();
  clear_has_annotation();
}
inline const ::mozc::commands::Annotation& CandidateWord::annotation() const {
  return annotation_ != NULL ? *annotation_ : *default_instance_->annotation_;
}
inline ::mozc::commands::Annotation* CandidateWord::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == NULL) annotation_ = new ::mozc::commands::Annotation;
  return annotation_;
}
inline ::mozc::commands::Annotation* CandidateWord::release_annotation() {
  clear_has_annotation();
  ::mozc::commands::Annotation* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline void CandidateWord::set_allocated_annotation(::mozc::commands::Annotation* annotation) {
  delete annotation_;
  annotation_ = annotation;
  if (annotation) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
}

// -------------------------------------------------------------------

// CandidateList

// optional uint32 focused_index = 1;
inline bool CandidateList::has_focused_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CandidateList::set_has_focused_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CandidateList::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CandidateList::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 CandidateList::focused_index() const {
  return focused_index_;
}
inline void CandidateList::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
}

// repeated .mozc.commands.CandidateWord candidates = 2;
inline int CandidateList::candidates_size() const {
  return candidates_.size();
}
inline void CandidateList::clear_candidates() {
  candidates_.Clear();
}
inline const ::mozc::commands::CandidateWord& CandidateList::candidates(int index) const {
  return candidates_.Get(index);
}
inline ::mozc::commands::CandidateWord* CandidateList::mutable_candidates(int index) {
  return candidates_.Mutable(index);
}
inline ::mozc::commands::CandidateWord* CandidateList::add_candidates() {
  return candidates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >&
CandidateList::candidates() const {
  return candidates_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::CandidateWord >*
CandidateList::mutable_candidates() {
  return &candidates_;
}

// optional .mozc.commands.Category category = 3 [default = CONVERSION];
inline bool CandidateList::has_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CandidateList::set_has_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CandidateList::clear_has_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CandidateList::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category CandidateList::category() const {
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void CandidateList::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
}

// -------------------------------------------------------------------

// Candidates_Candidate

// required uint32 index = 4;
inline bool Candidates_Candidate::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates_Candidate::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates_Candidate::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates_Candidate::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Candidates_Candidate::index() const {
  return index_;
}
inline void Candidates_Candidate::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required string value = 5;
inline bool Candidates_Candidate::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidates_Candidate::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidates_Candidate::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidates_Candidate::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Candidates_Candidate::value() const {
  return *value_;
}
inline void Candidates_Candidate::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Candidates_Candidate::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Candidates_Candidate::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Candidates_Candidate::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Candidates_Candidate::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Candidates_Candidate::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 id = 9;
inline bool Candidates_Candidate::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Candidates_Candidate::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Candidates_Candidate::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Candidates_Candidate::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Candidates_Candidate::id() const {
  return id_;
}
inline void Candidates_Candidate::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .mozc.commands.Annotation annotation = 7;
inline bool Candidates_Candidate::has_annotation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Candidates_Candidate::set_has_annotation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Candidates_Candidate::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Candidates_Candidate::clear_annotation() {
  if (annotation_ != NULL) annotation_->::mozc::commands::Annotation::Clear();
  clear_has_annotation();
}
inline const ::mozc::commands::Annotation& Candidates_Candidate::annotation() const {
  return annotation_ != NULL ? *annotation_ : *default_instance_->annotation_;
}
inline ::mozc::commands::Annotation* Candidates_Candidate::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == NULL) annotation_ = new ::mozc::commands::Annotation;
  return annotation_;
}
inline ::mozc::commands::Annotation* Candidates_Candidate::release_annotation() {
  clear_has_annotation();
  ::mozc::commands::Annotation* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline void Candidates_Candidate::set_allocated_annotation(::mozc::commands::Annotation* annotation) {
  delete annotation_;
  annotation_ = annotation;
  if (annotation) {
    set_has_annotation();
  } else {
    clear_has_annotation();
  }
}

// optional int32 information_id = 10;
inline bool Candidates_Candidate::has_information_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Candidates_Candidate::set_has_information_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Candidates_Candidate::clear_has_information_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Candidates_Candidate::clear_information_id() {
  information_id_ = 0;
  clear_has_information_id();
}
inline ::google::protobuf::int32 Candidates_Candidate::information_id() const {
  return information_id_;
}
inline void Candidates_Candidate::set_information_id(::google::protobuf::int32 value) {
  set_has_information_id();
  information_id_ = value;
}

// -------------------------------------------------------------------

// Candidates

// optional uint32 focused_index = 1;
inline bool Candidates::has_focused_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Candidates::set_has_focused_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Candidates::clear_has_focused_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Candidates::clear_focused_index() {
  focused_index_ = 0u;
  clear_has_focused_index();
}
inline ::google::protobuf::uint32 Candidates::focused_index() const {
  return focused_index_;
}
inline void Candidates::set_focused_index(::google::protobuf::uint32 value) {
  set_has_focused_index();
  focused_index_ = value;
}

// required uint32 size = 2;
inline bool Candidates::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Candidates::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Candidates::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Candidates::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 Candidates::size() const {
  return size_;
}
inline void Candidates::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// repeated group Candidate = 3 {
inline int Candidates::candidate_size() const {
  return candidate_.size();
}
inline void Candidates::clear_candidate() {
  candidate_.Clear();
}
inline const ::mozc::commands::Candidates_Candidate& Candidates::candidate(int index) const {
  return candidate_.Get(index);
}
inline ::mozc::commands::Candidates_Candidate* Candidates::mutable_candidate(int index) {
  return candidate_.Mutable(index);
}
inline ::mozc::commands::Candidates_Candidate* Candidates::add_candidate() {
  return candidate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >&
Candidates::candidate() const {
  return candidate_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::commands::Candidates_Candidate >*
Candidates::mutable_candidate() {
  return &candidate_;
}

// required uint32 position = 6;
inline bool Candidates::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Candidates::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Candidates::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Candidates::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Candidates::position() const {
  return position_;
}
inline void Candidates::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional .mozc.commands.Candidates subcandidates = 8;
inline bool Candidates::has_subcandidates() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Candidates::set_has_subcandidates() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Candidates::clear_has_subcandidates() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Candidates::clear_subcandidates() {
  if (subcandidates_ != NULL) subcandidates_->::mozc::commands::Candidates::Clear();
  clear_has_subcandidates();
}
inline const ::mozc::commands::Candidates& Candidates::subcandidates() const {
  return subcandidates_ != NULL ? *subcandidates_ : *default_instance_->subcandidates_;
}
inline ::mozc::commands::Candidates* Candidates::mutable_subcandidates() {
  set_has_subcandidates();
  if (subcandidates_ == NULL) subcandidates_ = new ::mozc::commands::Candidates;
  return subcandidates_;
}
inline ::mozc::commands::Candidates* Candidates::release_subcandidates() {
  clear_has_subcandidates();
  ::mozc::commands::Candidates* temp = subcandidates_;
  subcandidates_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_subcandidates(::mozc::commands::Candidates* subcandidates) {
  delete subcandidates_;
  subcandidates_ = subcandidates;
  if (subcandidates) {
    set_has_subcandidates();
  } else {
    clear_has_subcandidates();
  }
}

// optional .mozc.commands.InformationList usages = 10;
inline bool Candidates::has_usages() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Candidates::set_has_usages() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Candidates::clear_has_usages() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Candidates::clear_usages() {
  if (usages_ != NULL) usages_->::mozc::commands::InformationList::Clear();
  clear_has_usages();
}
inline const ::mozc::commands::InformationList& Candidates::usages() const {
  return usages_ != NULL ? *usages_ : *default_instance_->usages_;
}
inline ::mozc::commands::InformationList* Candidates::mutable_usages() {
  set_has_usages();
  if (usages_ == NULL) usages_ = new ::mozc::commands::InformationList;
  return usages_;
}
inline ::mozc::commands::InformationList* Candidates::release_usages() {
  clear_has_usages();
  ::mozc::commands::InformationList* temp = usages_;
  usages_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_usages(::mozc::commands::InformationList* usages) {
  delete usages_;
  usages_ = usages;
  if (usages) {
    set_has_usages();
  } else {
    clear_has_usages();
  }
}

// optional .mozc.commands.Category category = 11 [default = CONVERSION];
inline bool Candidates::has_category() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Candidates::set_has_category() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Candidates::clear_has_category() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Candidates::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::mozc::commands::Category Candidates::category() const {
  return static_cast< ::mozc::commands::Category >(category_);
}
inline void Candidates::set_category(::mozc::commands::Category value) {
  assert(::mozc::commands::Category_IsValid(value));
  set_has_category();
  category_ = value;
}

// optional .mozc.commands.DisplayType display_type = 12 [default = MAIN];
inline bool Candidates::has_display_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Candidates::set_has_display_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Candidates::clear_has_display_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Candidates::clear_display_type() {
  display_type_ = 0;
  clear_has_display_type();
}
inline ::mozc::commands::DisplayType Candidates::display_type() const {
  return static_cast< ::mozc::commands::DisplayType >(display_type_);
}
inline void Candidates::set_display_type(::mozc::commands::DisplayType value) {
  assert(::mozc::commands::DisplayType_IsValid(value));
  set_has_display_type();
  display_type_ = value;
}

// optional .mozc.commands.Footer footer = 13;
inline bool Candidates::has_footer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Candidates::set_has_footer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Candidates::clear_has_footer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Candidates::clear_footer() {
  if (footer_ != NULL) footer_->::mozc::commands::Footer::Clear();
  clear_has_footer();
}
inline const ::mozc::commands::Footer& Candidates::footer() const {
  return footer_ != NULL ? *footer_ : *default_instance_->footer_;
}
inline ::mozc::commands::Footer* Candidates::mutable_footer() {
  set_has_footer();
  if (footer_ == NULL) footer_ = new ::mozc::commands::Footer;
  return footer_;
}
inline ::mozc::commands::Footer* Candidates::release_footer() {
  clear_has_footer();
  ::mozc::commands::Footer* temp = footer_;
  footer_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_footer(::mozc::commands::Footer* footer) {
  delete footer_;
  footer_ = footer;
  if (footer) {
    set_has_footer();
  } else {
    clear_has_footer();
  }
}

// optional .mozc.commands.Candidates.Direction direction = 14 [default = VERTICAL];
inline bool Candidates::has_direction() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Candidates::set_has_direction() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Candidates::clear_has_direction() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Candidates::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::mozc::commands::Candidates_Direction Candidates::direction() const {
  return static_cast< ::mozc::commands::Candidates_Direction >(direction_);
}
inline void Candidates::set_direction(::mozc::commands::Candidates_Direction value) {
  assert(::mozc::commands::Candidates_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// optional .mozc.commands.Rectangle composition_rectangle = 15;
inline bool Candidates::has_composition_rectangle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Candidates::set_has_composition_rectangle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Candidates::clear_has_composition_rectangle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Candidates::clear_composition_rectangle() {
  if (composition_rectangle_ != NULL) composition_rectangle_->::mozc::commands::Rectangle::Clear();
  clear_has_composition_rectangle();
}
inline const ::mozc::commands::Rectangle& Candidates::composition_rectangle() const {
  return composition_rectangle_ != NULL ? *composition_rectangle_ : *default_instance_->composition_rectangle_;
}
inline ::mozc::commands::Rectangle* Candidates::mutable_composition_rectangle() {
  set_has_composition_rectangle();
  if (composition_rectangle_ == NULL) composition_rectangle_ = new ::mozc::commands::Rectangle;
  return composition_rectangle_;
}
inline ::mozc::commands::Rectangle* Candidates::release_composition_rectangle() {
  clear_has_composition_rectangle();
  ::mozc::commands::Rectangle* temp = composition_rectangle_;
  composition_rectangle_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_composition_rectangle(::mozc::commands::Rectangle* composition_rectangle) {
  delete composition_rectangle_;
  composition_rectangle_ = composition_rectangle;
  if (composition_rectangle) {
    set_has_composition_rectangle();
  } else {
    clear_has_composition_rectangle();
  }
}

// optional .mozc.commands.Rectangle caret_rectangle = 16;
inline bool Candidates::has_caret_rectangle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Candidates::set_has_caret_rectangle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Candidates::clear_has_caret_rectangle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Candidates::clear_caret_rectangle() {
  if (caret_rectangle_ != NULL) caret_rectangle_->::mozc::commands::Rectangle::Clear();
  clear_has_caret_rectangle();
}
inline const ::mozc::commands::Rectangle& Candidates::caret_rectangle() const {
  return caret_rectangle_ != NULL ? *caret_rectangle_ : *default_instance_->caret_rectangle_;
}
inline ::mozc::commands::Rectangle* Candidates::mutable_caret_rectangle() {
  set_has_caret_rectangle();
  if (caret_rectangle_ == NULL) caret_rectangle_ = new ::mozc::commands::Rectangle;
  return caret_rectangle_;
}
inline ::mozc::commands::Rectangle* Candidates::release_caret_rectangle() {
  clear_has_caret_rectangle();
  ::mozc::commands::Rectangle* temp = caret_rectangle_;
  caret_rectangle_ = NULL;
  return temp;
}
inline void Candidates::set_allocated_caret_rectangle(::mozc::commands::Rectangle* caret_rectangle) {
  delete caret_rectangle_;
  caret_rectangle_ = caret_rectangle;
  if (caret_rectangle) {
    set_has_caret_rectangle();
  } else {
    clear_has_caret_rectangle();
  }
}

// optional .mozc.commands.Candidates.CandidateWindowLocation window_location = 17;
inline bool Candidates::has_window_location() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Candidates::set_has_window_location() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Candidates::clear_has_window_location() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Candidates::clear_window_location() {
  window_location_ = 0;
  clear_has_window_location();
}
inline ::mozc::commands::Candidates_CandidateWindowLocation Candidates::window_location() const {
  return static_cast< ::mozc::commands::Candidates_CandidateWindowLocation >(window_location_);
}
inline void Candidates::set_window_location(::mozc::commands::Candidates_CandidateWindowLocation value) {
  assert(::mozc::commands::Candidates_CandidateWindowLocation_IsValid(value));
  set_has_window_location();
  window_location_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace commands
}  // namespace mozc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Candidates_Direction>() {
  return ::mozc::commands::Candidates_Direction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Candidates_CandidateWindowLocation>() {
  return ::mozc::commands::Candidates_CandidateWindowLocation_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::Category>() {
  return ::mozc::commands::Category_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::commands::DisplayType>() {
  return ::mozc::commands::DisplayType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_session_2fcandidates_2eproto__INCLUDED
