// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config/config.proto

#ifndef PROTOBUF_config_2fconfig_2eproto__INCLUDED
#define PROTOBUF_config_2fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mozc {
namespace config {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2fconfig_2eproto();
void protobuf_AssignDesc_config_2fconfig_2eproto();
void protobuf_ShutdownFile_config_2fconfig_2eproto();

class GeneralConfig;
class OBSOLETE_SyncConfig;
class Config;
class Config_CharacterFormRule;
class Config_InformationListConfig;

enum Config_PreeditMethod {
  Config_PreeditMethod_ROMAN = 0,
  Config_PreeditMethod_KANA = 1
};
bool Config_PreeditMethod_IsValid(int value);
const Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MIN = Config_PreeditMethod_ROMAN;
const Config_PreeditMethod Config_PreeditMethod_PreeditMethod_MAX = Config_PreeditMethod_KANA;
const int Config_PreeditMethod_PreeditMethod_ARRAYSIZE = Config_PreeditMethod_PreeditMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_PreeditMethod_descriptor();
inline const ::std::string& Config_PreeditMethod_Name(Config_PreeditMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_PreeditMethod_descriptor(), value);
}
inline bool Config_PreeditMethod_Parse(
    const ::std::string& name, Config_PreeditMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PreeditMethod>(
    Config_PreeditMethod_descriptor(), name, value);
}
enum Config_SessionKeymap {
  Config_SessionKeymap_NONE = -1,
  Config_SessionKeymap_CUSTOM = 0,
  Config_SessionKeymap_ATOK = 1,
  Config_SessionKeymap_MSIME = 2,
  Config_SessionKeymap_KOTOERI = 3,
  Config_SessionKeymap_MOBILE = 4,
  Config_SessionKeymap_CHROMEOS = 5
};
bool Config_SessionKeymap_IsValid(int value);
const Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MIN = Config_SessionKeymap_NONE;
const Config_SessionKeymap Config_SessionKeymap_SessionKeymap_MAX = Config_SessionKeymap_CHROMEOS;
const int Config_SessionKeymap_SessionKeymap_ARRAYSIZE = Config_SessionKeymap_SessionKeymap_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SessionKeymap_descriptor();
inline const ::std::string& Config_SessionKeymap_Name(Config_SessionKeymap value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SessionKeymap_descriptor(), value);
}
inline bool Config_SessionKeymap_Parse(
    const ::std::string& name, Config_SessionKeymap* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SessionKeymap>(
    Config_SessionKeymap_descriptor(), name, value);
}
enum Config_PunctuationMethod {
  Config_PunctuationMethod_KUTEN_TOUTEN = 0,
  Config_PunctuationMethod_COMMA_PERIOD = 1,
  Config_PunctuationMethod_KUTEN_PERIOD = 2,
  Config_PunctuationMethod_COMMA_TOUTEN = 3
};
bool Config_PunctuationMethod_IsValid(int value);
const Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MIN = Config_PunctuationMethod_KUTEN_TOUTEN;
const Config_PunctuationMethod Config_PunctuationMethod_PunctuationMethod_MAX = Config_PunctuationMethod_COMMA_TOUTEN;
const int Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE = Config_PunctuationMethod_PunctuationMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_PunctuationMethod_descriptor();
inline const ::std::string& Config_PunctuationMethod_Name(Config_PunctuationMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_PunctuationMethod_descriptor(), value);
}
inline bool Config_PunctuationMethod_Parse(
    const ::std::string& name, Config_PunctuationMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PunctuationMethod>(
    Config_PunctuationMethod_descriptor(), name, value);
}
enum Config_SymbolMethod {
  Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT = 0,
  Config_SymbolMethod_SQUARE_BRACKET_SLASH = 1,
  Config_SymbolMethod_CORNER_BRACKET_SLASH = 2,
  Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT = 3
};
bool Config_SymbolMethod_IsValid(int value);
const Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MIN = Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
const Config_SymbolMethod Config_SymbolMethod_SymbolMethod_MAX = Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
const int Config_SymbolMethod_SymbolMethod_ARRAYSIZE = Config_SymbolMethod_SymbolMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SymbolMethod_descriptor();
inline const ::std::string& Config_SymbolMethod_Name(Config_SymbolMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SymbolMethod_descriptor(), value);
}
inline bool Config_SymbolMethod_Parse(
    const ::std::string& name, Config_SymbolMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SymbolMethod>(
    Config_SymbolMethod_descriptor(), name, value);
}
enum Config_FundamentalCharacterForm {
  Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE = 0,
  Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH = 1,
  Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH = 2
};
bool Config_FundamentalCharacterForm_IsValid(int value);
const Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN = Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
const Config_FundamentalCharacterForm Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX = Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
const int Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE = Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_FundamentalCharacterForm_descriptor();
inline const ::std::string& Config_FundamentalCharacterForm_Name(Config_FundamentalCharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_FundamentalCharacterForm_descriptor(), value);
}
inline bool Config_FundamentalCharacterForm_Parse(
    const ::std::string& name, Config_FundamentalCharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_FundamentalCharacterForm>(
    Config_FundamentalCharacterForm_descriptor(), name, value);
}
enum Config_HistoryLearningLevel {
  Config_HistoryLearningLevel_DEFAULT_HISTORY = 0,
  Config_HistoryLearningLevel_READ_ONLY = 1,
  Config_HistoryLearningLevel_NO_HISTORY = 2
};
bool Config_HistoryLearningLevel_IsValid(int value);
const Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MIN = Config_HistoryLearningLevel_DEFAULT_HISTORY;
const Config_HistoryLearningLevel Config_HistoryLearningLevel_HistoryLearningLevel_MAX = Config_HistoryLearningLevel_NO_HISTORY;
const int Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE = Config_HistoryLearningLevel_HistoryLearningLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_HistoryLearningLevel_descriptor();
inline const ::std::string& Config_HistoryLearningLevel_Name(Config_HistoryLearningLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_HistoryLearningLevel_descriptor(), value);
}
inline bool Config_HistoryLearningLevel_Parse(
    const ::std::string& name, Config_HistoryLearningLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_HistoryLearningLevel>(
    Config_HistoryLearningLevel_descriptor(), name, value);
}
enum Config_SelectionShortcut {
  Config_SelectionShortcut_NO_SHORTCUT = 0,
  Config_SelectionShortcut_SHORTCUT_123456789 = 1,
  Config_SelectionShortcut_SHORTCUT_ASDFGHJKL = 2
};
bool Config_SelectionShortcut_IsValid(int value);
const Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MIN = Config_SelectionShortcut_NO_SHORTCUT;
const Config_SelectionShortcut Config_SelectionShortcut_SelectionShortcut_MAX = Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
const int Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE = Config_SelectionShortcut_SelectionShortcut_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_SelectionShortcut_descriptor();
inline const ::std::string& Config_SelectionShortcut_Name(Config_SelectionShortcut value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_SelectionShortcut_descriptor(), value);
}
inline bool Config_SelectionShortcut_Parse(
    const ::std::string& name, Config_SelectionShortcut* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_SelectionShortcut>(
    Config_SelectionShortcut_descriptor(), name, value);
}
enum Config_CharacterForm {
  Config_CharacterForm_HALF_WIDTH = 0,
  Config_CharacterForm_FULL_WIDTH = 1,
  Config_CharacterForm_LAST_FORM = 2,
  Config_CharacterForm_NO_CONVERSION = 3
};
bool Config_CharacterForm_IsValid(int value);
const Config_CharacterForm Config_CharacterForm_CharacterForm_MIN = Config_CharacterForm_HALF_WIDTH;
const Config_CharacterForm Config_CharacterForm_CharacterForm_MAX = Config_CharacterForm_NO_CONVERSION;
const int Config_CharacterForm_CharacterForm_ARRAYSIZE = Config_CharacterForm_CharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_CharacterForm_descriptor();
inline const ::std::string& Config_CharacterForm_Name(Config_CharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_CharacterForm_descriptor(), value);
}
inline bool Config_CharacterForm_Parse(
    const ::std::string& name, Config_CharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_CharacterForm>(
    Config_CharacterForm_descriptor(), name, value);
}
enum Config_ShiftKeyModeSwitch {
  Config_ShiftKeyModeSwitch_OFF = 0,
  Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE = 1,
  Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE = 2
};
bool Config_ShiftKeyModeSwitch_IsValid(int value);
const Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN = Config_ShiftKeyModeSwitch_OFF;
const Config_ShiftKeyModeSwitch Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX = Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
const int Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE = Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_ShiftKeyModeSwitch_descriptor();
inline const ::std::string& Config_ShiftKeyModeSwitch_Name(Config_ShiftKeyModeSwitch value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_ShiftKeyModeSwitch_descriptor(), value);
}
inline bool Config_ShiftKeyModeSwitch_Parse(
    const ::std::string& name, Config_ShiftKeyModeSwitch* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_ShiftKeyModeSwitch>(
    Config_ShiftKeyModeSwitch_descriptor(), name, value);
}
enum Config_NumpadCharacterForm {
  Config_NumpadCharacterForm_NUMPAD_INPUT_MODE = 0,
  Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH = 1,
  Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH = 2,
  Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT = 3
};
bool Config_NumpadCharacterForm_IsValid(int value);
const Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MIN = Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
const Config_NumpadCharacterForm Config_NumpadCharacterForm_NumpadCharacterForm_MAX = Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
const int Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE = Config_NumpadCharacterForm_NumpadCharacterForm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_NumpadCharacterForm_descriptor();
inline const ::std::string& Config_NumpadCharacterForm_Name(Config_NumpadCharacterForm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_NumpadCharacterForm_descriptor(), value);
}
inline bool Config_NumpadCharacterForm_Parse(
    const ::std::string& name, Config_NumpadCharacterForm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_NumpadCharacterForm>(
    Config_NumpadCharacterForm_descriptor(), name, value);
}
enum Config_AutoConversionKey {
  Config_AutoConversionKey_AUTO_CONVERSION_OFF = 0,
  Config_AutoConversionKey_AUTO_CONVERSION_KUTEN = 1,
  Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN = 2,
  Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK = 4,
  Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK = 8
};
bool Config_AutoConversionKey_IsValid(int value);
const Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MIN = Config_AutoConversionKey_AUTO_CONVERSION_OFF;
const Config_AutoConversionKey Config_AutoConversionKey_AutoConversionKey_MAX = Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
const int Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE = Config_AutoConversionKey_AutoConversionKey_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_AutoConversionKey_descriptor();
inline const ::std::string& Config_AutoConversionKey_Name(Config_AutoConversionKey value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_AutoConversionKey_descriptor(), value);
}
inline bool Config_AutoConversionKey_Parse(
    const ::std::string& name, Config_AutoConversionKey* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_AutoConversionKey>(
    Config_AutoConversionKey_descriptor(), name, value);
}
enum Config_YenSignCharacter {
  Config_YenSignCharacter_YEN_SIGN = 0,
  Config_YenSignCharacter_BACKSLASH = 1
};
bool Config_YenSignCharacter_IsValid(int value);
const Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MIN = Config_YenSignCharacter_YEN_SIGN;
const Config_YenSignCharacter Config_YenSignCharacter_YenSignCharacter_MAX = Config_YenSignCharacter_BACKSLASH;
const int Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE = Config_YenSignCharacter_YenSignCharacter_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_YenSignCharacter_descriptor();
inline const ::std::string& Config_YenSignCharacter_Name(Config_YenSignCharacter value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_YenSignCharacter_descriptor(), value);
}
inline bool Config_YenSignCharacter_Parse(
    const ::std::string& name, Config_YenSignCharacter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_YenSignCharacter>(
    Config_YenSignCharacter_descriptor(), name, value);
}
// ===================================================================

class GeneralConfig : public ::google::protobuf::Message {
 public:
  GeneralConfig();
  virtual ~GeneralConfig();

  GeneralConfig(const GeneralConfig& from);

  inline GeneralConfig& operator=(const GeneralConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralConfig& default_instance();

  void Swap(GeneralConfig* other);

  // implements Message ----------------------------------------------

  GeneralConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeneralConfig& from);
  void MergeFrom(const GeneralConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 config_version = 1 [default = 0];
  inline bool has_config_version() const;
  inline void clear_config_version();
  static const int kConfigVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 config_version() const;
  inline void set_config_version(::google::protobuf::uint32 value);

  // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
  inline bool has_last_modified_product_version() const;
  inline void clear_last_modified_product_version();
  static const int kLastModifiedProductVersionFieldNumber = 2;
  inline const ::std::string& last_modified_product_version() const;
  inline void set_last_modified_product_version(const ::std::string& value);
  inline void set_last_modified_product_version(const char* value);
  inline void set_last_modified_product_version(const char* value, size_t size);
  inline ::std::string* mutable_last_modified_product_version();
  inline ::std::string* release_last_modified_product_version();
  inline void set_allocated_last_modified_product_version(::std::string* last_modified_product_version);

  // optional uint64 last_modified_time = 3 [default = 0];
  inline bool has_last_modified_time() const;
  inline void clear_last_modified_time();
  static const int kLastModifiedTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 last_modified_time() const;
  inline void set_last_modified_time(::google::protobuf::uint64 value);

  // optional string platform = 4 [default = ""];
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 4;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string ui_locale = 5 [default = ""];
  inline bool has_ui_locale() const;
  inline void clear_ui_locale();
  static const int kUiLocaleFieldNumber = 5;
  inline const ::std::string& ui_locale() const;
  inline void set_ui_locale(const ::std::string& value);
  inline void set_ui_locale(const char* value);
  inline void set_ui_locale(const char* value, size_t size);
  inline ::std::string* mutable_ui_locale();
  inline ::std::string* release_ui_locale();
  inline void set_allocated_ui_locale(::std::string* ui_locale);

  // optional bool upload_usage_stats = 6 [default = false];
  inline bool has_upload_usage_stats() const;
  inline void clear_upload_usage_stats();
  static const int kUploadUsageStatsFieldNumber = 6;
  inline bool upload_usage_stats() const;
  inline void set_upload_usage_stats(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
 private:
  inline void set_has_config_version();
  inline void clear_has_config_version();
  inline void set_has_last_modified_product_version();
  inline void clear_has_last_modified_product_version();
  inline void set_has_last_modified_time();
  inline void clear_has_last_modified_time();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_ui_locale();
  inline void clear_has_ui_locale();
  inline void set_has_upload_usage_stats();
  inline void clear_has_upload_usage_stats();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* last_modified_product_version_;
  static ::std::string* _default_last_modified_product_version_;
  ::google::protobuf::uint64 last_modified_time_;
  ::google::protobuf::uint32 config_version_;
  bool upload_usage_stats_;
  ::std::string* platform_;
  ::std::string* ui_locale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_config_2fconfig_2eproto();
  friend void protobuf_AssignDesc_config_2fconfig_2eproto();
  friend void protobuf_ShutdownFile_config_2fconfig_2eproto();

  void InitAsDefaultInstance();
  static GeneralConfig* default_instance_;
};
// -------------------------------------------------------------------

class OBSOLETE_SyncConfig : public ::google::protobuf::Message {
 public:
  OBSOLETE_SyncConfig();
  virtual ~OBSOLETE_SyncConfig();

  OBSOLETE_SyncConfig(const OBSOLETE_SyncConfig& from);

  inline OBSOLETE_SyncConfig& operator=(const OBSOLETE_SyncConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OBSOLETE_SyncConfig& default_instance();

  void Swap(OBSOLETE_SyncConfig* other);

  // implements Message ----------------------------------------------

  OBSOLETE_SyncConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OBSOLETE_SyncConfig& from);
  void MergeFrom(const OBSOLETE_SyncConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_config_sync = 1 [default = false];
  inline bool has_use_config_sync() const;
  inline void clear_use_config_sync();
  static const int kUseConfigSyncFieldNumber = 1;
  inline bool use_config_sync() const;
  inline void set_use_config_sync(bool value);

  // optional bool use_user_dictionary_sync = 2 [default = false];
  inline bool has_use_user_dictionary_sync() const;
  inline void clear_use_user_dictionary_sync();
  static const int kUseUserDictionarySyncFieldNumber = 2;
  inline bool use_user_dictionary_sync() const;
  inline void set_use_user_dictionary_sync(bool value);

  // optional bool use_user_history_sync = 3 [default = false];
  inline bool has_use_user_history_sync() const;
  inline void clear_use_user_history_sync();
  static const int kUseUserHistorySyncFieldNumber = 3;
  inline bool use_user_history_sync() const;
  inline void set_use_user_history_sync(bool value);

  // optional bool use_learning_preference_sync = 4 [default = false];
  inline bool has_use_learning_preference_sync() const;
  inline void clear_use_learning_preference_sync();
  static const int kUseLearningPreferenceSyncFieldNumber = 4;
  inline bool use_learning_preference_sync() const;
  inline void set_use_learning_preference_sync(bool value);

  // optional bool use_contact_list_sync = 5 [default = false];
  inline bool has_use_contact_list_sync() const;
  inline void clear_use_contact_list_sync();
  static const int kUseContactListSyncFieldNumber = 5;
  inline bool use_contact_list_sync() const;
  inline void set_use_contact_list_sync(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.OBSOLETE_SyncConfig)
 private:
  inline void set_has_use_config_sync();
  inline void clear_has_use_config_sync();
  inline void set_has_use_user_dictionary_sync();
  inline void clear_has_use_user_dictionary_sync();
  inline void set_has_use_user_history_sync();
  inline void clear_has_use_user_history_sync();
  inline void set_has_use_learning_preference_sync();
  inline void clear_has_use_learning_preference_sync();
  inline void set_has_use_contact_list_sync();
  inline void clear_has_use_contact_list_sync();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool use_config_sync_;
  bool use_user_dictionary_sync_;
  bool use_user_history_sync_;
  bool use_learning_preference_sync_;
  bool use_contact_list_sync_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_config_2fconfig_2eproto();
  friend void protobuf_AssignDesc_config_2fconfig_2eproto();
  friend void protobuf_ShutdownFile_config_2fconfig_2eproto();

  void InitAsDefaultInstance();
  static OBSOLETE_SyncConfig* default_instance_;
};
// -------------------------------------------------------------------

class Config_CharacterFormRule : public ::google::protobuf::Message {
 public:
  Config_CharacterFormRule();
  virtual ~Config_CharacterFormRule();

  Config_CharacterFormRule(const Config_CharacterFormRule& from);

  inline Config_CharacterFormRule& operator=(const Config_CharacterFormRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config_CharacterFormRule& default_instance();

  void Swap(Config_CharacterFormRule* other);

  // implements Message ----------------------------------------------

  Config_CharacterFormRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config_CharacterFormRule& from);
  void MergeFrom(const Config_CharacterFormRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
  inline bool has_preedit_character_form() const;
  inline void clear_preedit_character_form();
  static const int kPreeditCharacterFormFieldNumber = 2;
  inline ::mozc::config::Config_CharacterForm preedit_character_form() const;
  inline void set_preedit_character_form(::mozc::config::Config_CharacterForm value);

  // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
  inline bool has_conversion_character_form() const;
  inline void clear_conversion_character_form();
  static const int kConversionCharacterFormFieldNumber = 3;
  inline ::mozc::config::Config_CharacterForm conversion_character_form() const;
  inline void set_conversion_character_form(::mozc::config::Config_CharacterForm value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_preedit_character_form();
  inline void clear_has_preedit_character_form();
  inline void set_has_conversion_character_form();
  inline void clear_has_conversion_character_form();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* group_;
  int preedit_character_form_;
  int conversion_character_form_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_config_2fconfig_2eproto();
  friend void protobuf_AssignDesc_config_2fconfig_2eproto();
  friend void protobuf_ShutdownFile_config_2fconfig_2eproto();

  void InitAsDefaultInstance();
  static Config_CharacterFormRule* default_instance_;
};
// -------------------------------------------------------------------

class Config_InformationListConfig : public ::google::protobuf::Message {
 public:
  Config_InformationListConfig();
  virtual ~Config_InformationListConfig();

  Config_InformationListConfig(const Config_InformationListConfig& from);

  inline Config_InformationListConfig& operator=(const Config_InformationListConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config_InformationListConfig& default_instance();

  void Swap(Config_InformationListConfig* other);

  // implements Message ----------------------------------------------

  Config_InformationListConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config_InformationListConfig& from);
  void MergeFrom(const Config_InformationListConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_local_usage_dictionary = 1 [default = true];
  inline bool has_use_local_usage_dictionary() const;
  inline void clear_use_local_usage_dictionary();
  static const int kUseLocalUsageDictionaryFieldNumber = 1;
  inline bool use_local_usage_dictionary() const;
  inline void set_use_local_usage_dictionary(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
 private:
  inline void set_has_use_local_usage_dictionary();
  inline void clear_has_use_local_usage_dictionary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool use_local_usage_dictionary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_config_2fconfig_2eproto();
  friend void protobuf_AssignDesc_config_2fconfig_2eproto();
  friend void protobuf_ShutdownFile_config_2fconfig_2eproto();

  void InitAsDefaultInstance();
  static Config_InformationListConfig* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Config_CharacterFormRule CharacterFormRule;
  typedef Config_InformationListConfig InformationListConfig;

  typedef Config_PreeditMethod PreeditMethod;
  static const PreeditMethod ROMAN = Config_PreeditMethod_ROMAN;
  static const PreeditMethod KANA = Config_PreeditMethod_KANA;
  static inline bool PreeditMethod_IsValid(int value) {
    return Config_PreeditMethod_IsValid(value);
  }
  static const PreeditMethod PreeditMethod_MIN =
    Config_PreeditMethod_PreeditMethod_MIN;
  static const PreeditMethod PreeditMethod_MAX =
    Config_PreeditMethod_PreeditMethod_MAX;
  static const int PreeditMethod_ARRAYSIZE =
    Config_PreeditMethod_PreeditMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PreeditMethod_descriptor() {
    return Config_PreeditMethod_descriptor();
  }
  static inline const ::std::string& PreeditMethod_Name(PreeditMethod value) {
    return Config_PreeditMethod_Name(value);
  }
  static inline bool PreeditMethod_Parse(const ::std::string& name,
      PreeditMethod* value) {
    return Config_PreeditMethod_Parse(name, value);
  }

  typedef Config_SessionKeymap SessionKeymap;
  static const SessionKeymap NONE = Config_SessionKeymap_NONE;
  static const SessionKeymap CUSTOM = Config_SessionKeymap_CUSTOM;
  static const SessionKeymap ATOK = Config_SessionKeymap_ATOK;
  static const SessionKeymap MSIME = Config_SessionKeymap_MSIME;
  static const SessionKeymap KOTOERI = Config_SessionKeymap_KOTOERI;
  static const SessionKeymap MOBILE = Config_SessionKeymap_MOBILE;
  static const SessionKeymap CHROMEOS = Config_SessionKeymap_CHROMEOS;
  static inline bool SessionKeymap_IsValid(int value) {
    return Config_SessionKeymap_IsValid(value);
  }
  static const SessionKeymap SessionKeymap_MIN =
    Config_SessionKeymap_SessionKeymap_MIN;
  static const SessionKeymap SessionKeymap_MAX =
    Config_SessionKeymap_SessionKeymap_MAX;
  static const int SessionKeymap_ARRAYSIZE =
    Config_SessionKeymap_SessionKeymap_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SessionKeymap_descriptor() {
    return Config_SessionKeymap_descriptor();
  }
  static inline const ::std::string& SessionKeymap_Name(SessionKeymap value) {
    return Config_SessionKeymap_Name(value);
  }
  static inline bool SessionKeymap_Parse(const ::std::string& name,
      SessionKeymap* value) {
    return Config_SessionKeymap_Parse(name, value);
  }

  typedef Config_PunctuationMethod PunctuationMethod;
  static const PunctuationMethod KUTEN_TOUTEN = Config_PunctuationMethod_KUTEN_TOUTEN;
  static const PunctuationMethod COMMA_PERIOD = Config_PunctuationMethod_COMMA_PERIOD;
  static const PunctuationMethod KUTEN_PERIOD = Config_PunctuationMethod_KUTEN_PERIOD;
  static const PunctuationMethod COMMA_TOUTEN = Config_PunctuationMethod_COMMA_TOUTEN;
  static inline bool PunctuationMethod_IsValid(int value) {
    return Config_PunctuationMethod_IsValid(value);
  }
  static const PunctuationMethod PunctuationMethod_MIN =
    Config_PunctuationMethod_PunctuationMethod_MIN;
  static const PunctuationMethod PunctuationMethod_MAX =
    Config_PunctuationMethod_PunctuationMethod_MAX;
  static const int PunctuationMethod_ARRAYSIZE =
    Config_PunctuationMethod_PunctuationMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PunctuationMethod_descriptor() {
    return Config_PunctuationMethod_descriptor();
  }
  static inline const ::std::string& PunctuationMethod_Name(PunctuationMethod value) {
    return Config_PunctuationMethod_Name(value);
  }
  static inline bool PunctuationMethod_Parse(const ::std::string& name,
      PunctuationMethod* value) {
    return Config_PunctuationMethod_Parse(name, value);
  }

  typedef Config_SymbolMethod SymbolMethod;
  static const SymbolMethod CORNER_BRACKET_MIDDLE_DOT = Config_SymbolMethod_CORNER_BRACKET_MIDDLE_DOT;
  static const SymbolMethod SQUARE_BRACKET_SLASH = Config_SymbolMethod_SQUARE_BRACKET_SLASH;
  static const SymbolMethod CORNER_BRACKET_SLASH = Config_SymbolMethod_CORNER_BRACKET_SLASH;
  static const SymbolMethod SQUARE_BRACKET_MIDDLE_DOT = Config_SymbolMethod_SQUARE_BRACKET_MIDDLE_DOT;
  static inline bool SymbolMethod_IsValid(int value) {
    return Config_SymbolMethod_IsValid(value);
  }
  static const SymbolMethod SymbolMethod_MIN =
    Config_SymbolMethod_SymbolMethod_MIN;
  static const SymbolMethod SymbolMethod_MAX =
    Config_SymbolMethod_SymbolMethod_MAX;
  static const int SymbolMethod_ARRAYSIZE =
    Config_SymbolMethod_SymbolMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SymbolMethod_descriptor() {
    return Config_SymbolMethod_descriptor();
  }
  static inline const ::std::string& SymbolMethod_Name(SymbolMethod value) {
    return Config_SymbolMethod_Name(value);
  }
  static inline bool SymbolMethod_Parse(const ::std::string& name,
      SymbolMethod* value) {
    return Config_SymbolMethod_Parse(name, value);
  }

  typedef Config_FundamentalCharacterForm FundamentalCharacterForm;
  static const FundamentalCharacterForm FUNDAMENTAL_INPUT_MODE = Config_FundamentalCharacterForm_FUNDAMENTAL_INPUT_MODE;
  static const FundamentalCharacterForm FUNDAMENTAL_FULL_WIDTH = Config_FundamentalCharacterForm_FUNDAMENTAL_FULL_WIDTH;
  static const FundamentalCharacterForm FUNDAMENTAL_HALF_WIDTH = Config_FundamentalCharacterForm_FUNDAMENTAL_HALF_WIDTH;
  static inline bool FundamentalCharacterForm_IsValid(int value) {
    return Config_FundamentalCharacterForm_IsValid(value);
  }
  static const FundamentalCharacterForm FundamentalCharacterForm_MIN =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MIN;
  static const FundamentalCharacterForm FundamentalCharacterForm_MAX =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_MAX;
  static const int FundamentalCharacterForm_ARRAYSIZE =
    Config_FundamentalCharacterForm_FundamentalCharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FundamentalCharacterForm_descriptor() {
    return Config_FundamentalCharacterForm_descriptor();
  }
  static inline const ::std::string& FundamentalCharacterForm_Name(FundamentalCharacterForm value) {
    return Config_FundamentalCharacterForm_Name(value);
  }
  static inline bool FundamentalCharacterForm_Parse(const ::std::string& name,
      FundamentalCharacterForm* value) {
    return Config_FundamentalCharacterForm_Parse(name, value);
  }

  typedef Config_HistoryLearningLevel HistoryLearningLevel;
  static const HistoryLearningLevel DEFAULT_HISTORY = Config_HistoryLearningLevel_DEFAULT_HISTORY;
  static const HistoryLearningLevel READ_ONLY = Config_HistoryLearningLevel_READ_ONLY;
  static const HistoryLearningLevel NO_HISTORY = Config_HistoryLearningLevel_NO_HISTORY;
  static inline bool HistoryLearningLevel_IsValid(int value) {
    return Config_HistoryLearningLevel_IsValid(value);
  }
  static const HistoryLearningLevel HistoryLearningLevel_MIN =
    Config_HistoryLearningLevel_HistoryLearningLevel_MIN;
  static const HistoryLearningLevel HistoryLearningLevel_MAX =
    Config_HistoryLearningLevel_HistoryLearningLevel_MAX;
  static const int HistoryLearningLevel_ARRAYSIZE =
    Config_HistoryLearningLevel_HistoryLearningLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HistoryLearningLevel_descriptor() {
    return Config_HistoryLearningLevel_descriptor();
  }
  static inline const ::std::string& HistoryLearningLevel_Name(HistoryLearningLevel value) {
    return Config_HistoryLearningLevel_Name(value);
  }
  static inline bool HistoryLearningLevel_Parse(const ::std::string& name,
      HistoryLearningLevel* value) {
    return Config_HistoryLearningLevel_Parse(name, value);
  }

  typedef Config_SelectionShortcut SelectionShortcut;
  static const SelectionShortcut NO_SHORTCUT = Config_SelectionShortcut_NO_SHORTCUT;
  static const SelectionShortcut SHORTCUT_123456789 = Config_SelectionShortcut_SHORTCUT_123456789;
  static const SelectionShortcut SHORTCUT_ASDFGHJKL = Config_SelectionShortcut_SHORTCUT_ASDFGHJKL;
  static inline bool SelectionShortcut_IsValid(int value) {
    return Config_SelectionShortcut_IsValid(value);
  }
  static const SelectionShortcut SelectionShortcut_MIN =
    Config_SelectionShortcut_SelectionShortcut_MIN;
  static const SelectionShortcut SelectionShortcut_MAX =
    Config_SelectionShortcut_SelectionShortcut_MAX;
  static const int SelectionShortcut_ARRAYSIZE =
    Config_SelectionShortcut_SelectionShortcut_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SelectionShortcut_descriptor() {
    return Config_SelectionShortcut_descriptor();
  }
  static inline const ::std::string& SelectionShortcut_Name(SelectionShortcut value) {
    return Config_SelectionShortcut_Name(value);
  }
  static inline bool SelectionShortcut_Parse(const ::std::string& name,
      SelectionShortcut* value) {
    return Config_SelectionShortcut_Parse(name, value);
  }

  typedef Config_CharacterForm CharacterForm;
  static const CharacterForm HALF_WIDTH = Config_CharacterForm_HALF_WIDTH;
  static const CharacterForm FULL_WIDTH = Config_CharacterForm_FULL_WIDTH;
  static const CharacterForm LAST_FORM = Config_CharacterForm_LAST_FORM;
  static const CharacterForm NO_CONVERSION = Config_CharacterForm_NO_CONVERSION;
  static inline bool CharacterForm_IsValid(int value) {
    return Config_CharacterForm_IsValid(value);
  }
  static const CharacterForm CharacterForm_MIN =
    Config_CharacterForm_CharacterForm_MIN;
  static const CharacterForm CharacterForm_MAX =
    Config_CharacterForm_CharacterForm_MAX;
  static const int CharacterForm_ARRAYSIZE =
    Config_CharacterForm_CharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CharacterForm_descriptor() {
    return Config_CharacterForm_descriptor();
  }
  static inline const ::std::string& CharacterForm_Name(CharacterForm value) {
    return Config_CharacterForm_Name(value);
  }
  static inline bool CharacterForm_Parse(const ::std::string& name,
      CharacterForm* value) {
    return Config_CharacterForm_Parse(name, value);
  }

  typedef Config_ShiftKeyModeSwitch ShiftKeyModeSwitch;
  static const ShiftKeyModeSwitch OFF = Config_ShiftKeyModeSwitch_OFF;
  static const ShiftKeyModeSwitch ASCII_INPUT_MODE = Config_ShiftKeyModeSwitch_ASCII_INPUT_MODE;
  static const ShiftKeyModeSwitch KATAKANA_INPUT_MODE = Config_ShiftKeyModeSwitch_KATAKANA_INPUT_MODE;
  static inline bool ShiftKeyModeSwitch_IsValid(int value) {
    return Config_ShiftKeyModeSwitch_IsValid(value);
  }
  static const ShiftKeyModeSwitch ShiftKeyModeSwitch_MIN =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MIN;
  static const ShiftKeyModeSwitch ShiftKeyModeSwitch_MAX =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_MAX;
  static const int ShiftKeyModeSwitch_ARRAYSIZE =
    Config_ShiftKeyModeSwitch_ShiftKeyModeSwitch_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShiftKeyModeSwitch_descriptor() {
    return Config_ShiftKeyModeSwitch_descriptor();
  }
  static inline const ::std::string& ShiftKeyModeSwitch_Name(ShiftKeyModeSwitch value) {
    return Config_ShiftKeyModeSwitch_Name(value);
  }
  static inline bool ShiftKeyModeSwitch_Parse(const ::std::string& name,
      ShiftKeyModeSwitch* value) {
    return Config_ShiftKeyModeSwitch_Parse(name, value);
  }

  typedef Config_NumpadCharacterForm NumpadCharacterForm;
  static const NumpadCharacterForm NUMPAD_INPUT_MODE = Config_NumpadCharacterForm_NUMPAD_INPUT_MODE;
  static const NumpadCharacterForm NUMPAD_FULL_WIDTH = Config_NumpadCharacterForm_NUMPAD_FULL_WIDTH;
  static const NumpadCharacterForm NUMPAD_HALF_WIDTH = Config_NumpadCharacterForm_NUMPAD_HALF_WIDTH;
  static const NumpadCharacterForm NUMPAD_DIRECT_INPUT = Config_NumpadCharacterForm_NUMPAD_DIRECT_INPUT;
  static inline bool NumpadCharacterForm_IsValid(int value) {
    return Config_NumpadCharacterForm_IsValid(value);
  }
  static const NumpadCharacterForm NumpadCharacterForm_MIN =
    Config_NumpadCharacterForm_NumpadCharacterForm_MIN;
  static const NumpadCharacterForm NumpadCharacterForm_MAX =
    Config_NumpadCharacterForm_NumpadCharacterForm_MAX;
  static const int NumpadCharacterForm_ARRAYSIZE =
    Config_NumpadCharacterForm_NumpadCharacterForm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NumpadCharacterForm_descriptor() {
    return Config_NumpadCharacterForm_descriptor();
  }
  static inline const ::std::string& NumpadCharacterForm_Name(NumpadCharacterForm value) {
    return Config_NumpadCharacterForm_Name(value);
  }
  static inline bool NumpadCharacterForm_Parse(const ::std::string& name,
      NumpadCharacterForm* value) {
    return Config_NumpadCharacterForm_Parse(name, value);
  }

  typedef Config_AutoConversionKey AutoConversionKey;
  static const AutoConversionKey AUTO_CONVERSION_OFF = Config_AutoConversionKey_AUTO_CONVERSION_OFF;
  static const AutoConversionKey AUTO_CONVERSION_KUTEN = Config_AutoConversionKey_AUTO_CONVERSION_KUTEN;
  static const AutoConversionKey AUTO_CONVERSION_TOUTEN = Config_AutoConversionKey_AUTO_CONVERSION_TOUTEN;
  static const AutoConversionKey AUTO_CONVERSION_QUESTION_MARK = Config_AutoConversionKey_AUTO_CONVERSION_QUESTION_MARK;
  static const AutoConversionKey AUTO_CONVERSION_EXCLAMATION_MARK = Config_AutoConversionKey_AUTO_CONVERSION_EXCLAMATION_MARK;
  static inline bool AutoConversionKey_IsValid(int value) {
    return Config_AutoConversionKey_IsValid(value);
  }
  static const AutoConversionKey AutoConversionKey_MIN =
    Config_AutoConversionKey_AutoConversionKey_MIN;
  static const AutoConversionKey AutoConversionKey_MAX =
    Config_AutoConversionKey_AutoConversionKey_MAX;
  static const int AutoConversionKey_ARRAYSIZE =
    Config_AutoConversionKey_AutoConversionKey_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AutoConversionKey_descriptor() {
    return Config_AutoConversionKey_descriptor();
  }
  static inline const ::std::string& AutoConversionKey_Name(AutoConversionKey value) {
    return Config_AutoConversionKey_Name(value);
  }
  static inline bool AutoConversionKey_Parse(const ::std::string& name,
      AutoConversionKey* value) {
    return Config_AutoConversionKey_Parse(name, value);
  }

  typedef Config_YenSignCharacter YenSignCharacter;
  static const YenSignCharacter YEN_SIGN = Config_YenSignCharacter_YEN_SIGN;
  static const YenSignCharacter BACKSLASH = Config_YenSignCharacter_BACKSLASH;
  static inline bool YenSignCharacter_IsValid(int value) {
    return Config_YenSignCharacter_IsValid(value);
  }
  static const YenSignCharacter YenSignCharacter_MIN =
    Config_YenSignCharacter_YenSignCharacter_MIN;
  static const YenSignCharacter YenSignCharacter_MAX =
    Config_YenSignCharacter_YenSignCharacter_MAX;
  static const int YenSignCharacter_ARRAYSIZE =
    Config_YenSignCharacter_YenSignCharacter_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  YenSignCharacter_descriptor() {
    return Config_YenSignCharacter_descriptor();
  }
  static inline const ::std::string& YenSignCharacter_Name(YenSignCharacter value) {
    return Config_YenSignCharacter_Name(value);
  }
  static inline bool YenSignCharacter_Parse(const ::std::string& name,
      YenSignCharacter* value) {
    return Config_YenSignCharacter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .mozc.config.GeneralConfig general_config = 1;
  inline bool has_general_config() const;
  inline void clear_general_config();
  static const int kGeneralConfigFieldNumber = 1;
  inline const ::mozc::config::GeneralConfig& general_config() const;
  inline ::mozc::config::GeneralConfig* mutable_general_config();
  inline ::mozc::config::GeneralConfig* release_general_config();
  inline void set_allocated_general_config(::mozc::config::GeneralConfig* general_config);

  // optional int32 verbose_level = 10 [default = 0];
  inline bool has_verbose_level() const;
  inline void clear_verbose_level();
  static const int kVerboseLevelFieldNumber = 10;
  inline ::google::protobuf::int32 verbose_level() const;
  inline void set_verbose_level(::google::protobuf::int32 value);

  // optional bool DEPRECATED_log_all_commands = 11 [default = false];
  inline bool has_deprecated_log_all_commands() const;
  inline void clear_deprecated_log_all_commands();
  static const int kDEPRECATEDLogAllCommandsFieldNumber = 11;
  inline bool deprecated_log_all_commands() const;
  inline void set_deprecated_log_all_commands(bool value);

  // optional bool incognito_mode = 20 [default = false];
  inline bool has_incognito_mode() const;
  inline void clear_incognito_mode();
  static const int kIncognitoModeFieldNumber = 20;
  inline bool incognito_mode() const;
  inline void set_incognito_mode(bool value);

  // optional bool check_default = 22 [default = true];
  inline bool has_check_default() const;
  inline void clear_check_default();
  static const int kCheckDefaultFieldNumber = 22;
  inline bool check_default() const;
  inline void set_check_default(bool value);

  // optional bool presentation_mode = 23 [default = false];
  inline bool has_presentation_mode() const;
  inline void clear_presentation_mode();
  static const int kPresentationModeFieldNumber = 23;
  inline bool presentation_mode() const;
  inline void set_presentation_mode(bool value);

  // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
  inline bool has_preedit_method() const;
  inline void clear_preedit_method();
  static const int kPreeditMethodFieldNumber = 40;
  inline ::mozc::config::Config_PreeditMethod preedit_method() const;
  inline void set_preedit_method(::mozc::config::Config_PreeditMethod value);

  // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
  inline bool has_session_keymap() const;
  inline void clear_session_keymap();
  static const int kSessionKeymapFieldNumber = 41;
  inline ::mozc::config::Config_SessionKeymap session_keymap() const;
  inline void set_session_keymap(::mozc::config::Config_SessionKeymap value);

  // optional bytes custom_keymap_table = 42;
  inline bool has_custom_keymap_table() const;
  inline void clear_custom_keymap_table();
  static const int kCustomKeymapTableFieldNumber = 42;
  inline const ::std::string& custom_keymap_table() const;
  inline void set_custom_keymap_table(const ::std::string& value);
  inline void set_custom_keymap_table(const char* value);
  inline void set_custom_keymap_table(const void* value, size_t size);
  inline ::std::string* mutable_custom_keymap_table();
  inline ::std::string* release_custom_keymap_table();
  inline void set_allocated_custom_keymap_table(::std::string* custom_keymap_table);

  // optional bytes custom_roman_table = 43;
  inline bool has_custom_roman_table() const;
  inline void clear_custom_roman_table();
  static const int kCustomRomanTableFieldNumber = 43;
  inline const ::std::string& custom_roman_table() const;
  inline void set_custom_roman_table(const ::std::string& value);
  inline void set_custom_roman_table(const char* value);
  inline void set_custom_roman_table(const void* value, size_t size);
  inline ::std::string* mutable_custom_roman_table();
  inline ::std::string* release_custom_roman_table();
  inline void set_allocated_custom_roman_table(::std::string* custom_roman_table);

  // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
  inline bool has_punctuation_method() const;
  inline void clear_punctuation_method();
  static const int kPunctuationMethodFieldNumber = 45;
  inline ::mozc::config::Config_PunctuationMethod punctuation_method() const;
  inline void set_punctuation_method(::mozc::config::Config_PunctuationMethod value);

  // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
  inline bool has_symbol_method() const;
  inline void clear_symbol_method();
  static const int kSymbolMethodFieldNumber = 46;
  inline ::mozc::config::Config_SymbolMethod symbol_method() const;
  inline void set_symbol_method(::mozc::config::Config_SymbolMethod value);

  // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
  inline bool has_space_character_form() const;
  inline void clear_space_character_form();
  static const int kSpaceCharacterFormFieldNumber = 47;
  inline ::mozc::config::Config_FundamentalCharacterForm space_character_form() const;
  inline void set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value);

  // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
  inline bool has_use_keyboard_to_change_preedit_method() const;
  inline void clear_use_keyboard_to_change_preedit_method();
  static const int kUseKeyboardToChangePreeditMethodFieldNumber = 48;
  inline bool use_keyboard_to_change_preedit_method() const;
  inline void set_use_keyboard_to_change_preedit_method(bool value);

  // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
  inline bool has_history_learning_level() const;
  inline void clear_history_learning_level();
  static const int kHistoryLearningLevelFieldNumber = 50;
  inline ::mozc::config::Config_HistoryLearningLevel history_learning_level() const;
  inline void set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value);

  // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
  inline bool has_selection_shortcut() const;
  inline void clear_selection_shortcut();
  static const int kSelectionShortcutFieldNumber = 52;
  inline ::mozc::config::Config_SelectionShortcut selection_shortcut() const;
  inline void set_selection_shortcut(::mozc::config::Config_SelectionShortcut value);

  // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
  inline int character_form_rules_size() const;
  inline void clear_character_form_rules();
  static const int kCharacterFormRulesFieldNumber = 54;
  inline const ::mozc::config::Config_CharacterFormRule& character_form_rules(int index) const;
  inline ::mozc::config::Config_CharacterFormRule* mutable_character_form_rules(int index);
  inline ::mozc::config::Config_CharacterFormRule* add_character_form_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
      character_form_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
      mutable_character_form_rules();

  // optional bool use_auto_ime_turn_off = 56 [default = true];
  inline bool has_use_auto_ime_turn_off() const;
  inline void clear_use_auto_ime_turn_off();
  static const int kUseAutoImeTurnOffFieldNumber = 56;
  inline bool use_auto_ime_turn_off() const;
  inline void set_use_auto_ime_turn_off(bool value);

  // optional bool use_cascading_window = 58 [default = true];
  inline bool has_use_cascading_window() const;
  inline void clear_use_cascading_window();
  static const int kUseCascadingWindowFieldNumber = 58;
  inline bool use_cascading_window() const;
  inline void set_use_cascading_window(bool value);

  // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
  inline bool has_shift_key_mode_switch() const;
  inline void clear_shift_key_mode_switch();
  static const int kShiftKeyModeSwitchFieldNumber = 59;
  inline ::mozc::config::Config_ShiftKeyModeSwitch shift_key_mode_switch() const;
  inline void set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value);

  // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
  inline bool has_numpad_character_form() const;
  inline void clear_numpad_character_form();
  static const int kNumpadCharacterFormFieldNumber = 60;
  inline ::mozc::config::Config_NumpadCharacterForm numpad_character_form() const;
  inline void set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value);

  // optional bool use_auto_conversion = 61 [default = false];
  inline bool has_use_auto_conversion() const;
  inline void clear_use_auto_conversion();
  static const int kUseAutoConversionFieldNumber = 61;
  inline bool use_auto_conversion() const;
  inline void set_use_auto_conversion(bool value);

  // optional uint32 auto_conversion_key = 62 [default = 13];
  inline bool has_auto_conversion_key() const;
  inline void clear_auto_conversion_key();
  static const int kAutoConversionKeyFieldNumber = 62;
  inline ::google::protobuf::uint32 auto_conversion_key() const;
  inline void set_auto_conversion_key(::google::protobuf::uint32 value);

  // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
  inline bool has_yen_sign_character() const;
  inline void clear_yen_sign_character();
  static const int kYenSignCharacterFieldNumber = 63;
  inline ::mozc::config::Config_YenSignCharacter yen_sign_character() const;
  inline void set_yen_sign_character(::mozc::config::Config_YenSignCharacter value);

  // optional bool use_japanese_layout = 64 [default = false];
  inline bool has_use_japanese_layout() const;
  inline void clear_use_japanese_layout();
  static const int kUseJapaneseLayoutFieldNumber = 64;
  inline bool use_japanese_layout() const;
  inline void set_use_japanese_layout(bool value);

  // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
  inline bool has_use_kana_modifier_insensitive_conversion() const;
  inline void clear_use_kana_modifier_insensitive_conversion();
  static const int kUseKanaModifierInsensitiveConversionFieldNumber = 65;
  inline bool use_kana_modifier_insensitive_conversion() const;
  inline void set_use_kana_modifier_insensitive_conversion(bool value);

  // optional bool use_typing_correction = 66 [default = false];
  inline bool has_use_typing_correction() const;
  inline void clear_use_typing_correction();
  static const int kUseTypingCorrectionFieldNumber = 66;
  inline bool use_typing_correction() const;
  inline void set_use_typing_correction(bool value);

  // optional bool use_date_conversion = 80 [default = true];
  inline bool has_use_date_conversion() const;
  inline void clear_use_date_conversion();
  static const int kUseDateConversionFieldNumber = 80;
  inline bool use_date_conversion() const;
  inline void set_use_date_conversion(bool value);

  // optional bool use_single_kanji_conversion = 81 [default = true];
  inline bool has_use_single_kanji_conversion() const;
  inline void clear_use_single_kanji_conversion();
  static const int kUseSingleKanjiConversionFieldNumber = 81;
  inline bool use_single_kanji_conversion() const;
  inline void set_use_single_kanji_conversion(bool value);

  // optional bool use_symbol_conversion = 82 [default = true];
  inline bool has_use_symbol_conversion() const;
  inline void clear_use_symbol_conversion();
  static const int kUseSymbolConversionFieldNumber = 82;
  inline bool use_symbol_conversion() const;
  inline void set_use_symbol_conversion(bool value);

  // optional bool use_number_conversion = 83 [default = true];
  inline bool has_use_number_conversion() const;
  inline void clear_use_number_conversion();
  static const int kUseNumberConversionFieldNumber = 83;
  inline bool use_number_conversion() const;
  inline void set_use_number_conversion(bool value);

  // optional bool use_emoticon_conversion = 84 [default = true];
  inline bool has_use_emoticon_conversion() const;
  inline void clear_use_emoticon_conversion();
  static const int kUseEmoticonConversionFieldNumber = 84;
  inline bool use_emoticon_conversion() const;
  inline void set_use_emoticon_conversion(bool value);

  // optional bool use_calculator = 85 [default = true];
  inline bool has_use_calculator() const;
  inline void clear_use_calculator();
  static const int kUseCalculatorFieldNumber = 85;
  inline bool use_calculator() const;
  inline void set_use_calculator(bool value);

  // optional bool use_t13n_conversion = 86 [default = true];
  inline bool has_use_t13n_conversion() const;
  inline void clear_use_t13n_conversion();
  static const int kUseT13NConversionFieldNumber = 86;
  inline bool use_t13n_conversion() const;
  inline void set_use_t13n_conversion(bool value);

  // optional bool use_zip_code_conversion = 87 [default = true];
  inline bool has_use_zip_code_conversion() const;
  inline void clear_use_zip_code_conversion();
  static const int kUseZipCodeConversionFieldNumber = 87;
  inline bool use_zip_code_conversion() const;
  inline void set_use_zip_code_conversion(bool value);

  // optional bool use_spelling_correction = 88 [default = true];
  inline bool has_use_spelling_correction() const;
  inline void clear_use_spelling_correction();
  static const int kUseSpellingCorrectionFieldNumber = 88;
  inline bool use_spelling_correction() const;
  inline void set_use_spelling_correction(bool value);

  // optional bool use_emoji_conversion = 89 [default = false];
  inline bool has_use_emoji_conversion() const;
  inline void clear_use_emoji_conversion();
  static const int kUseEmojiConversionFieldNumber = 89;
  inline bool use_emoji_conversion() const;
  inline void set_use_emoji_conversion(bool value);

  // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
  inline bool has_information_list_config() const;
  inline void clear_information_list_config();
  static const int kInformationListConfigFieldNumber = 90;
  inline const ::mozc::config::Config_InformationListConfig& information_list_config() const;
  inline ::mozc::config::Config_InformationListConfig* mutable_information_list_config();
  inline ::mozc::config::Config_InformationListConfig* release_information_list_config();
  inline void set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config);

  // optional bool use_history_suggest = 100 [default = true];
  inline bool has_use_history_suggest() const;
  inline void clear_use_history_suggest();
  static const int kUseHistorySuggestFieldNumber = 100;
  inline bool use_history_suggest() const;
  inline void set_use_history_suggest(bool value);

  // optional bool use_dictionary_suggest = 101 [default = true];
  inline bool has_use_dictionary_suggest() const;
  inline void clear_use_dictionary_suggest();
  static const int kUseDictionarySuggestFieldNumber = 101;
  inline bool use_dictionary_suggest() const;
  inline void set_use_dictionary_suggest(bool value);

  // optional bool use_realtime_conversion = 102 [default = true];
  inline bool has_use_realtime_conversion() const;
  inline void clear_use_realtime_conversion();
  static const int kUseRealtimeConversionFieldNumber = 102;
  inline bool use_realtime_conversion() const;
  inline void set_use_realtime_conversion(bool value);

  // optional uint32 suggestions_size = 110 [default = 3];
  inline bool has_suggestions_size() const;
  inline void clear_suggestions_size();
  static const int kSuggestionsSizeFieldNumber = 110;
  inline ::google::protobuf::uint32 suggestions_size() const;
  inline void set_suggestions_size(::google::protobuf::uint32 value);

  // optional bool use_mode_indicator = 120 [default = true];
  inline bool has_use_mode_indicator() const;
  inline void clear_use_mode_indicator();
  static const int kUseModeIndicatorFieldNumber = 120;
  inline bool use_mode_indicator() const;
  inline void set_use_mode_indicator(bool value);

  // optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;
  inline bool has_obsolete_sync_config() const;
  inline void clear_obsolete_sync_config();
  static const int kOBSOLETESyncConfigFieldNumber = 300;
  inline const ::mozc::config::OBSOLETE_SyncConfig& obsolete_sync_config() const;
  inline ::mozc::config::OBSOLETE_SyncConfig* mutable_obsolete_sync_config();
  inline ::mozc::config::OBSOLETE_SyncConfig* release_obsolete_sync_config();
  inline void set_allocated_obsolete_sync_config(::mozc::config::OBSOLETE_SyncConfig* obsolete_sync_config);

  // optional bool allow_cloud_handwriting = 301 [default = false];
  inline bool has_allow_cloud_handwriting() const;
  inline void clear_allow_cloud_handwriting();
  static const int kAllowCloudHandwritingFieldNumber = 301;
  inline bool allow_cloud_handwriting() const;
  inline void set_allow_cloud_handwriting(bool value);

  // @@protoc_insertion_point(class_scope:mozc.config.Config)
 private:
  inline void set_has_general_config();
  inline void clear_has_general_config();
  inline void set_has_verbose_level();
  inline void clear_has_verbose_level();
  inline void set_has_deprecated_log_all_commands();
  inline void clear_has_deprecated_log_all_commands();
  inline void set_has_incognito_mode();
  inline void clear_has_incognito_mode();
  inline void set_has_check_default();
  inline void clear_has_check_default();
  inline void set_has_presentation_mode();
  inline void clear_has_presentation_mode();
  inline void set_has_preedit_method();
  inline void clear_has_preedit_method();
  inline void set_has_session_keymap();
  inline void clear_has_session_keymap();
  inline void set_has_custom_keymap_table();
  inline void clear_has_custom_keymap_table();
  inline void set_has_custom_roman_table();
  inline void clear_has_custom_roman_table();
  inline void set_has_punctuation_method();
  inline void clear_has_punctuation_method();
  inline void set_has_symbol_method();
  inline void clear_has_symbol_method();
  inline void set_has_space_character_form();
  inline void clear_has_space_character_form();
  inline void set_has_use_keyboard_to_change_preedit_method();
  inline void clear_has_use_keyboard_to_change_preedit_method();
  inline void set_has_history_learning_level();
  inline void clear_has_history_learning_level();
  inline void set_has_selection_shortcut();
  inline void clear_has_selection_shortcut();
  inline void set_has_use_auto_ime_turn_off();
  inline void clear_has_use_auto_ime_turn_off();
  inline void set_has_use_cascading_window();
  inline void clear_has_use_cascading_window();
  inline void set_has_shift_key_mode_switch();
  inline void clear_has_shift_key_mode_switch();
  inline void set_has_numpad_character_form();
  inline void clear_has_numpad_character_form();
  inline void set_has_use_auto_conversion();
  inline void clear_has_use_auto_conversion();
  inline void set_has_auto_conversion_key();
  inline void clear_has_auto_conversion_key();
  inline void set_has_yen_sign_character();
  inline void clear_has_yen_sign_character();
  inline void set_has_use_japanese_layout();
  inline void clear_has_use_japanese_layout();
  inline void set_has_use_kana_modifier_insensitive_conversion();
  inline void clear_has_use_kana_modifier_insensitive_conversion();
  inline void set_has_use_typing_correction();
  inline void clear_has_use_typing_correction();
  inline void set_has_use_date_conversion();
  inline void clear_has_use_date_conversion();
  inline void set_has_use_single_kanji_conversion();
  inline void clear_has_use_single_kanji_conversion();
  inline void set_has_use_symbol_conversion();
  inline void clear_has_use_symbol_conversion();
  inline void set_has_use_number_conversion();
  inline void clear_has_use_number_conversion();
  inline void set_has_use_emoticon_conversion();
  inline void clear_has_use_emoticon_conversion();
  inline void set_has_use_calculator();
  inline void clear_has_use_calculator();
  inline void set_has_use_t13n_conversion();
  inline void clear_has_use_t13n_conversion();
  inline void set_has_use_zip_code_conversion();
  inline void clear_has_use_zip_code_conversion();
  inline void set_has_use_spelling_correction();
  inline void clear_has_use_spelling_correction();
  inline void set_has_use_emoji_conversion();
  inline void clear_has_use_emoji_conversion();
  inline void set_has_information_list_config();
  inline void clear_has_information_list_config();
  inline void set_has_use_history_suggest();
  inline void clear_has_use_history_suggest();
  inline void set_has_use_dictionary_suggest();
  inline void clear_has_use_dictionary_suggest();
  inline void set_has_use_realtime_conversion();
  inline void clear_has_use_realtime_conversion();
  inline void set_has_suggestions_size();
  inline void clear_has_suggestions_size();
  inline void set_has_use_mode_indicator();
  inline void clear_has_use_mode_indicator();
  inline void set_has_obsolete_sync_config();
  inline void clear_has_obsolete_sync_config();
  inline void set_has_allow_cloud_handwriting();
  inline void clear_has_allow_cloud_handwriting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mozc::config::GeneralConfig* general_config_;
  ::google::protobuf::int32 verbose_level_;
  bool deprecated_log_all_commands_;
  bool incognito_mode_;
  bool check_default_;
  bool presentation_mode_;
  int preedit_method_;
  int session_keymap_;
  ::std::string* custom_keymap_table_;
  ::std::string* custom_roman_table_;
  int punctuation_method_;
  int symbol_method_;
  int space_character_form_;
  int history_learning_level_;
  ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule > character_form_rules_;
  int selection_shortcut_;
  bool use_keyboard_to_change_preedit_method_;
  bool use_auto_ime_turn_off_;
  bool use_cascading_window_;
  bool use_auto_conversion_;
  int shift_key_mode_switch_;
  int numpad_character_form_;
  ::google::protobuf::uint32 auto_conversion_key_;
  int yen_sign_character_;
  bool use_japanese_layout_;
  bool use_kana_modifier_insensitive_conversion_;
  bool use_typing_correction_;
  bool use_date_conversion_;
  bool use_single_kanji_conversion_;
  bool use_symbol_conversion_;
  bool use_number_conversion_;
  bool use_emoticon_conversion_;
  bool use_calculator_;
  bool use_t13n_conversion_;
  bool use_zip_code_conversion_;
  bool use_spelling_correction_;
  bool use_emoji_conversion_;
  bool use_history_suggest_;
  bool use_dictionary_suggest_;
  bool use_realtime_conversion_;
  ::mozc::config::Config_InformationListConfig* information_list_config_;
  ::google::protobuf::uint32 suggestions_size_;
  bool use_mode_indicator_;
  bool allow_cloud_handwriting_;
  ::mozc::config::OBSOLETE_SyncConfig* obsolete_sync_config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(45 + 31) / 32];

  friend void  protobuf_AddDesc_config_2fconfig_2eproto();
  friend void protobuf_AssignDesc_config_2fconfig_2eproto();
  friend void protobuf_ShutdownFile_config_2fconfig_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// ===================================================================


// ===================================================================

// GeneralConfig

// optional uint32 config_version = 1 [default = 0];
inline bool GeneralConfig::has_config_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralConfig::set_has_config_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralConfig::clear_has_config_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralConfig::clear_config_version() {
  config_version_ = 0u;
  clear_has_config_version();
}
inline ::google::protobuf::uint32 GeneralConfig::config_version() const {
  return config_version_;
}
inline void GeneralConfig::set_config_version(::google::protobuf::uint32 value) {
  set_has_config_version();
  config_version_ = value;
}

// optional string last_modified_product_version = 2 [default = "0.0.0.0"];
inline bool GeneralConfig::has_last_modified_product_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GeneralConfig::set_has_last_modified_product_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GeneralConfig::clear_has_last_modified_product_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GeneralConfig::clear_last_modified_product_version() {
  if (last_modified_product_version_ != _default_last_modified_product_version_) {
    last_modified_product_version_->assign(*_default_last_modified_product_version_);
  }
  clear_has_last_modified_product_version();
}
inline const ::std::string& GeneralConfig::last_modified_product_version() const {
  return *last_modified_product_version_;
}
inline void GeneralConfig::set_last_modified_product_version(const ::std::string& value) {
  set_has_last_modified_product_version();
  if (last_modified_product_version_ == _default_last_modified_product_version_) {
    last_modified_product_version_ = new ::std::string;
  }
  last_modified_product_version_->assign(value);
}
inline void GeneralConfig::set_last_modified_product_version(const char* value) {
  set_has_last_modified_product_version();
  if (last_modified_product_version_ == _default_last_modified_product_version_) {
    last_modified_product_version_ = new ::std::string;
  }
  last_modified_product_version_->assign(value);
}
inline void GeneralConfig::set_last_modified_product_version(const char* value, size_t size) {
  set_has_last_modified_product_version();
  if (last_modified_product_version_ == _default_last_modified_product_version_) {
    last_modified_product_version_ = new ::std::string;
  }
  last_modified_product_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralConfig::mutable_last_modified_product_version() {
  set_has_last_modified_product_version();
  if (last_modified_product_version_ == _default_last_modified_product_version_) {
    last_modified_product_version_ = new ::std::string(*_default_last_modified_product_version_);
  }
  return last_modified_product_version_;
}
inline ::std::string* GeneralConfig::release_last_modified_product_version() {
  clear_has_last_modified_product_version();
  if (last_modified_product_version_ == _default_last_modified_product_version_) {
    return NULL;
  } else {
    ::std::string* temp = last_modified_product_version_;
    last_modified_product_version_ = const_cast< ::std::string*>(_default_last_modified_product_version_);
    return temp;
  }
}
inline void GeneralConfig::set_allocated_last_modified_product_version(::std::string* last_modified_product_version) {
  if (last_modified_product_version_ != _default_last_modified_product_version_) {
    delete last_modified_product_version_;
  }
  if (last_modified_product_version) {
    set_has_last_modified_product_version();
    last_modified_product_version_ = last_modified_product_version;
  } else {
    clear_has_last_modified_product_version();
    last_modified_product_version_ = const_cast< ::std::string*>(_default_last_modified_product_version_);
  }
}

// optional uint64 last_modified_time = 3 [default = 0];
inline bool GeneralConfig::has_last_modified_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GeneralConfig::set_has_last_modified_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GeneralConfig::clear_has_last_modified_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GeneralConfig::clear_last_modified_time() {
  last_modified_time_ = GOOGLE_ULONGLONG(0);
  clear_has_last_modified_time();
}
inline ::google::protobuf::uint64 GeneralConfig::last_modified_time() const {
  return last_modified_time_;
}
inline void GeneralConfig::set_last_modified_time(::google::protobuf::uint64 value) {
  set_has_last_modified_time();
  last_modified_time_ = value;
}

// optional string platform = 4 [default = ""];
inline bool GeneralConfig::has_platform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GeneralConfig::set_has_platform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GeneralConfig::clear_has_platform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GeneralConfig::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& GeneralConfig::platform() const {
  return *platform_;
}
inline void GeneralConfig::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void GeneralConfig::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void GeneralConfig::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralConfig::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* GeneralConfig::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeneralConfig::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ui_locale = 5 [default = ""];
inline bool GeneralConfig::has_ui_locale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GeneralConfig::set_has_ui_locale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GeneralConfig::clear_has_ui_locale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GeneralConfig::clear_ui_locale() {
  if (ui_locale_ != &::google::protobuf::internal::kEmptyString) {
    ui_locale_->clear();
  }
  clear_has_ui_locale();
}
inline const ::std::string& GeneralConfig::ui_locale() const {
  return *ui_locale_;
}
inline void GeneralConfig::set_ui_locale(const ::std::string& value) {
  set_has_ui_locale();
  if (ui_locale_ == &::google::protobuf::internal::kEmptyString) {
    ui_locale_ = new ::std::string;
  }
  ui_locale_->assign(value);
}
inline void GeneralConfig::set_ui_locale(const char* value) {
  set_has_ui_locale();
  if (ui_locale_ == &::google::protobuf::internal::kEmptyString) {
    ui_locale_ = new ::std::string;
  }
  ui_locale_->assign(value);
}
inline void GeneralConfig::set_ui_locale(const char* value, size_t size) {
  set_has_ui_locale();
  if (ui_locale_ == &::google::protobuf::internal::kEmptyString) {
    ui_locale_ = new ::std::string;
  }
  ui_locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralConfig::mutable_ui_locale() {
  set_has_ui_locale();
  if (ui_locale_ == &::google::protobuf::internal::kEmptyString) {
    ui_locale_ = new ::std::string;
  }
  return ui_locale_;
}
inline ::std::string* GeneralConfig::release_ui_locale() {
  clear_has_ui_locale();
  if (ui_locale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ui_locale_;
    ui_locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GeneralConfig::set_allocated_ui_locale(::std::string* ui_locale) {
  if (ui_locale_ != &::google::protobuf::internal::kEmptyString) {
    delete ui_locale_;
  }
  if (ui_locale) {
    set_has_ui_locale();
    ui_locale_ = ui_locale;
  } else {
    clear_has_ui_locale();
    ui_locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool upload_usage_stats = 6 [default = false];
inline bool GeneralConfig::has_upload_usage_stats() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GeneralConfig::set_has_upload_usage_stats() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GeneralConfig::clear_has_upload_usage_stats() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GeneralConfig::clear_upload_usage_stats() {
  upload_usage_stats_ = false;
  clear_has_upload_usage_stats();
}
inline bool GeneralConfig::upload_usage_stats() const {
  return upload_usage_stats_;
}
inline void GeneralConfig::set_upload_usage_stats(bool value) {
  set_has_upload_usage_stats();
  upload_usage_stats_ = value;
}

// -------------------------------------------------------------------

// OBSOLETE_SyncConfig

// optional bool use_config_sync = 1 [default = false];
inline bool OBSOLETE_SyncConfig::has_use_config_sync() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OBSOLETE_SyncConfig::set_has_use_config_sync() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OBSOLETE_SyncConfig::clear_has_use_config_sync() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OBSOLETE_SyncConfig::clear_use_config_sync() {
  use_config_sync_ = false;
  clear_has_use_config_sync();
}
inline bool OBSOLETE_SyncConfig::use_config_sync() const {
  return use_config_sync_;
}
inline void OBSOLETE_SyncConfig::set_use_config_sync(bool value) {
  set_has_use_config_sync();
  use_config_sync_ = value;
}

// optional bool use_user_dictionary_sync = 2 [default = false];
inline bool OBSOLETE_SyncConfig::has_use_user_dictionary_sync() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OBSOLETE_SyncConfig::set_has_use_user_dictionary_sync() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OBSOLETE_SyncConfig::clear_has_use_user_dictionary_sync() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OBSOLETE_SyncConfig::clear_use_user_dictionary_sync() {
  use_user_dictionary_sync_ = false;
  clear_has_use_user_dictionary_sync();
}
inline bool OBSOLETE_SyncConfig::use_user_dictionary_sync() const {
  return use_user_dictionary_sync_;
}
inline void OBSOLETE_SyncConfig::set_use_user_dictionary_sync(bool value) {
  set_has_use_user_dictionary_sync();
  use_user_dictionary_sync_ = value;
}

// optional bool use_user_history_sync = 3 [default = false];
inline bool OBSOLETE_SyncConfig::has_use_user_history_sync() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OBSOLETE_SyncConfig::set_has_use_user_history_sync() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OBSOLETE_SyncConfig::clear_has_use_user_history_sync() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OBSOLETE_SyncConfig::clear_use_user_history_sync() {
  use_user_history_sync_ = false;
  clear_has_use_user_history_sync();
}
inline bool OBSOLETE_SyncConfig::use_user_history_sync() const {
  return use_user_history_sync_;
}
inline void OBSOLETE_SyncConfig::set_use_user_history_sync(bool value) {
  set_has_use_user_history_sync();
  use_user_history_sync_ = value;
}

// optional bool use_learning_preference_sync = 4 [default = false];
inline bool OBSOLETE_SyncConfig::has_use_learning_preference_sync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OBSOLETE_SyncConfig::set_has_use_learning_preference_sync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OBSOLETE_SyncConfig::clear_has_use_learning_preference_sync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OBSOLETE_SyncConfig::clear_use_learning_preference_sync() {
  use_learning_preference_sync_ = false;
  clear_has_use_learning_preference_sync();
}
inline bool OBSOLETE_SyncConfig::use_learning_preference_sync() const {
  return use_learning_preference_sync_;
}
inline void OBSOLETE_SyncConfig::set_use_learning_preference_sync(bool value) {
  set_has_use_learning_preference_sync();
  use_learning_preference_sync_ = value;
}

// optional bool use_contact_list_sync = 5 [default = false];
inline bool OBSOLETE_SyncConfig::has_use_contact_list_sync() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OBSOLETE_SyncConfig::set_has_use_contact_list_sync() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OBSOLETE_SyncConfig::clear_has_use_contact_list_sync() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OBSOLETE_SyncConfig::clear_use_contact_list_sync() {
  use_contact_list_sync_ = false;
  clear_has_use_contact_list_sync();
}
inline bool OBSOLETE_SyncConfig::use_contact_list_sync() const {
  return use_contact_list_sync_;
}
inline void OBSOLETE_SyncConfig::set_use_contact_list_sync(bool value) {
  set_has_use_contact_list_sync();
  use_contact_list_sync_ = value;
}

// -------------------------------------------------------------------

// Config_CharacterFormRule

// optional string group = 1;
inline bool Config_CharacterFormRule::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config_CharacterFormRule::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config_CharacterFormRule::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config_CharacterFormRule::clear_group() {
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    group_->clear();
  }
  clear_has_group();
}
inline const ::std::string& Config_CharacterFormRule::group() const {
  return *group_;
}
inline void Config_CharacterFormRule::set_group(const ::std::string& value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Config_CharacterFormRule::set_group(const char* value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Config_CharacterFormRule::set_group(const char* value, size_t size) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config_CharacterFormRule::mutable_group() {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  return group_;
}
inline ::std::string* Config_CharacterFormRule::release_group() {
  clear_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_;
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Config_CharacterFormRule::set_allocated_group(::std::string* group) {
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (group) {
    set_has_group();
    group_ = group;
  } else {
    clear_has_group();
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::has_preedit_character_form() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config_CharacterFormRule::set_has_preedit_character_form() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config_CharacterFormRule::clear_has_preedit_character_form() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config_CharacterFormRule::clear_preedit_character_form() {
  preedit_character_form_ = 1;
  clear_has_preedit_character_form();
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::preedit_character_form() const {
  return static_cast< ::mozc::config::Config_CharacterForm >(preedit_character_form_);
}
inline void Config_CharacterFormRule::set_preedit_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  set_has_preedit_character_form();
  preedit_character_form_ = value;
}

// optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
inline bool Config_CharacterFormRule::has_conversion_character_form() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config_CharacterFormRule::set_has_conversion_character_form() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config_CharacterFormRule::clear_has_conversion_character_form() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config_CharacterFormRule::clear_conversion_character_form() {
  conversion_character_form_ = 1;
  clear_has_conversion_character_form();
}
inline ::mozc::config::Config_CharacterForm Config_CharacterFormRule::conversion_character_form() const {
  return static_cast< ::mozc::config::Config_CharacterForm >(conversion_character_form_);
}
inline void Config_CharacterFormRule::set_conversion_character_form(::mozc::config::Config_CharacterForm value) {
  assert(::mozc::config::Config_CharacterForm_IsValid(value));
  set_has_conversion_character_form();
  conversion_character_form_ = value;
}

// -------------------------------------------------------------------

// Config_InformationListConfig

// optional bool use_local_usage_dictionary = 1 [default = true];
inline bool Config_InformationListConfig::has_use_local_usage_dictionary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config_InformationListConfig::set_has_use_local_usage_dictionary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config_InformationListConfig::clear_has_use_local_usage_dictionary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config_InformationListConfig::clear_use_local_usage_dictionary() {
  use_local_usage_dictionary_ = true;
  clear_has_use_local_usage_dictionary();
}
inline bool Config_InformationListConfig::use_local_usage_dictionary() const {
  return use_local_usage_dictionary_;
}
inline void Config_InformationListConfig::set_use_local_usage_dictionary(bool value) {
  set_has_use_local_usage_dictionary();
  use_local_usage_dictionary_ = value;
}

// -------------------------------------------------------------------

// Config

// optional .mozc.config.GeneralConfig general_config = 1;
inline bool Config::has_general_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_general_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_general_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_general_config() {
  if (general_config_ != NULL) general_config_->::mozc::config::GeneralConfig::Clear();
  clear_has_general_config();
}
inline const ::mozc::config::GeneralConfig& Config::general_config() const {
  return general_config_ != NULL ? *general_config_ : *default_instance_->general_config_;
}
inline ::mozc::config::GeneralConfig* Config::mutable_general_config() {
  set_has_general_config();
  if (general_config_ == NULL) general_config_ = new ::mozc::config::GeneralConfig;
  return general_config_;
}
inline ::mozc::config::GeneralConfig* Config::release_general_config() {
  clear_has_general_config();
  ::mozc::config::GeneralConfig* temp = general_config_;
  general_config_ = NULL;
  return temp;
}
inline void Config::set_allocated_general_config(::mozc::config::GeneralConfig* general_config) {
  delete general_config_;
  general_config_ = general_config;
  if (general_config) {
    set_has_general_config();
  } else {
    clear_has_general_config();
  }
}

// optional int32 verbose_level = 10 [default = 0];
inline bool Config::has_verbose_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_verbose_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_verbose_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_verbose_level() {
  verbose_level_ = 0;
  clear_has_verbose_level();
}
inline ::google::protobuf::int32 Config::verbose_level() const {
  return verbose_level_;
}
inline void Config::set_verbose_level(::google::protobuf::int32 value) {
  set_has_verbose_level();
  verbose_level_ = value;
}

// optional bool DEPRECATED_log_all_commands = 11 [default = false];
inline bool Config::has_deprecated_log_all_commands() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_deprecated_log_all_commands() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_deprecated_log_all_commands() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_deprecated_log_all_commands() {
  deprecated_log_all_commands_ = false;
  clear_has_deprecated_log_all_commands();
}
inline bool Config::deprecated_log_all_commands() const {
  return deprecated_log_all_commands_;
}
inline void Config::set_deprecated_log_all_commands(bool value) {
  set_has_deprecated_log_all_commands();
  deprecated_log_all_commands_ = value;
}

// optional bool incognito_mode = 20 [default = false];
inline bool Config::has_incognito_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_incognito_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_incognito_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_incognito_mode() {
  incognito_mode_ = false;
  clear_has_incognito_mode();
}
inline bool Config::incognito_mode() const {
  return incognito_mode_;
}
inline void Config::set_incognito_mode(bool value) {
  set_has_incognito_mode();
  incognito_mode_ = value;
}

// optional bool check_default = 22 [default = true];
inline bool Config::has_check_default() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_check_default() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_check_default() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_check_default() {
  check_default_ = true;
  clear_has_check_default();
}
inline bool Config::check_default() const {
  return check_default_;
}
inline void Config::set_check_default(bool value) {
  set_has_check_default();
  check_default_ = value;
}

// optional bool presentation_mode = 23 [default = false];
inline bool Config::has_presentation_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_presentation_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_presentation_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_presentation_mode() {
  presentation_mode_ = false;
  clear_has_presentation_mode();
}
inline bool Config::presentation_mode() const {
  return presentation_mode_;
}
inline void Config::set_presentation_mode(bool value) {
  set_has_presentation_mode();
  presentation_mode_ = value;
}

// optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
inline bool Config::has_preedit_method() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_preedit_method() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_preedit_method() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_preedit_method() {
  preedit_method_ = 0;
  clear_has_preedit_method();
}
inline ::mozc::config::Config_PreeditMethod Config::preedit_method() const {
  return static_cast< ::mozc::config::Config_PreeditMethod >(preedit_method_);
}
inline void Config::set_preedit_method(::mozc::config::Config_PreeditMethod value) {
  assert(::mozc::config::Config_PreeditMethod_IsValid(value));
  set_has_preedit_method();
  preedit_method_ = value;
}

// optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
inline bool Config::has_session_keymap() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Config::set_has_session_keymap() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Config::clear_has_session_keymap() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Config::clear_session_keymap() {
  session_keymap_ = -1;
  clear_has_session_keymap();
}
inline ::mozc::config::Config_SessionKeymap Config::session_keymap() const {
  return static_cast< ::mozc::config::Config_SessionKeymap >(session_keymap_);
}
inline void Config::set_session_keymap(::mozc::config::Config_SessionKeymap value) {
  assert(::mozc::config::Config_SessionKeymap_IsValid(value));
  set_has_session_keymap();
  session_keymap_ = value;
}

// optional bytes custom_keymap_table = 42;
inline bool Config::has_custom_keymap_table() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Config::set_has_custom_keymap_table() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Config::clear_has_custom_keymap_table() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Config::clear_custom_keymap_table() {
  if (custom_keymap_table_ != &::google::protobuf::internal::kEmptyString) {
    custom_keymap_table_->clear();
  }
  clear_has_custom_keymap_table();
}
inline const ::std::string& Config::custom_keymap_table() const {
  return *custom_keymap_table_;
}
inline void Config::set_custom_keymap_table(const ::std::string& value) {
  set_has_custom_keymap_table();
  if (custom_keymap_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_keymap_table_ = new ::std::string;
  }
  custom_keymap_table_->assign(value);
}
inline void Config::set_custom_keymap_table(const char* value) {
  set_has_custom_keymap_table();
  if (custom_keymap_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_keymap_table_ = new ::std::string;
  }
  custom_keymap_table_->assign(value);
}
inline void Config::set_custom_keymap_table(const void* value, size_t size) {
  set_has_custom_keymap_table();
  if (custom_keymap_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_keymap_table_ = new ::std::string;
  }
  custom_keymap_table_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_custom_keymap_table() {
  set_has_custom_keymap_table();
  if (custom_keymap_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_keymap_table_ = new ::std::string;
  }
  return custom_keymap_table_;
}
inline ::std::string* Config::release_custom_keymap_table() {
  clear_has_custom_keymap_table();
  if (custom_keymap_table_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_keymap_table_;
    custom_keymap_table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Config::set_allocated_custom_keymap_table(::std::string* custom_keymap_table) {
  if (custom_keymap_table_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_keymap_table_;
  }
  if (custom_keymap_table) {
    set_has_custom_keymap_table();
    custom_keymap_table_ = custom_keymap_table;
  } else {
    clear_has_custom_keymap_table();
    custom_keymap_table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes custom_roman_table = 43;
inline bool Config::has_custom_roman_table() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Config::set_has_custom_roman_table() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Config::clear_has_custom_roman_table() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Config::clear_custom_roman_table() {
  if (custom_roman_table_ != &::google::protobuf::internal::kEmptyString) {
    custom_roman_table_->clear();
  }
  clear_has_custom_roman_table();
}
inline const ::std::string& Config::custom_roman_table() const {
  return *custom_roman_table_;
}
inline void Config::set_custom_roman_table(const ::std::string& value) {
  set_has_custom_roman_table();
  if (custom_roman_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_roman_table_ = new ::std::string;
  }
  custom_roman_table_->assign(value);
}
inline void Config::set_custom_roman_table(const char* value) {
  set_has_custom_roman_table();
  if (custom_roman_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_roman_table_ = new ::std::string;
  }
  custom_roman_table_->assign(value);
}
inline void Config::set_custom_roman_table(const void* value, size_t size) {
  set_has_custom_roman_table();
  if (custom_roman_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_roman_table_ = new ::std::string;
  }
  custom_roman_table_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_custom_roman_table() {
  set_has_custom_roman_table();
  if (custom_roman_table_ == &::google::protobuf::internal::kEmptyString) {
    custom_roman_table_ = new ::std::string;
  }
  return custom_roman_table_;
}
inline ::std::string* Config::release_custom_roman_table() {
  clear_has_custom_roman_table();
  if (custom_roman_table_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custom_roman_table_;
    custom_roman_table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Config::set_allocated_custom_roman_table(::std::string* custom_roman_table) {
  if (custom_roman_table_ != &::google::protobuf::internal::kEmptyString) {
    delete custom_roman_table_;
  }
  if (custom_roman_table) {
    set_has_custom_roman_table();
    custom_roman_table_ = custom_roman_table;
  } else {
    clear_has_custom_roman_table();
    custom_roman_table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
inline bool Config::has_punctuation_method() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Config::set_has_punctuation_method() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Config::clear_has_punctuation_method() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Config::clear_punctuation_method() {
  punctuation_method_ = 0;
  clear_has_punctuation_method();
}
inline ::mozc::config::Config_PunctuationMethod Config::punctuation_method() const {
  return static_cast< ::mozc::config::Config_PunctuationMethod >(punctuation_method_);
}
inline void Config::set_punctuation_method(::mozc::config::Config_PunctuationMethod value) {
  assert(::mozc::config::Config_PunctuationMethod_IsValid(value));
  set_has_punctuation_method();
  punctuation_method_ = value;
}

// optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
inline bool Config::has_symbol_method() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Config::set_has_symbol_method() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Config::clear_has_symbol_method() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Config::clear_symbol_method() {
  symbol_method_ = 0;
  clear_has_symbol_method();
}
inline ::mozc::config::Config_SymbolMethod Config::symbol_method() const {
  return static_cast< ::mozc::config::Config_SymbolMethod >(symbol_method_);
}
inline void Config::set_symbol_method(::mozc::config::Config_SymbolMethod value) {
  assert(::mozc::config::Config_SymbolMethod_IsValid(value));
  set_has_symbol_method();
  symbol_method_ = value;
}

// optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
inline bool Config::has_space_character_form() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Config::set_has_space_character_form() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Config::clear_has_space_character_form() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Config::clear_space_character_form() {
  space_character_form_ = 0;
  clear_has_space_character_form();
}
inline ::mozc::config::Config_FundamentalCharacterForm Config::space_character_form() const {
  return static_cast< ::mozc::config::Config_FundamentalCharacterForm >(space_character_form_);
}
inline void Config::set_space_character_form(::mozc::config::Config_FundamentalCharacterForm value) {
  assert(::mozc::config::Config_FundamentalCharacterForm_IsValid(value));
  set_has_space_character_form();
  space_character_form_ = value;
}

// optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
inline bool Config::has_use_keyboard_to_change_preedit_method() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Config::set_has_use_keyboard_to_change_preedit_method() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Config::clear_has_use_keyboard_to_change_preedit_method() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Config::clear_use_keyboard_to_change_preedit_method() {
  use_keyboard_to_change_preedit_method_ = false;
  clear_has_use_keyboard_to_change_preedit_method();
}
inline bool Config::use_keyboard_to_change_preedit_method() const {
  return use_keyboard_to_change_preedit_method_;
}
inline void Config::set_use_keyboard_to_change_preedit_method(bool value) {
  set_has_use_keyboard_to_change_preedit_method();
  use_keyboard_to_change_preedit_method_ = value;
}

// optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
inline bool Config::has_history_learning_level() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Config::set_has_history_learning_level() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Config::clear_has_history_learning_level() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Config::clear_history_learning_level() {
  history_learning_level_ = 0;
  clear_has_history_learning_level();
}
inline ::mozc::config::Config_HistoryLearningLevel Config::history_learning_level() const {
  return static_cast< ::mozc::config::Config_HistoryLearningLevel >(history_learning_level_);
}
inline void Config::set_history_learning_level(::mozc::config::Config_HistoryLearningLevel value) {
  assert(::mozc::config::Config_HistoryLearningLevel_IsValid(value));
  set_has_history_learning_level();
  history_learning_level_ = value;
}

// optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
inline bool Config::has_selection_shortcut() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Config::set_has_selection_shortcut() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Config::clear_has_selection_shortcut() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Config::clear_selection_shortcut() {
  selection_shortcut_ = 1;
  clear_has_selection_shortcut();
}
inline ::mozc::config::Config_SelectionShortcut Config::selection_shortcut() const {
  return static_cast< ::mozc::config::Config_SelectionShortcut >(selection_shortcut_);
}
inline void Config::set_selection_shortcut(::mozc::config::Config_SelectionShortcut value) {
  assert(::mozc::config::Config_SelectionShortcut_IsValid(value));
  set_has_selection_shortcut();
  selection_shortcut_ = value;
}

// repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
inline int Config::character_form_rules_size() const {
  return character_form_rules_.size();
}
inline void Config::clear_character_form_rules() {
  character_form_rules_.Clear();
}
inline const ::mozc::config::Config_CharacterFormRule& Config::character_form_rules(int index) const {
  return character_form_rules_.Get(index);
}
inline ::mozc::config::Config_CharacterFormRule* Config::mutable_character_form_rules(int index) {
  return character_form_rules_.Mutable(index);
}
inline ::mozc::config::Config_CharacterFormRule* Config::add_character_form_rules() {
  return character_form_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >&
Config::character_form_rules() const {
  return character_form_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozc::config::Config_CharacterFormRule >*
Config::mutable_character_form_rules() {
  return &character_form_rules_;
}

// optional bool use_auto_ime_turn_off = 56 [default = true];
inline bool Config::has_use_auto_ime_turn_off() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Config::set_has_use_auto_ime_turn_off() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Config::clear_has_use_auto_ime_turn_off() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Config::clear_use_auto_ime_turn_off() {
  use_auto_ime_turn_off_ = true;
  clear_has_use_auto_ime_turn_off();
}
inline bool Config::use_auto_ime_turn_off() const {
  return use_auto_ime_turn_off_;
}
inline void Config::set_use_auto_ime_turn_off(bool value) {
  set_has_use_auto_ime_turn_off();
  use_auto_ime_turn_off_ = value;
}

// optional bool use_cascading_window = 58 [default = true];
inline bool Config::has_use_cascading_window() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Config::set_has_use_cascading_window() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Config::clear_has_use_cascading_window() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Config::clear_use_cascading_window() {
  use_cascading_window_ = true;
  clear_has_use_cascading_window();
}
inline bool Config::use_cascading_window() const {
  return use_cascading_window_;
}
inline void Config::set_use_cascading_window(bool value) {
  set_has_use_cascading_window();
  use_cascading_window_ = value;
}

// optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
inline bool Config::has_shift_key_mode_switch() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Config::set_has_shift_key_mode_switch() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Config::clear_has_shift_key_mode_switch() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Config::clear_shift_key_mode_switch() {
  shift_key_mode_switch_ = 1;
  clear_has_shift_key_mode_switch();
}
inline ::mozc::config::Config_ShiftKeyModeSwitch Config::shift_key_mode_switch() const {
  return static_cast< ::mozc::config::Config_ShiftKeyModeSwitch >(shift_key_mode_switch_);
}
inline void Config::set_shift_key_mode_switch(::mozc::config::Config_ShiftKeyModeSwitch value) {
  assert(::mozc::config::Config_ShiftKeyModeSwitch_IsValid(value));
  set_has_shift_key_mode_switch();
  shift_key_mode_switch_ = value;
}

// optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
inline bool Config::has_numpad_character_form() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Config::set_has_numpad_character_form() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Config::clear_has_numpad_character_form() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Config::clear_numpad_character_form() {
  numpad_character_form_ = 2;
  clear_has_numpad_character_form();
}
inline ::mozc::config::Config_NumpadCharacterForm Config::numpad_character_form() const {
  return static_cast< ::mozc::config::Config_NumpadCharacterForm >(numpad_character_form_);
}
inline void Config::set_numpad_character_form(::mozc::config::Config_NumpadCharacterForm value) {
  assert(::mozc::config::Config_NumpadCharacterForm_IsValid(value));
  set_has_numpad_character_form();
  numpad_character_form_ = value;
}

// optional bool use_auto_conversion = 61 [default = false];
inline bool Config::has_use_auto_conversion() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Config::set_has_use_auto_conversion() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Config::clear_has_use_auto_conversion() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Config::clear_use_auto_conversion() {
  use_auto_conversion_ = false;
  clear_has_use_auto_conversion();
}
inline bool Config::use_auto_conversion() const {
  return use_auto_conversion_;
}
inline void Config::set_use_auto_conversion(bool value) {
  set_has_use_auto_conversion();
  use_auto_conversion_ = value;
}

// optional uint32 auto_conversion_key = 62 [default = 13];
inline bool Config::has_auto_conversion_key() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Config::set_has_auto_conversion_key() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Config::clear_has_auto_conversion_key() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Config::clear_auto_conversion_key() {
  auto_conversion_key_ = 13u;
  clear_has_auto_conversion_key();
}
inline ::google::protobuf::uint32 Config::auto_conversion_key() const {
  return auto_conversion_key_;
}
inline void Config::set_auto_conversion_key(::google::protobuf::uint32 value) {
  set_has_auto_conversion_key();
  auto_conversion_key_ = value;
}

// optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
inline bool Config::has_yen_sign_character() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Config::set_has_yen_sign_character() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Config::clear_has_yen_sign_character() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Config::clear_yen_sign_character() {
  yen_sign_character_ = 0;
  clear_has_yen_sign_character();
}
inline ::mozc::config::Config_YenSignCharacter Config::yen_sign_character() const {
  return static_cast< ::mozc::config::Config_YenSignCharacter >(yen_sign_character_);
}
inline void Config::set_yen_sign_character(::mozc::config::Config_YenSignCharacter value) {
  assert(::mozc::config::Config_YenSignCharacter_IsValid(value));
  set_has_yen_sign_character();
  yen_sign_character_ = value;
}

// optional bool use_japanese_layout = 64 [default = false];
inline bool Config::has_use_japanese_layout() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Config::set_has_use_japanese_layout() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Config::clear_has_use_japanese_layout() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Config::clear_use_japanese_layout() {
  use_japanese_layout_ = false;
  clear_has_use_japanese_layout();
}
inline bool Config::use_japanese_layout() const {
  return use_japanese_layout_;
}
inline void Config::set_use_japanese_layout(bool value) {
  set_has_use_japanese_layout();
  use_japanese_layout_ = value;
}

// optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
inline bool Config::has_use_kana_modifier_insensitive_conversion() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Config::set_has_use_kana_modifier_insensitive_conversion() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Config::clear_has_use_kana_modifier_insensitive_conversion() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Config::clear_use_kana_modifier_insensitive_conversion() {
  use_kana_modifier_insensitive_conversion_ = false;
  clear_has_use_kana_modifier_insensitive_conversion();
}
inline bool Config::use_kana_modifier_insensitive_conversion() const {
  return use_kana_modifier_insensitive_conversion_;
}
inline void Config::set_use_kana_modifier_insensitive_conversion(bool value) {
  set_has_use_kana_modifier_insensitive_conversion();
  use_kana_modifier_insensitive_conversion_ = value;
}

// optional bool use_typing_correction = 66 [default = false];
inline bool Config::has_use_typing_correction() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Config::set_has_use_typing_correction() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Config::clear_has_use_typing_correction() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Config::clear_use_typing_correction() {
  use_typing_correction_ = false;
  clear_has_use_typing_correction();
}
inline bool Config::use_typing_correction() const {
  return use_typing_correction_;
}
inline void Config::set_use_typing_correction(bool value) {
  set_has_use_typing_correction();
  use_typing_correction_ = value;
}

// optional bool use_date_conversion = 80 [default = true];
inline bool Config::has_use_date_conversion() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Config::set_has_use_date_conversion() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Config::clear_has_use_date_conversion() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Config::clear_use_date_conversion() {
  use_date_conversion_ = true;
  clear_has_use_date_conversion();
}
inline bool Config::use_date_conversion() const {
  return use_date_conversion_;
}
inline void Config::set_use_date_conversion(bool value) {
  set_has_use_date_conversion();
  use_date_conversion_ = value;
}

// optional bool use_single_kanji_conversion = 81 [default = true];
inline bool Config::has_use_single_kanji_conversion() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Config::set_has_use_single_kanji_conversion() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Config::clear_has_use_single_kanji_conversion() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Config::clear_use_single_kanji_conversion() {
  use_single_kanji_conversion_ = true;
  clear_has_use_single_kanji_conversion();
}
inline bool Config::use_single_kanji_conversion() const {
  return use_single_kanji_conversion_;
}
inline void Config::set_use_single_kanji_conversion(bool value) {
  set_has_use_single_kanji_conversion();
  use_single_kanji_conversion_ = value;
}

// optional bool use_symbol_conversion = 82 [default = true];
inline bool Config::has_use_symbol_conversion() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Config::set_has_use_symbol_conversion() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Config::clear_has_use_symbol_conversion() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Config::clear_use_symbol_conversion() {
  use_symbol_conversion_ = true;
  clear_has_use_symbol_conversion();
}
inline bool Config::use_symbol_conversion() const {
  return use_symbol_conversion_;
}
inline void Config::set_use_symbol_conversion(bool value) {
  set_has_use_symbol_conversion();
  use_symbol_conversion_ = value;
}

// optional bool use_number_conversion = 83 [default = true];
inline bool Config::has_use_number_conversion() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Config::set_has_use_number_conversion() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Config::clear_has_use_number_conversion() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Config::clear_use_number_conversion() {
  use_number_conversion_ = true;
  clear_has_use_number_conversion();
}
inline bool Config::use_number_conversion() const {
  return use_number_conversion_;
}
inline void Config::set_use_number_conversion(bool value) {
  set_has_use_number_conversion();
  use_number_conversion_ = value;
}

// optional bool use_emoticon_conversion = 84 [default = true];
inline bool Config::has_use_emoticon_conversion() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Config::set_has_use_emoticon_conversion() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Config::clear_has_use_emoticon_conversion() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Config::clear_use_emoticon_conversion() {
  use_emoticon_conversion_ = true;
  clear_has_use_emoticon_conversion();
}
inline bool Config::use_emoticon_conversion() const {
  return use_emoticon_conversion_;
}
inline void Config::set_use_emoticon_conversion(bool value) {
  set_has_use_emoticon_conversion();
  use_emoticon_conversion_ = value;
}

// optional bool use_calculator = 85 [default = true];
inline bool Config::has_use_calculator() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Config::set_has_use_calculator() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Config::clear_has_use_calculator() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Config::clear_use_calculator() {
  use_calculator_ = true;
  clear_has_use_calculator();
}
inline bool Config::use_calculator() const {
  return use_calculator_;
}
inline void Config::set_use_calculator(bool value) {
  set_has_use_calculator();
  use_calculator_ = value;
}

// optional bool use_t13n_conversion = 86 [default = true];
inline bool Config::has_use_t13n_conversion() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Config::set_has_use_t13n_conversion() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Config::clear_has_use_t13n_conversion() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Config::clear_use_t13n_conversion() {
  use_t13n_conversion_ = true;
  clear_has_use_t13n_conversion();
}
inline bool Config::use_t13n_conversion() const {
  return use_t13n_conversion_;
}
inline void Config::set_use_t13n_conversion(bool value) {
  set_has_use_t13n_conversion();
  use_t13n_conversion_ = value;
}

// optional bool use_zip_code_conversion = 87 [default = true];
inline bool Config::has_use_zip_code_conversion() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Config::set_has_use_zip_code_conversion() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Config::clear_has_use_zip_code_conversion() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Config::clear_use_zip_code_conversion() {
  use_zip_code_conversion_ = true;
  clear_has_use_zip_code_conversion();
}
inline bool Config::use_zip_code_conversion() const {
  return use_zip_code_conversion_;
}
inline void Config::set_use_zip_code_conversion(bool value) {
  set_has_use_zip_code_conversion();
  use_zip_code_conversion_ = value;
}

// optional bool use_spelling_correction = 88 [default = true];
inline bool Config::has_use_spelling_correction() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Config::set_has_use_spelling_correction() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Config::clear_has_use_spelling_correction() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Config::clear_use_spelling_correction() {
  use_spelling_correction_ = true;
  clear_has_use_spelling_correction();
}
inline bool Config::use_spelling_correction() const {
  return use_spelling_correction_;
}
inline void Config::set_use_spelling_correction(bool value) {
  set_has_use_spelling_correction();
  use_spelling_correction_ = value;
}

// optional bool use_emoji_conversion = 89 [default = false];
inline bool Config::has_use_emoji_conversion() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Config::set_has_use_emoji_conversion() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Config::clear_has_use_emoji_conversion() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Config::clear_use_emoji_conversion() {
  use_emoji_conversion_ = false;
  clear_has_use_emoji_conversion();
}
inline bool Config::use_emoji_conversion() const {
  return use_emoji_conversion_;
}
inline void Config::set_use_emoji_conversion(bool value) {
  set_has_use_emoji_conversion();
  use_emoji_conversion_ = value;
}

// optional .mozc.config.Config.InformationListConfig information_list_config = 90;
inline bool Config::has_information_list_config() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Config::set_has_information_list_config() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Config::clear_has_information_list_config() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Config::clear_information_list_config() {
  if (information_list_config_ != NULL) information_list_config_->::mozc::config::Config_InformationListConfig::Clear();
  clear_has_information_list_config();
}
inline const ::mozc::config::Config_InformationListConfig& Config::information_list_config() const {
  return information_list_config_ != NULL ? *information_list_config_ : *default_instance_->information_list_config_;
}
inline ::mozc::config::Config_InformationListConfig* Config::mutable_information_list_config() {
  set_has_information_list_config();
  if (information_list_config_ == NULL) information_list_config_ = new ::mozc::config::Config_InformationListConfig;
  return information_list_config_;
}
inline ::mozc::config::Config_InformationListConfig* Config::release_information_list_config() {
  clear_has_information_list_config();
  ::mozc::config::Config_InformationListConfig* temp = information_list_config_;
  information_list_config_ = NULL;
  return temp;
}
inline void Config::set_allocated_information_list_config(::mozc::config::Config_InformationListConfig* information_list_config) {
  delete information_list_config_;
  information_list_config_ = information_list_config;
  if (information_list_config) {
    set_has_information_list_config();
  } else {
    clear_has_information_list_config();
  }
}

// optional bool use_history_suggest = 100 [default = true];
inline bool Config::has_use_history_suggest() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Config::set_has_use_history_suggest() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Config::clear_has_use_history_suggest() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Config::clear_use_history_suggest() {
  use_history_suggest_ = true;
  clear_has_use_history_suggest();
}
inline bool Config::use_history_suggest() const {
  return use_history_suggest_;
}
inline void Config::set_use_history_suggest(bool value) {
  set_has_use_history_suggest();
  use_history_suggest_ = value;
}

// optional bool use_dictionary_suggest = 101 [default = true];
inline bool Config::has_use_dictionary_suggest() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Config::set_has_use_dictionary_suggest() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Config::clear_has_use_dictionary_suggest() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Config::clear_use_dictionary_suggest() {
  use_dictionary_suggest_ = true;
  clear_has_use_dictionary_suggest();
}
inline bool Config::use_dictionary_suggest() const {
  return use_dictionary_suggest_;
}
inline void Config::set_use_dictionary_suggest(bool value) {
  set_has_use_dictionary_suggest();
  use_dictionary_suggest_ = value;
}

// optional bool use_realtime_conversion = 102 [default = true];
inline bool Config::has_use_realtime_conversion() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Config::set_has_use_realtime_conversion() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Config::clear_has_use_realtime_conversion() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Config::clear_use_realtime_conversion() {
  use_realtime_conversion_ = true;
  clear_has_use_realtime_conversion();
}
inline bool Config::use_realtime_conversion() const {
  return use_realtime_conversion_;
}
inline void Config::set_use_realtime_conversion(bool value) {
  set_has_use_realtime_conversion();
  use_realtime_conversion_ = value;
}

// optional uint32 suggestions_size = 110 [default = 3];
inline bool Config::has_suggestions_size() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Config::set_has_suggestions_size() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Config::clear_has_suggestions_size() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Config::clear_suggestions_size() {
  suggestions_size_ = 3u;
  clear_has_suggestions_size();
}
inline ::google::protobuf::uint32 Config::suggestions_size() const {
  return suggestions_size_;
}
inline void Config::set_suggestions_size(::google::protobuf::uint32 value) {
  set_has_suggestions_size();
  suggestions_size_ = value;
}

// optional bool use_mode_indicator = 120 [default = true];
inline bool Config::has_use_mode_indicator() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Config::set_has_use_mode_indicator() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Config::clear_has_use_mode_indicator() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Config::clear_use_mode_indicator() {
  use_mode_indicator_ = true;
  clear_has_use_mode_indicator();
}
inline bool Config::use_mode_indicator() const {
  return use_mode_indicator_;
}
inline void Config::set_use_mode_indicator(bool value) {
  set_has_use_mode_indicator();
  use_mode_indicator_ = value;
}

// optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;
inline bool Config::has_obsolete_sync_config() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Config::set_has_obsolete_sync_config() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Config::clear_has_obsolete_sync_config() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Config::clear_obsolete_sync_config() {
  if (obsolete_sync_config_ != NULL) obsolete_sync_config_->::mozc::config::OBSOLETE_SyncConfig::Clear();
  clear_has_obsolete_sync_config();
}
inline const ::mozc::config::OBSOLETE_SyncConfig& Config::obsolete_sync_config() const {
  return obsolete_sync_config_ != NULL ? *obsolete_sync_config_ : *default_instance_->obsolete_sync_config_;
}
inline ::mozc::config::OBSOLETE_SyncConfig* Config::mutable_obsolete_sync_config() {
  set_has_obsolete_sync_config();
  if (obsolete_sync_config_ == NULL) obsolete_sync_config_ = new ::mozc::config::OBSOLETE_SyncConfig;
  return obsolete_sync_config_;
}
inline ::mozc::config::OBSOLETE_SyncConfig* Config::release_obsolete_sync_config() {
  clear_has_obsolete_sync_config();
  ::mozc::config::OBSOLETE_SyncConfig* temp = obsolete_sync_config_;
  obsolete_sync_config_ = NULL;
  return temp;
}
inline void Config::set_allocated_obsolete_sync_config(::mozc::config::OBSOLETE_SyncConfig* obsolete_sync_config) {
  delete obsolete_sync_config_;
  obsolete_sync_config_ = obsolete_sync_config;
  if (obsolete_sync_config) {
    set_has_obsolete_sync_config();
  } else {
    clear_has_obsolete_sync_config();
  }
}

// optional bool allow_cloud_handwriting = 301 [default = false];
inline bool Config::has_allow_cloud_handwriting() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Config::set_has_allow_cloud_handwriting() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Config::clear_has_allow_cloud_handwriting() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Config::clear_allow_cloud_handwriting() {
  allow_cloud_handwriting_ = false;
  clear_has_allow_cloud_handwriting();
}
inline bool Config::allow_cloud_handwriting() const {
  return allow_cloud_handwriting_;
}
inline void Config::set_allow_cloud_handwriting(bool value) {
  set_has_allow_cloud_handwriting();
  allow_cloud_handwriting_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace mozc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PreeditMethod>() {
  return ::mozc::config::Config_PreeditMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SessionKeymap>() {
  return ::mozc::config::Config_SessionKeymap_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_PunctuationMethod>() {
  return ::mozc::config::Config_PunctuationMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SymbolMethod>() {
  return ::mozc::config::Config_SymbolMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_FundamentalCharacterForm>() {
  return ::mozc::config::Config_FundamentalCharacterForm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_HistoryLearningLevel>() {
  return ::mozc::config::Config_HistoryLearningLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_SelectionShortcut>() {
  return ::mozc::config::Config_SelectionShortcut_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_CharacterForm>() {
  return ::mozc::config::Config_CharacterForm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_ShiftKeyModeSwitch>() {
  return ::mozc::config::Config_ShiftKeyModeSwitch_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_NumpadCharacterForm>() {
  return ::mozc::config::Config_NumpadCharacterForm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_AutoConversionKey>() {
  return ::mozc::config::Config_AutoConversionKey_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mozc::config::Config_YenSignCharacter>() {
  return ::mozc::config::Config_YenSignCharacter_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2fconfig_2eproto__INCLUDED
